{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"JAX-LaB's home","text":""},{"location":"#jax-lab-a-python-based-accelerated-differentiable-massively-parallel-lattice-boltzmann-library-for-modeling-multiphase-and-multiphysics-flows-physics-based-machine-learning","title":"JAX-LaB: A Python-based, Accelerated, Differentiable Massively Parallel Lattice Boltzmann Library for Modeling Multiphase and Multiphysics Flows &amp; Physics-Based Machine Learning","text":"<p>JAX-LaB is a fully differentiable, accelerated multiphysics and multiphase 2D/3D Lattice Boltzmann Method (LBM) Python library written in JAX and it provides a unified workflow for forward and inverse modeling of multiphase flows. JAX-LaB is an extension of XLB and adds support multiphase and multiphysics flows to the original library.</p>"},{"location":"#showcase","title":"Showcase","text":"<p>     Time evolution of liquid distribution in a porous medium during evaporation. Two-component (air\u2013water) system simulated with the Cascaded (central-moment) collision model. </p> <p> </p> <p>   On GPU in-situ rendering using PhantomGaze library (no I/O). Droplet impact on dry surface using MRT collision model with ~16 million cells.   (single component, multiphase simulation, density ratio: 350, fluid modeled using Peng-Robinson EOS). </p> <p> </p> <p>   In-situ GPU rendering of drainage in a porous geometry. BGK collision model, 110 million cells. </p> <p> </p> <p> Temporal evolution of the density field determined using neural network for the inverse multiphase flow control problem of forming a droplet at t = 900. The MLP output is used as the initial condition for LBM and the backpropagation step during training leverages the auto-differentiation capabilities of JAX-LaB (see paper for details). </p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Integration with JAX Ecosystem: The library can be easily integrated with JAX\u2019s robust ecosystem of machine learning libraries such as Equinox Flax, Haiku, Optax, and many more.</li> <li>Differentiable LBM Kernels: JAX-LaB provides differentiable LBM kernels that can be used in differentiable physics and deep learning applications.</li> <li>Scalability: JAX-LaB is capable of scaling on distributed multi-GPU systems, enabling the execution of large-scale simulations on hundreds of GPUs with billions of cells.</li> <li>Support for Various LBM Boundary Conditions and Kernels: JAX-LaB supports several LBM boundary conditions and collision kernels.</li> <li>Support for Multiphase, Multiphysics and Multicomponent flows: JAX-LaB can accurately model multiphysics and multiphase flows using Shan-Chen method, simulating complex interface dynamics without tracking any interface.</li> <li>User-Friendly Interface: Written entirely in Python, JAX-LaB emphasizes a highly accessible interface that allows users to extend the library with ease and quickly set up and run new simulations.</li> <li>Leverages JAX Array and Shardmap: The library incorporates the new JAX array unified array type and JAX shardmap, providing users with a numpy-like interface. This allows users to focus solely on the semantics, leaving performance optimizations to the compiler.</li> <li>Platform Versatility: The same JAX-LaB code can be executed on a variety of platforms including multi-core CPUs, single or multi-GPU systems, TPUs, and it also supports distributed runs on multi-GPU systems or TPU Pod slices.</li> <li>Visualization: JAX-LaB provides a variety of visualization options including in-situ on GPU rendering using PhantomGaze.</li> </ul>"},{"location":"#capabilities","title":"Capabilities","text":""},{"location":"#multiphase-flow-modeling","title":"Multiphase Flow Modeling","text":"<p>Shan-Chen pseudopotential method with various modifications: - Support for high density ratio flows (tested for density ratios &gt; 10<sup>8</sup>) using improved forcing scheme. - Incorporates Equation of State (EOS) to model multiphase flows. Currently implemented EOS include Carnahan-Starling, Peng-Robinson, Redlich-Kwong, Redlich-Kwong-Soave and VanderWaals. - Density ratio independent surface tension control by directly modifying pressure tensor. - Improved wetting scheme to handle large range of contact angles without large spurious current or thick layers near solid surface.</p>"},{"location":"#multicomponent-flow-support","title":"Multicomponent Flow Support","text":"<p>JAX-LaB takes advantage of pytrees for computation hence, it can model any number of components (each with their own equation of state, initial condition and boundary conditions) without any user modification.</p>"},{"location":"#wetting-model","title":"Wetting model","text":"<ul> <li>Wetting behavior of fluids is modeled using the improved virtual density scheme which avoids the need to include separate fluid-solid interaction forces commonly seen in Shan-Chen method by directly updating the near-wall densities</li> <li>Wetting parameters can be passed by user while defining wall boundary conditions.</li> </ul>"},{"location":"#collision-models","title":"Collision Models","text":"<ul> <li>BGK</li> <li>Multi-Relaxation Time (MRT)</li> <li>Cascaded Model</li> <li>KBC</li> </ul>"},{"location":"#lattice","title":"Lattice","text":"<ul> <li>D2Q9</li> <li>D3Q19</li> <li>D3Q27</li> </ul>"},{"location":"#machine-learning","title":"Machine Learning","text":"<ul> <li>Easy integration with JAX\u2019s ecosystem of machine learning libraries</li> <li>Differentiable LBM kernels both for single and multiphase flows</li> <li>Differentiable boundary conditions</li> </ul>"},{"location":"#compute-capabilities","title":"Compute Capabilities","text":"<ul> <li>Distributed Multi-GPU support</li> <li>Mixed-Precision support (store vs compute)</li> <li>Out-of-core support (coming soon)</li> </ul>"},{"location":"#output","title":"Output","text":"<ul> <li>Binary and ASCII VTK output (based on PyVista library)</li> <li>In-situ rendering using PhantomGaze library</li> <li>Orbax-based distributed asynchronous checkpointing</li> <li>Image Output</li> <li>3D mesh voxelizer using trimesh</li> </ul>"},{"location":"#boundary-conditions","title":"Boundary conditions","text":"<ul> <li> <p>Equilibrium BC: In this boundary condition, the fluid populations are assumed to be in at equilibrium. Can be used to set prescribed velocity or pressure.</p> </li> <li> <p>Full-Way Bounceback BC: In this boundary condition, the velocity of the fluid populations is reflected back to the fluid side of the boundary, resulting in zero fluid velocity at the boundary.</p> </li> <li> <p>Half-Way Bounceback BC: Similar to the Full-Way Bounceback BC, in this boundary condition, the velocity of the fluid populations is partially reflected back to the fluid side of the boundary, resulting in a non-zero fluid velocity at the boundary.</p> </li> <li> <p>Do Nothing BC: In this boundary condition, the fluid populations are allowed to pass through the boundary without any reflection or modification.</p> </li> <li> <p>Zouhe BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary.</p> </li> <li>Regularized BC: This boundary condition is used to impose a prescribed velocity or pressure profile at the boundary. This BC is more stable than Zouhe BC, but computationally more expensive.</li> <li> <p>Extrapolation Outflow BC: A type of outflow boundary condition that uses extrapolation to avoid strong wave reflections.</p> </li> <li> <p>Interpolated Bounceback BC: Interpolated bounce-back boundary condition due to Bouzidi for a lattice Boltzmann method simulation.</p> </li> <li> <p>Convective Outflow BC: Convective outflow boundary condition, useful for porous media flows.</p> </li> </ul>"},{"location":"#accompanying-paper","title":"Accompanying Paper","text":"<p>A preprint of the paper, accepted for publication in Journal of Advances in Modeling Earth Systems (JAMES), is available on arXiv.</p>"},{"location":"#installation-guide","title":"Installation Guide","text":"<p>To use JAX-LaB, you must first install JAX and other dependencies using the following commands:</p> <p>Please refer to https://github.com/google/jax for the latest installation documentation. The following table is taken from JAX\u2019s Github page.</p> Hardware Instructions CPU <code>pip install -U \"jax[cpu]\"</code> NVIDIA GPU on x86_64 <code>pip install -U \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html</code> Google TPU <code>pip install -U \"jax[tpu]\" -f https://storage.googleapis.com/jax-releases/libtpu_releases.html</code> AMD GPU Use Docker or build from source. Apple GPU Follow Apple\u2019s instructions. <p>Note: We encountered challenges when executing XLB on Apple GPUs due to the lack of support for certain operations in the Metal backend. We advise using the CPU backend on Mac OS. We will be testing XLB on Apple\u2019s GPUs in the future and will update this section accordingly.</p> <p>Install dependencies:</p> <pre><code>pip install pyvista numpy matplotlib Rtree trimesh jmp orbax-checkpoint termcolor\n</code></pre> <p>Run an example:</p> <pre><code>git clone https://github.com/piyush-ppradhan/JAX-LaB\ncd JAX-LaB\nexport PYTHONPATH=.\npython3 examples/singlephase/cavity2d.py\n</code></pre>"},{"location":"base/","title":"JAX-LaB base","text":"<p>               Bases: <code>object</code></p> <p>LBMBase: A class that represents a base for Lattice Boltzmann Method simulation.</p>"},{"location":"base/#src.base.LBMBase--parameters","title":"Parameters","text":"<pre><code>lattice (object): The lattice object that contains the lattice structure and weights.\n\nomega (float): The relaxation parameter for the LBM simulation.\n\nnx (int): Number of grid points in the x-direction.\n\nny (int): Number of grid points in the y-direction.\n\nnz (int, optional): Number of grid points in the z-direction. Defaults to 0.\n\nprecision (str, optional): A string specifying the precision used for the simulation. Defaults to \"f32/f32\".\n</code></pre> Source code in <code>src/base.py</code> <pre><code>class LBMBase(object):\n    \"\"\"\n    LBMBase: A class that represents a base for Lattice Boltzmann Method simulation.\n\n    Parameters\n    ----------\n        lattice (object): The lattice object that contains the lattice structure and weights.\n\n        omega (float): The relaxation parameter for the LBM simulation.\n\n        nx (int): Number of grid points in the x-direction.\n\n        ny (int): Number of grid points in the y-direction.\n\n        nz (int, optional): Number of grid points in the z-direction. Defaults to 0.\n\n        precision (str, optional): A string specifying the precision used for the simulation. Defaults to \"f32/f32\".\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.omega = kwargs.get(\"omega\")\n        self.nx = kwargs.get(\"nx\")\n        self.ny = kwargs.get(\"ny\")\n        self.nz = kwargs.get(\"nz\")\n\n        self.precision = kwargs.get(\"precision\")\n        computedType, storedType = self.set_precisions(self.precision)\n        self.precisionPolicy = jmp.Policy(\n            compute_dtype=computedType,\n            param_dtype=computedType,\n            output_dtype=storedType,\n        )\n\n        self.lattice = kwargs.get(\"lattice\")\n        self.checkpointRate = kwargs.get(\"checkpoint_rate\", 0)\n        self.checkpointDir = kwargs.get(\"checkpoint_dir\", \"./checkpoints\")\n        self.downsamplingFactor = kwargs.get(\"downsampling_factor\", 1)\n        self.printInfoRate = kwargs.get(\"print_info_rate\", 100)\n        self.ioRate = kwargs.get(\"io_rate\", 0)\n        self.returnFpost = kwargs.get(\"return_fpost\", False)\n        self.computeMLUPS = kwargs.get(\"compute_MLUPS\", False)\n        self.restore_checkpoint = kwargs.get(\"restore_checkpoint\", False)\n        self.nDevices = jax.device_count()\n        self.backend = jax.default_backend()\n\n        if self.computeMLUPS:\n            self.restore_checkpoint = False\n            self.ioRate = 0\n            self.checkpointRate = 0\n            self.printInfoRate = 0\n\n        # Check for distributed mode\n        if self.nDevices &gt; jax.local_device_count():\n            print(\"WARNING: Running in distributed mode. Make sure that jax.distributed.initialize is called before performing any JAX computations.\")\n\n        self.c = self.lattice.c\n        self.q = self.lattice.q\n        self.w = self.lattice.w\n        self.dim = self.lattice.d\n\n        # Set the checkpoint manager\n        if self.checkpointRate &gt; 0:\n            mngr_options = orb.CheckpointManagerOptions(save_interval_steps=self.checkpointRate, max_to_keep=1)\n            # self.mngr = orb.CheckpointManager(self.checkpointDir, orb.PyTreeCheckpointer(), options=mngr_options)\n            self.mngr = orb.CheckpointManager(self.checkpointDir, options=mngr_options)\n        else:\n            self.mngr = None\n\n        # Adjust the number of grid points in the x direction, if necessary.\n        # If the number of grid points is not divisible by the number of devices\n        # it increases the number of grid points to the next multiple of the number of devices.\n        # This is done in order to accommodate the domain sharding per XLA device\n        nx, ny, nz = kwargs.get(\"nx\"), kwargs.get(\"ny\"), kwargs.get(\"nz\")\n        if None in {nx, ny, nz}:\n            raise ValueError(\"nx, ny, and nz must be provided. For 2D examples, nz must be set to 0.\")\n        self.nx = nx\n        if nx % self.nDevices:\n            self.nx = nx + (self.nDevices - nx % self.nDevices)\n            print(\n                colored(\"WARNING: nx increased from {} to {} in order to accommodate domain sharding per XLA device.\".format(nx, self.nx)),\n                \"yellow\",\n            )\n        self.ny = ny\n        self.nz = nz\n\n        # self.show_simulation_parameters()\n\n        # Store grid information\n        self.gridInfo = {\n            \"nx\": self.nx,\n            \"ny\": self.ny,\n            \"nz\": self.nz,\n            \"dim\": self.lattice.d,\n            \"lattice\": self.lattice,\n        }\n\n        P = PartitionSpec\n\n        # Define the right permutation\n        self.rightPerm = [(i, (i + 1) % self.nDevices) for i in range(self.nDevices)]\n        # Define the left permutation\n        self.leftPerm = [((i + 1) % self.nDevices, i) for i in range(self.nDevices)]\n\n        # Set up the sharding and streaming for 2D simulations\n        if self.dim == 2:\n            self.devices = mesh_utils.create_device_mesh((self.nDevices, 1, 1))\n            self.mesh = Mesh(self.devices, axis_names=(\"x\", \"y\", \"value\"))\n            self.sharding = NamedSharding(self.mesh, P(\"x\", \"y\", \"value\"))\n\n            self.streaming = jit(\n                shard_map(\n                    self.streaming_m,\n                    mesh=self.mesh,\n                    in_specs=P(\"x\", None, None),\n                    out_specs=P(\"x\", None, None),\n                    check_rep=False,\n                )\n            )\n\n        # Set up the sharding and streaming for 3D simulations\n        elif self.dim == 3:\n            self.devices = mesh_utils.create_device_mesh((self.nDevices, 1, 1, 1))\n            self.mesh = Mesh(self.devices, axis_names=(\"x\", \"y\", \"z\", \"value\"))\n            self.sharding = NamedSharding(self.mesh, P(\"x\", \"y\", \"z\", \"value\"))\n\n            self.streaming = jit(\n                shard_map(\n                    self.streaming_m,\n                    mesh=self.mesh,\n                    in_specs=P(\"x\", None, None, None),\n                    out_specs=P(\"x\", None, None, None),\n                    check_rep=False,\n                )\n            )\n\n        else:\n            raise ValueError(f\"dim = {self.dim} not supported\")\n\n        # Compute the bounding box indices for boundary conditions\n        self.boundingBoxIndices = self.bounding_box_indices()\n        # Create boundary data for the simulation\n        self._create_boundary_data()\n        self.force = self.get_force()\n\n    @property\n    def lattice(self):\n        return self._lattice\n\n    @lattice.setter\n    def lattice(self, value):\n        if value is None:\n            raise ValueError(\"Lattice type must be provided.\")\n        if self.nz == 0 and value.name not in [\"D2Q9\"]:\n            raise ValueError(\"For 2D simulations, lattice type must be LatticeD2Q9.\")\n        if self.nz != 0 and value.name not in [\"D3Q19\", \"D3Q15\", \"D3Q27\"]:\n            raise ValueError(\"For 3D simulations, lattice type must be LatticeD3Q19, or LatticeD3Q27.\")\n\n        self._lattice = value\n\n    @property\n    def omega(self):\n        return self._omega\n\n    @omega.setter\n    def omega(self, value):\n        if value is None:\n            raise ValueError(\"omega must be provided\")\n        self._omega = value\n\n    @property\n    def nx(self):\n        return self._nx\n\n    @nx.setter\n    def nx(self, value):\n        if value is None:\n            raise ValueError(\"nx must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"nx must be an integer\")\n        self._nx = value\n\n    @property\n    def ny(self):\n        return self._ny\n\n    @ny.setter\n    def ny(self, value):\n        if value is None:\n            raise ValueError(\"ny must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"ny must be an integer\")\n        self._ny = value\n\n    @property\n    def nz(self):\n        return self._nz\n\n    @nz.setter\n    def nz(self, value):\n        if value is None:\n            raise ValueError(\"nz must be provided\")\n        if not isinstance(value, int):\n            raise TypeError(\"nz must be an integer\")\n        self._nz = value\n\n    @property\n    def precision(self):\n        return self._precision\n\n    @precision.setter\n    def precision(self, value):\n        if not isinstance(value, str):\n            raise TypeError(\"precision must be a string\")\n        self._precision = value\n\n    @property\n    def checkpointRate(self):\n        return self._checkpointRate\n\n    @checkpointRate.setter\n    def checkpointRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"checkpointRate must be an integer\")\n        self._checkpointRate = value\n\n    @property\n    def checkpointDir(self):\n        return self._checkpointDir\n\n    @checkpointDir.setter\n    def checkpointDir(self, value):\n        if not isinstance(value, str):\n            raise TypeError(\"checkpointDir must be a string\")\n        self._checkpointDir = value\n\n    @property\n    def downsamplingFactor(self):\n        return self._downsamplingFactor\n\n    @downsamplingFactor.setter\n    def downsamplingFactor(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"downsamplingFactor must be an integer\")\n        self._downsamplingFactor = value\n\n    @property\n    def printInfoRate(self):\n        return self._printInfoRate\n\n    @printInfoRate.setter\n    def printInfoRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"printInfoRate must be an integer\")\n        self._printInfoRate = value\n\n    @property\n    def ioRate(self):\n        return self._ioRate\n\n    @ioRate.setter\n    def ioRate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"ioRate must be an integer\")\n        self._ioRate = value\n\n    @property\n    def returnFpost(self):\n        return self._returnFpost\n\n    @returnFpost.setter\n    def returnFpost(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"returnFpost must be a boolean\")\n        self._returnFpost = value\n\n    @property\n    def computeMLUPS(self):\n        return self._computeMLUPS\n\n    @computeMLUPS.setter\n    def computeMLUPS(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"computeMLUPS must be a boolean\")\n        self._computeMLUPS = value\n\n    @property\n    def restore_checkpoint(self):\n        return self._restore_checkpoint\n\n    @restore_checkpoint.setter\n    def restore_checkpoint(self, value):\n        if not isinstance(value, bool):\n            raise TypeError(\"restore_checkpoint must be a boolean\")\n        self._restore_checkpoint = value\n\n    @property\n    def nDevices(self):\n        return self._nDevices\n\n    @nDevices.setter\n    def nDevices(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"nDevices must be an integer\")\n        self._nDevices = value\n\n    def show_simulation_parameters(self):\n        attributes_to_show = [\n            \"omega\",\n            \"nx\",\n            \"ny\",\n            \"nz\",\n            \"dim\",\n            \"precision\",\n            \"lattice\",\n            \"checkpointRate\",\n            \"checkpointDir\",\n            \"downsamplingFactor\",\n            \"printInfoRate\",\n            \"ioRate\",\n            \"computeMLUPS\",\n            \"restore_checkpoint\",\n            \"backend\",\n            \"nDevices\",\n        ]\n\n        descriptive_names = {\n            \"omega\": \"Omega\",\n            \"nx\": \"Grid Points in X\",\n            \"ny\": \"Grid Points in Y\",\n            \"nz\": \"Grid Points in Z\",\n            \"dim\": \"Dimensionality\",\n            \"precision\": \"Precision Policy\",\n            \"lattice\": \"Lattice Type\",\n            \"checkpointRate\": \"Checkpoint Rate\",\n            \"checkpointDir\": \"Checkpoint Directory\",\n            \"downsamplingFactor\": \"Downsampling Factor\",\n            \"printInfoRate\": \"Print Info Rate\",\n            \"ioRate\": \"I/O Rate\",\n            \"computeMLUPS\": \"Compute MLUPS\",\n            \"restore_checkpoint\": \"Restore Checkpoint\",\n            \"backend\": \"Backend\",\n            \"nDevices\": \"Number of Devices\",\n        }\n        simulation_name = self.__class__.__name__\n\n        print(colored(f\"**** Simulation Parameters for {simulation_name} ****\", \"green\"))\n\n        header = f\"{colored('Parameter', 'blue'):&gt;30} | {colored('Value', 'yellow')}\"\n        print(header)\n        print(\"-\" * 50)\n\n        for attr in attributes_to_show:\n            value = getattr(self, attr, \"Attribute not set\")\n            descriptive_name = descriptive_names.get(attr, attr)  # Use the attribute name as a fallback\n            row = f\"{colored(descriptive_name, 'blue'):&gt;30} | {colored(value, 'yellow')}\"\n            print(row)\n\n    def _create_boundary_data(self):\n        \"\"\"\n        Create boundary data for the Lattice Boltzmann simulation by setting boundary conditions,\n        creating grid mask, and preparing local masks and normal arrays.\n        \"\"\"\n        self.BCs = []\n        self.set_boundary_conditions()\n        # Accumulate the indices of all BCs to create the grid mask with FALSE along directions that\n        # stream into a boundary voxel.\n        solid_halo_list = [np.array(bc.indices).T for bc in self.BCs if bc.isSolid]\n        solid_halo_voxels = np.unique(np.vstack(solid_halo_list), axis=0) if solid_halo_list else None\n\n        # Create the grid mask on each process\n        start = time.time()\n        grid_mask = self.create_grid_mask(solid_halo_voxels)\n        print(\"Time to create the grid mask:\", time.time() - start)\n\n        start = time.time()\n        for bc in self.BCs:\n            assert bc.implementationStep in [\"PostStreaming\", \"PostCollision\"]\n            bc.create_local_mask_and_normal_arrays(grid_mask)\n        print(\"Time to create the local masks and normal arrays:\", time.time() - start)\n\n    @partial(jit, static_argnums=(0, 1, 2, 4))\n    def distributed_array_init(self, shape, type, init_val=0, sharding=None):\n        \"\"\"\n        Initialize a distributed array using JAX, with a specified shape, data type, and initial value.\n        Optionally, provide a custom sharding strategy.\n\n        Parameters\n        ----------\n        shape (tuple): The shape of the array to be created.\n\n        type (dtype): The data type of the array to be created.\n\n        init_val (scalar, optional): The initial value to fill the array with. Defaults to 0.\n\n        sharding (Sharding, optional): The sharding strategy to use. Defaults to `self.sharding`.\n\n        Returns\n        -------\n        jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.\n        \"\"\"\n        if sharding is None:\n            sharding = self.sharding\n        x = jnp.full(shape=shape, fill_value=init_val, dtype=type)\n        return jax.lax.with_sharding_constraint(x, sharding)\n\n    @partial(jit, static_argnums=(0,))\n    def create_grid_mask(self, solid_halo_voxels):\n        \"\"\"\n        This function creates a mask for the background grid that accounts for the location of the boundaries.\n\n        Parameters\n        ----------\n        solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.\n\n        Returns\n        -------\n        A JAX array representing the grid mask of the grid.\n        \"\"\"\n        # Halo width (hw_x is different to accommodate the domain sharding per XLA device)\n        hw_x = self.nDevices\n        hw_y = hw_z = 1\n        if self.dim == 2:\n            grid_mask = self.distributed_array_init(\n                (self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.lattice.q),\n                jnp.bool_,\n                init_val=True,\n            )\n            grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(None))].set(False)\n            if solid_halo_voxels is not None:\n                solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n                solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n                grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n\n            grid_mask = self.streaming(grid_mask)\n            return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n        elif self.dim == 3:\n            grid_mask = self.distributed_array_init(\n                (\n                    self.nx + 2 * hw_x,\n                    self.ny + 2 * hw_y,\n                    self.nz + 2 * hw_z,\n                    self.lattice.q,\n                ),\n                jnp.bool_,\n                init_val=True,\n            )\n            grid_mask = grid_mask.at[\n                (\n                    slice(hw_x, -hw_x),\n                    slice(hw_y, -hw_y),\n                    slice(hw_z, -hw_z),\n                    slice(None),\n                )\n            ].set(False)\n            if solid_halo_voxels is not None:\n                solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n                solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n                solid_halo_voxels = solid_halo_voxels.at[:, 2].add(hw_z)\n                grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n            grid_mask = self.streaming(grid_mask)\n            return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n    def bounding_box_indices(self):\n        \"\"\"\n        This function calculates the indices of the bounding box of a 2D or 3D grid.\n        The bounding box is defined as the set of grid points on the outer edge of the grid.\n\n        Returns\n        -------\n        boundingBox (dict): A dictionary where keys are the names of the bounding box faces\n        (\"bottom\", \"top\", \"left\", \"right\" for 2D; additional \"front\", \"back\" for 3D), and values\n        are numpy arrays of indices corresponding to each face.\n        \"\"\"\n        if self.dim == 2:\n            # For a 2D grid, the bounding box consists of four edges: bottom, top, left, and right.\n            # Each edge is represented as an array of indices. For example, the bottom edge includes\n            # all points where the y-coordinate is 0, so its indices are [[i, 0] for i in range(self.nx)].\n            bounding_box = {\n                \"bottom\": np.array([[i, 0] for i in range(self.nx)], dtype=int),\n                \"top\": np.array([[i, self.ny - 1] for i in range(self.nx)], dtype=int),\n                \"left\": np.array([[0, i] for i in range(self.ny)], dtype=int),\n                \"right\": np.array([[self.nx - 1, i] for i in range(self.ny)], dtype=int),\n            }\n\n            return bounding_box\n\n        elif self.dim == 3:\n            # For a 3D grid, the bounding box consists of six faces: bottom, top, left, right, front, and back.\n            # Each face is represented as an array of indices. For example, the bottom face includes all points\n            # where the z-coordinate is 0, so its indices are [[i, j, 0] for i in range(self.nx) for j in range(self.ny)].\n            bounding_box = {\n                \"bottom\": np.array(\n                    [[i, j, 0] for i in range(self.nx) for j in range(self.ny)],\n                    dtype=int,\n                ),\n                \"top\": np.array(\n                    [[i, j, self.nz - 1] for i in range(self.nx) for j in range(self.ny)],\n                    dtype=int,\n                ),\n                \"left\": np.array(\n                    [[0, j, k] for j in range(self.ny) for k in range(self.nz)],\n                    dtype=int,\n                ),\n                \"right\": np.array(\n                    [[self.nx - 1, j, k] for j in range(self.ny) for k in range(self.nz)],\n                    dtype=int,\n                ),\n                \"front\": np.array(\n                    [[i, 0, k] for i in range(self.nx) for k in range(self.nz)],\n                    dtype=int,\n                ),\n                \"back\": np.array(\n                    [[i, self.ny - 1, k] for i in range(self.nx) for k in range(self.nz)],\n                    dtype=int,\n                ),\n            }\n\n            return bounding_box\n\n    def set_precisions(self, precision):\n        \"\"\"\n        This function sets the precision of the computations. The precision is defined by a pair of values,\n        representing the precision of the computation and the precision of the storage, respectively.\n\n        Parameters\n        ----------\n        precision (str): A string representing the desired precision. The string should be in the format\n        \"computation/storage\", where \"computation\" and \"storage\" are either \"f64\", \"f32\", or \"f16\",\n        representing 64-bit, 32-bit, or 16-bit floating point numbers, respectively.\n\n        Returns\n        -------\n        tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively.\n        If the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).\n        \"\"\"\n        return {\n            \"f64/f64\": (jnp.float64, jnp.float64),\n            \"f32/f32\": (jnp.float32, jnp.float32),\n            \"f32/f16\": (jnp.float32, jnp.float16),\n            \"f16/f16\": (jnp.float16, jnp.float16),\n            \"f64/f32\": (jnp.float64, jnp.float32),\n            \"f64/f16\": (jnp.float64, jnp.float16),\n        }.get(precision, (jnp.float32, jnp.float32))\n\n    def initialize_macroscopic_fields(self):\n        \"\"\"\n        This function initializes the macroscopic fields (density and velocity) to their default values.\n        The default density is 1 and the default velocity is 0.\n\n        Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class\n        to provide specific initial conditions.\n\n        Returns\n        -------\n        None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.\n        \"\"\"\n        print(\"WARNING: Default initial conditions assumed: density = 1, velocity = 0\")\n        print(\"         To set explicit initial density and velocity, use self.initialize_macroscopic_fields.\")\n        return None, None\n\n    def assign_fields_sharded(self):\n        \"\"\"\n        This function is used to initialize the simulation by assigning the macroscopic fields and populations.\n\n        The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0).\n        Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the\n        distribution functions (f).\n\n        If the density or velocity are not provided, the function initializes the distribution functions with a default\n        value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.\n        \"\"\"\n        rho0, u0 = self.initialize_macroscopic_fields()\n\n        if self.dim == 2:\n            shape = (self.nx, self.ny, self.lattice.q)\n        if self.dim == 3:\n            shape = (self.nx, self.ny, self.nz, self.lattice.q)\n\n        if rho0 is None or u0 is None:\n            f = self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w)\n        else:\n            f = self.initialize_populations(rho0, u0)\n\n        return f\n\n    def initialize_populations(self, rho0, u0):\n        \"\"\"\n        This function initializes the populations (distribution functions) for the simulation.\n        It uses the equilibrium distribution function, which is a function of the macroscopic\n        density and velocity.\n\n        Parameters\n        ----------\n        rho0 (jax.numpy.ndarray): Initial density field.\n\n        u0 (jax.numpy.ndarray): Initial velocity field.\n\n        Returns\n        -------\n        f (jax.numpy.ndarray): The array holding the initialized distribution functions for the simulation.\n        \"\"\"\n        return self.equilibrium(rho0, u0)\n\n    def send_right(self, x, axis_name):\n        \"\"\"\n        This function sends the data to the right neighboring process in a parallel computing environment.\n        It uses a permutation operation provided by the LAX library.\n\n        Parameters\n        ----------\n        x (jax.numpy.ndarray): The data to be sent.\n\n        axis_name (str): The name of the axis along which the data is sent.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): The data after being sent to the right neighboring process.\n        \"\"\"\n        return lax.ppermute(x, perm=self.rightPerm, axis_name=axis_name)\n\n    def send_left(self, x, axis_name):\n        \"\"\"\n        This function sends the data to the left neighboring process in a parallel computing environment.\n        It uses a permutation operation provided by the LAX library.\n\n        Parameters\n        ----------\n        x (jax.numpy.ndarray): The data to be sent.\n\n        axis_name (str): The name of the axis along which the data is sent.\n\n        Returns\n        -------\n        The data after being sent to the left neighboring process.\n        \"\"\"\n        return lax.ppermute(x, perm=self.leftPerm, axis_name=axis_name)\n\n    def streaming_m(self, f):\n        \"\"\"\n        This function performs the streaming step in the Lattice Boltzmann Method, which is\n        the propagation of the distribution functions in the lattice.\n\n        To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the\n        distribution functions that need to be communicated to the neighboring processes.\n\n        The function then sends the left boundary slice to the right neighboring process and the right\n        boundary slice to the left neighboring process. The received data is then set to the\n        corresponding indices in the receiving domain.\n\n        Parameters\n        ----------\n        f (jax.numpy.ndarray): The array holding the distribution functions for the simulation.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): The distribution functions after the streaming operation.\n        \"\"\"\n        f = self.streaming_p(f)\n        left_comm, right_comm = (\n            f[:1, ..., self.lattice.right_indices],\n            f[-1:, ..., self.lattice.left_indices],\n        )\n\n        left_comm, right_comm = (\n            self.send_right(left_comm, \"x\"),\n            self.send_left(right_comm, \"x\"),\n        )\n        f = f.at[:1, ..., self.lattice.right_indices].set(left_comm)\n        f = f.at[-1:, ..., self.lattice.left_indices].set(right_comm)\n        return f\n\n    @partial(jit, static_argnums=(0,))\n    def streaming_p(self, f):\n        \"\"\"\n        Perform streaming operation on a partitioned (in the x-direction) distribution function.\n\n        The function uses the vmap operation provided by the JAX library to vectorize the computation\n        over all lattice directions.\n\n        Parameters\n        ----------\n        f: The distribution function.\n\n        Returns\n        -------\n        The updated distribution function after streaming.\n        \"\"\"\n\n        def streaming_i(f, c):\n            \"\"\"\n            Perform individual streaming operation in a direction.\n\n            Parameters\n            ----------\n                f: The distribution function.\n                c: The streaming direction vector.\n\n            Returns\n            -------\n                jax.numpy.ndarray\n                The updated distribution function after streaming.\n            \"\"\"\n            if self.dim == 2:\n                return jnp.roll(f, (c[0], c[1]), axis=(0, 1))\n            elif self.dim == 3:\n                return jnp.roll(f, (c[0], c[1], c[2]), axis=(0, 1, 2))\n\n        return vmap(streaming_i, in_axes=(-1, 0), out_axes=-1)(f, self.c.T)\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def equilibrium(self, rho, u, cast_output=True):\n        \"\"\"\n        This function computes the equilibrium distribution function in the Lattice Boltzmann Method.\n        The equilibrium distribution function is a function of the macroscopic density and velocity.\n\n        The function first casts the density and velocity to the compute precision if the cast_output flag is True.\n        The function finally casts the equilibrium distribution function to the output precision if the cast_output\n        flag is True.\n\n        Parameters\n        ----------\n        rho (jax.numpy.ndarray): The macroscopic density.\n\n        u (jax.numpy.ndarray): The macroscopic velocity.\n\n        cast_output (bool, optional): A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the\n        compute and output precisions. Default is True.\n\n        Returns\n        -------\n        feq (jax.numpy.ndarray): The equilibrium distribution function.\n        \"\"\"\n        # Cast the density and velocity to the compute precision if the cast_output flag is True\n        if cast_output:\n            rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n\n        # Cast c to compute precision so that XLA call FXX matmul,\n        # which is faster (it is faster in some older versions of JAX, newer versions are smart enough to do this automatically)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 3.0 * jnp.dot(u, c)\n        usqr = 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True)\n        feq = rho * self.w * (1.0 + cu * (1.0 + 0.5 * cu) - usqr)\n\n        if cast_output:\n            return self.precisionPolicy.cast_to_output(feq)\n        else:\n            return feq\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_flux(self, fneq):\n        \"\"\"\n        This function computes the momentum flux, which is the product of the non-equilibrium\n        distribution functions (fneq) and the lattice moments (cc).\n\n        The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann\n        Method (LBM).\n\n        Parameters\n        ----------\n        fneq (jax.numpy.ndarray): The non-equilibrium distribution functions.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): The computed momentum flux.\n        \"\"\"\n        return jnp.dot(fneq, self.lattice.cc)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def update_macroscopic(self, f):\n        \"\"\"\n        This function computes the macroscopic variables (density and velocity) based on the\n        distribution functions (f).\n\n        The density is computed as the sum of the distribution functions over all lattice directions.\n        The velocity is computed as the dot product of the distribution functions and the lattice\n        velocities, divided by the density.\n\n        Parameters\n        ----------\n        f (jax.numpy.ndarray): The distribution functions.\n\n        Returns\n        -------\n        rho (jax.numpy.ndarray): Computed density.\n\n        u: (jax.numpy.ndarray): Computed velocity.\n        \"\"\"\n        rho = jnp.sum(f, axis=-1, keepdims=True)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        u = jnp.dot(f, c) / rho\n\n        return rho, u\n\n    @partial(jit, static_argnums=(0, 4), inline=True)\n    def apply_bc(self, fout, fin, timestep, implementation_step):\n        \"\"\"\n        This function applies the boundary conditions to the distribution functions.\n\n        It iterates over all boundary conditions (BCs) and checks if the implementation step of the\n        boundary condition matches the provided implementation step. If it does, it applies the\n        boundary condition to the post-streaming distribution functions (fout).\n\n        Parameters\n        ----------\n        fout (jax.numpy.ndarray): Post-collision distribution functions.\n\n        fin: jax.numpy.ndarray): Post-streaming distribution functions.\n\n        implementation_step (str): Implementation step at which the boundary conditions should be applied.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.\n        \"\"\"\n        for bc in self.BCs:\n            fout = bc.prepare_populations(fout, fin, implementation_step)\n            if bc.implementationStep == implementation_step:\n                if bc.isDynamic:\n                    fout = bc.apply(fout, fin, timestep)\n                else:\n                    fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n\n        return fout\n\n    @partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\n    def step(self, f_poststreaming, timestep, return_fpost=False):\n        \"\"\"\n        This function performs a single step of the LBM simulation.\n\n        It first performs the collision step, which is the relaxation of the distribution functions\n        towards their equilibrium values. It then applies the respective boundary conditions to the\n        post-collision distribution functions.\n\n        The function then performs the streaming step, which is the propagation of the distribution\n        functions in the lattice. It then applies the respective boundary conditions to the post-streaming\n        distribution functions.\n\n        Parameters\n        ----------\n        f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions.\n\n        timestep (int): The current timestep of the simulation.\n\n        return_fpost (bool, optional): If True, the function also returns the post-collision distribution functions.\n\n        Returns\n        -------\n        f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions after the simulation step.\n\n        f_postcollision (jax.numpy.ndarray or None): Post-collision distribution functions after the simulation step, or None if\n        return_fpost is False.\n        \"\"\"\n        f_postcollision = self.collision(f_poststreaming)\n        f_postcollision = self.apply_bc(f_postcollision, f_poststreaming, timestep, \"PostCollision\")\n        f_poststreaming = self.streaming(f_postcollision)\n        f_poststreaming = self.apply_bc(f_poststreaming, f_postcollision, timestep, \"PostStreaming\")\n\n        if return_fpost:\n            return f_poststreaming, f_postcollision\n        else:\n            return f_poststreaming, None\n\n    def run(self, t_max):\n        \"\"\"\n        This function runs the LBM simulation for a specified number of time steps.\n\n        It first initializes the distribution functions and then enters a loop where it performs the\n        simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n        The function can also print the progress of the simulation, save the simulation data, and\n        compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n        Parameters\n        ----------\n        t_max (int): The total number of time steps to run the simulation.\n\n        Returns\n        -------\n        f (jax.numpy.ndarray): The distribution functions after the simulation.\n        \"\"\"\n        f = self.assign_fields_sharded()\n        start_step = 0\n        if self.restore_checkpoint:\n            latest_step = self.mngr.latest_step()\n            if latest_step is not None:  # existing checkpoint present\n                # Assert that the checkpoint manager is not None\n                assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n                state = {\"f\": f}\n                # shardings = map(lambda x: x.sharding, state)\n                # restore_args = orb.checkpoint_utils.construct_restore_args(state, shardings)\n                try:\n                    # f = self.mngr.restore(latest_step, restore_kwargs={'restore_args': restore_args})['f']\n                    f = self.mngr.restore(latest_step, args=orb.args.StandardSave(state))[\"f\"]\n                    print(f\"Restored checkpoint at step {latest_step}.\")\n                except ValueError:\n                    raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n                start_step = latest_step + 1\n                if not (t_max &gt; start_step):\n                    raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max = {t_max}). Consider increasing t_max.\")\n        if self.computeMLUPS:\n            start = time.time()\n        # Loop over all time steps\n        for timestep in range(start_step, t_max + 1):\n            io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n            print_iter_flag = self.printInfoRate &gt; 0 and timestep % self.printInfoRate == 0\n            checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n            if io_flag:\n                # Update the macroscopic variables and save the previous values (for error computation)\n                rho_prev, u_prev = self.update_macroscopic(f)\n                rho_prev = downsample_field(rho_prev, self.downsamplingFactor)\n                u_prev = downsample_field(u_prev, self.downsamplingFactor)\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                rho_prev = process_allgather(rho_prev)\n                u_prev = process_allgather(u_prev)\n\n            # Perform one time-step (collision, streaming, and boundary conditions)\n            f, fstar = self.step(f, timestep, return_fpost=self.returnFpost)\n            # Print the progress of the simulation\n            if print_iter_flag:\n                print(\n                    colored(\"Timestep \", \"blue\")\n                    + colored(f\"{timestep}\", \"green\")\n                    + colored(\" of \", \"blue\")\n                    + colored(f\"{t_max}\", \"green\")\n                    + colored(\" completed\", \"blue\")\n                )\n\n            if io_flag:\n                # Save the simulation data\n                print(f\"Saving data at timestep {timestep}/{t_max}\")\n                rho, u = self.update_macroscopic(f)\n                rho = downsample_field(rho, self.downsamplingFactor)\n                u = downsample_field(u, self.downsamplingFactor)\n\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                rho = process_allgather(rho)\n                u = process_allgather(u)\n\n                # Save the data\n                self.handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n\n            if checkpoint_flag:\n                # Save the checkpoint\n                print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n                state = {\"f\": f}\n                # self.mngr.save(timestep, state)\n                self.mngr.save(timestep, args=orb.args.StandardSave(state))\n\n            # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n            if self.computeMLUPS and timestep == 1:\n                jax.block_until_ready(f)\n                start = time.time()\n\n        if self.computeMLUPS:\n            # Compute and print the performance of the simulation in MLUPS\n            jax.block_until_ready(f)\n            end = time.time()\n            if self.dim == 2:\n                print(\n                    colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny}\", \"green\")\n                    if self.dim == 2\n                    else colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\")\n                )\n                print(\n                    colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny}\", \"green\")\n                    if self.dim == 2\n                    else colored(f\"{self.nx * self.ny * self.nz}\", \"green\")\n                )\n                print(colored(\"MLUPS: \", \"blue\") + colored(f\"{self.nx * self.ny * t_max / (end - start) / 1e6}\", \"red\"))\n\n            elif self.dim == 3:\n                print(colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\"))\n                print(colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny * self.nz}\", \"green\"))\n                print(\n                    colored(\"MLUPS: \", \"blue\")\n                    + colored(\n                        f\"{self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\",\n                        \"red\",\n                    )\n                )\n        if self.mngr is not None:\n            self.mngr.wait_until_finished()\n        return f\n\n    def handle_io_timestep(self, timestep, f, fstar, rho, u, rho_prev, u_prev):\n        \"\"\"\n        This function handles the input/output (I/O) operations at each time step of the simulation.\n\n        It prepares the data to be saved and calls the output_data function, which can be overwritten\n        by the user to customize the I/O operations.\n\n        Parameters\n        ----------\n        timestep (int): Current time step of the simulation.\n\n        f (jax.numpy.ndarray): Post-streaming distribution functions at the current time step.\n\n        fstar (jax.numpy.ndarray): Post-collision distribution functions at the current time step.\n\n        rho (jax.numpy.ndarray): Density field at the current time step.\n\n        u (jax.numpy.ndarray): Velocity field at the current time step.\n        \"\"\"\n        kwargs = {\n            \"timestep\": timestep,\n            \"rho\": rho,\n            \"rho_prev\": rho_prev,\n            \"u\": u,\n            \"u_prev\": u_prev,\n            \"f_poststreaming\": f,\n            \"f_postcollision\": fstar,\n        }\n        self.output_data(**kwargs)\n\n    def output_data(self, **kwargs):\n        \"\"\"\n        This function is intended to be overwritten by the user to customize the input/output (I/O)\n        operations of the simulation.\n\n        By default, it does nothing. When overwritten, it could save the simulation data to files,\n        display the simulation results in real time, send the data to another process for analysis, etc.\n\n        Parameters\n        ----------\n        **kwargs (dict): A dictionary containing the simulation data to be outputted. The keys are the names of the\n        data fields, and the values are the data fields themselves.\n        \"\"\"\n        pass\n\n    def set_boundary_conditions(self):\n        \"\"\"\n        This function sets the boundary conditions for the simulation.\n\n        It is intended to be overwritten by the user to specify the boundary conditions according to\n        the specific problem being solved.\n\n        By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip\n        boundaries, inflow/outflow boundaries, etc.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin):\n        \"\"\"\n        This function performs the collision step in the Lattice Boltzmann Method.\n\n        It is intended to be overwritten by the user to specify the collision operator according to\n        the specific LBM model being used.\n\n        By default, it does nothing. When overwritten, it could implement the BGK collision operator,\n        the MRT collision operator, etc.\n\n        Parameters\n        ----------\n        fin (jax.numpy.ndarray): Pre-collision distribution functions.\n\n        Returns\n        -------\n        fin (jax.numpy.ndarray): Post-collision distribution functions.\n        \"\"\"\n        pass\n\n    def get_force(self):\n        \"\"\"\n        This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.\n\n        It is intended to be overwritten by the user to specify the force according to the specific\n        problem being solved.\n\n        By default, it does nothing and returns None. When overwritten, it could implement a constant\n        force term.\n\n        Returns\n        -------\n        force (jax.numpy.ndarray): The force to be applied to the fluid.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, f_postcollision, feq, rho, u):\n        \"\"\"\n        add force based on exact-difference method due to Kupershtokh\n\n        Parameters\n        ----------\n        f_postcollision (jax.numpy.ndarray): Post-collision distribution functions.\n\n        feq (jax.numpy.ndarray): Equilibrium distribution functions.\n\n        rho (jax.numpy.ndarray): Density field.\n\n        u (jax.numpy.ndarray): Velocity field.\n\n        Returns\n        -------\n        f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n\n        References\n        ----------\n        1. Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In\n        Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France.\n        Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations:\n        Boundary conditions. Physica A, 392, 1925-1930.\n        2. Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.\n        \"\"\"\n        delta_u = self.get_force()\n        feq_force = self.equilibrium(rho, u + delta_u, cast_output=False)\n        f_postcollision = f_postcollision + feq_force - feq\n        return f_postcollision\n</code></pre>"},{"location":"base/#src.base.LBMBase.apply_bc","title":"apply_bc","text":"<pre><code>apply_bc(fout, fin, timestep, implementation_step)\n</code></pre> <p>This function applies the boundary conditions to the distribution functions.</p> <p>It iterates over all boundary conditions (BCs) and checks if the implementation step of the boundary condition matches the provided implementation step. If it does, it applies the boundary condition to the post-streaming distribution functions (fout).</p>"},{"location":"base/#src.base.LBMBase.apply_bc--parameters","title":"Parameters","text":"<p>fout (jax.numpy.ndarray): Post-collision distribution functions.</p> <p>fin: jax.numpy.ndarray): Post-streaming distribution functions.</p> <p>implementation_step (str): Implementation step at which the boundary conditions should be applied.</p>"},{"location":"base/#src.base.LBMBase.apply_bc--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 4), inline=True)\ndef apply_bc(self, fout, fin, timestep, implementation_step):\n    \"\"\"\n    This function applies the boundary conditions to the distribution functions.\n\n    It iterates over all boundary conditions (BCs) and checks if the implementation step of the\n    boundary condition matches the provided implementation step. If it does, it applies the\n    boundary condition to the post-streaming distribution functions (fout).\n\n    Parameters\n    ----------\n    fout (jax.numpy.ndarray): Post-collision distribution functions.\n\n    fin: jax.numpy.ndarray): Post-streaming distribution functions.\n\n    implementation_step (str): Implementation step at which the boundary conditions should be applied.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.\n    \"\"\"\n    for bc in self.BCs:\n        fout = bc.prepare_populations(fout, fin, implementation_step)\n        if bc.implementationStep == implementation_step:\n            if bc.isDynamic:\n                fout = bc.apply(fout, fin, timestep)\n            else:\n                fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n\n    return fout\n</code></pre>"},{"location":"base/#src.base.LBMBase.apply_force","title":"apply_force","text":"<pre><code>apply_force(f_postcollision, feq, rho, u)\n</code></pre> <p>add force based on exact-difference method due to Kupershtokh</p>"},{"location":"base/#src.base.LBMBase.apply_force--parameters","title":"Parameters","text":"<p>f_postcollision (jax.numpy.ndarray): Post-collision distribution functions.</p> <p>feq (jax.numpy.ndarray): Equilibrium distribution functions.</p> <p>rho (jax.numpy.ndarray): Density field.</p> <p>u (jax.numpy.ndarray): Velocity field.</p>"},{"location":"base/#src.base.LBMBase.apply_force--returns","title":"Returns","text":"<p>f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.</p>"},{"location":"base/#src.base.LBMBase.apply_force--references","title":"References","text":"<ol> <li>Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France. Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations: Boundary conditions. Physica A, 392, 1925-1930.</li> <li>Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.</li> </ol> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, f_postcollision, feq, rho, u):\n    \"\"\"\n    add force based on exact-difference method due to Kupershtokh\n\n    Parameters\n    ----------\n    f_postcollision (jax.numpy.ndarray): Post-collision distribution functions.\n\n    feq (jax.numpy.ndarray): Equilibrium distribution functions.\n\n    rho (jax.numpy.ndarray): Density field.\n\n    u (jax.numpy.ndarray): Velocity field.\n\n    Returns\n    -------\n    f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n\n    References\n    ----------\n    1. Kupershtokh, A. (2004). New method of incorporating a body force term into the lattice Boltzmann equation. In\n    Proceedings of the 5th International EHD Workshop (pp. 241-246). University of Poitiers, Poitiers, France.\n    Chikatamarla, S. S., &amp; Karlin, I. V. (2013). Entropic lattice Boltzmann method for turbulent flow simulations:\n    Boundary conditions. Physica A, 392, 1925-1930.\n    2. Kr\u00fcger, T., et al. (2017). The lattice Boltzmann method. Springer International Publishing, 10.978-3, 4-15.\n    \"\"\"\n    delta_u = self.get_force()\n    feq_force = self.equilibrium(rho, u + delta_u, cast_output=False)\n    f_postcollision = f_postcollision + feq_force - feq\n    return f_postcollision\n</code></pre>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded","title":"assign_fields_sharded","text":"<pre><code>assign_fields_sharded()\n</code></pre> <p>This function is used to initialize the simulation by assigning the macroscopic fields and populations.</p> <p>The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0). Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the distribution functions (f).</p> <p>If the density or velocity are not provided, the function initializes the distribution functions with a default value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.</p>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"base/#src.base.LBMBase.assign_fields_sharded--returns","title":"Returns","text":"<p>f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def assign_fields_sharded(self):\n    \"\"\"\n    This function is used to initialize the simulation by assigning the macroscopic fields and populations.\n\n    The function first initializes the macroscopic fields, which are the density (rho0) and velocity (u0).\n    Depending on the dimension of the simulation (2D or 3D), it then sets the shape of the array that will hold the\n    distribution functions (f).\n\n    If the density or velocity are not provided, the function initializes the distribution functions with a default\n    value (self.w), representing density=1 and velocity=0. Otherwise, it uses the provided density and velocity to initialize the populations.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    f: a distributed JAX array of shape (nx, ny, nz, q) or (nx, ny, q) holding the distribution functions for the simulation.\n    \"\"\"\n    rho0, u0 = self.initialize_macroscopic_fields()\n\n    if self.dim == 2:\n        shape = (self.nx, self.ny, self.lattice.q)\n    if self.dim == 3:\n        shape = (self.nx, self.ny, self.nz, self.lattice.q)\n\n    if rho0 is None or u0 is None:\n        f = self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w)\n    else:\n        f = self.initialize_populations(rho0, u0)\n\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.bounding_box_indices","title":"bounding_box_indices","text":"<pre><code>bounding_box_indices()\n</code></pre> <p>This function calculates the indices of the bounding box of a 2D or 3D grid. The bounding box is defined as the set of grid points on the outer edge of the grid.</p>"},{"location":"base/#src.base.LBMBase.bounding_box_indices--returns","title":"Returns","text":"<p>boundingBox (dict): A dictionary where keys are the names of the bounding box faces (\u201cbottom\u201d, \u201ctop\u201d, \u201cleft\u201d, \u201cright\u201d for 2D; additional \u201cfront\u201d, \u201cback\u201d for 3D), and values are numpy arrays of indices corresponding to each face.</p> Source code in <code>src/base.py</code> <pre><code>def bounding_box_indices(self):\n    \"\"\"\n    This function calculates the indices of the bounding box of a 2D or 3D grid.\n    The bounding box is defined as the set of grid points on the outer edge of the grid.\n\n    Returns\n    -------\n    boundingBox (dict): A dictionary where keys are the names of the bounding box faces\n    (\"bottom\", \"top\", \"left\", \"right\" for 2D; additional \"front\", \"back\" for 3D), and values\n    are numpy arrays of indices corresponding to each face.\n    \"\"\"\n    if self.dim == 2:\n        # For a 2D grid, the bounding box consists of four edges: bottom, top, left, and right.\n        # Each edge is represented as an array of indices. For example, the bottom edge includes\n        # all points where the y-coordinate is 0, so its indices are [[i, 0] for i in range(self.nx)].\n        bounding_box = {\n            \"bottom\": np.array([[i, 0] for i in range(self.nx)], dtype=int),\n            \"top\": np.array([[i, self.ny - 1] for i in range(self.nx)], dtype=int),\n            \"left\": np.array([[0, i] for i in range(self.ny)], dtype=int),\n            \"right\": np.array([[self.nx - 1, i] for i in range(self.ny)], dtype=int),\n        }\n\n        return bounding_box\n\n    elif self.dim == 3:\n        # For a 3D grid, the bounding box consists of six faces: bottom, top, left, right, front, and back.\n        # Each face is represented as an array of indices. For example, the bottom face includes all points\n        # where the z-coordinate is 0, so its indices are [[i, j, 0] for i in range(self.nx) for j in range(self.ny)].\n        bounding_box = {\n            \"bottom\": np.array(\n                [[i, j, 0] for i in range(self.nx) for j in range(self.ny)],\n                dtype=int,\n            ),\n            \"top\": np.array(\n                [[i, j, self.nz - 1] for i in range(self.nx) for j in range(self.ny)],\n                dtype=int,\n            ),\n            \"left\": np.array(\n                [[0, j, k] for j in range(self.ny) for k in range(self.nz)],\n                dtype=int,\n            ),\n            \"right\": np.array(\n                [[self.nx - 1, j, k] for j in range(self.ny) for k in range(self.nz)],\n                dtype=int,\n            ),\n            \"front\": np.array(\n                [[i, 0, k] for i in range(self.nx) for k in range(self.nz)],\n                dtype=int,\n            ),\n            \"back\": np.array(\n                [[i, self.ny - 1, k] for i in range(self.nx) for k in range(self.nz)],\n                dtype=int,\n            ),\n        }\n\n        return bounding_box\n</code></pre>"},{"location":"base/#src.base.LBMBase.collision","title":"collision","text":"<pre><code>collision(fin)\n</code></pre> <p>This function performs the collision step in the Lattice Boltzmann Method.</p> <p>It is intended to be overwritten by the user to specify the collision operator according to the specific LBM model being used.</p> <p>By default, it does nothing. When overwritten, it could implement the BGK collision operator, the MRT collision operator, etc.</p>"},{"location":"base/#src.base.LBMBase.collision--parameters","title":"Parameters","text":"<p>fin (jax.numpy.ndarray): Pre-collision distribution functions.</p>"},{"location":"base/#src.base.LBMBase.collision--returns","title":"Returns","text":"<p>fin (jax.numpy.ndarray): Post-collision distribution functions.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin):\n    \"\"\"\n    This function performs the collision step in the Lattice Boltzmann Method.\n\n    It is intended to be overwritten by the user to specify the collision operator according to\n    the specific LBM model being used.\n\n    By default, it does nothing. When overwritten, it could implement the BGK collision operator,\n    the MRT collision operator, etc.\n\n    Parameters\n    ----------\n    fin (jax.numpy.ndarray): Pre-collision distribution functions.\n\n    Returns\n    -------\n    fin (jax.numpy.ndarray): Post-collision distribution functions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.create_grid_mask","title":"create_grid_mask","text":"<pre><code>create_grid_mask(solid_halo_voxels)\n</code></pre> <p>This function creates a mask for the background grid that accounts for the location of the boundaries.</p>"},{"location":"base/#src.base.LBMBase.create_grid_mask--parameters","title":"Parameters","text":"<p>solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.</p>"},{"location":"base/#src.base.LBMBase.create_grid_mask--returns","title":"Returns","text":"<p>A JAX array representing the grid mask of the grid.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef create_grid_mask(self, solid_halo_voxels):\n    \"\"\"\n    This function creates a mask for the background grid that accounts for the location of the boundaries.\n\n    Parameters\n    ----------\n    solid_halo_voxels: A numpy array representing the voxels in the halo of the solid object.\n\n    Returns\n    -------\n    A JAX array representing the grid mask of the grid.\n    \"\"\"\n    # Halo width (hw_x is different to accommodate the domain sharding per XLA device)\n    hw_x = self.nDevices\n    hw_y = hw_z = 1\n    if self.dim == 2:\n        grid_mask = self.distributed_array_init(\n            (self.nx + 2 * hw_x, self.ny + 2 * hw_y, self.lattice.q),\n            jnp.bool_,\n            init_val=True,\n        )\n        grid_mask = grid_mask.at[(slice(hw_x, -hw_x), slice(hw_y, -hw_y), slice(None))].set(False)\n        if solid_halo_voxels is not None:\n            solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n            solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n            grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n\n        grid_mask = self.streaming(grid_mask)\n        return lax.with_sharding_constraint(grid_mask, self.sharding)\n\n    elif self.dim == 3:\n        grid_mask = self.distributed_array_init(\n            (\n                self.nx + 2 * hw_x,\n                self.ny + 2 * hw_y,\n                self.nz + 2 * hw_z,\n                self.lattice.q,\n            ),\n            jnp.bool_,\n            init_val=True,\n        )\n        grid_mask = grid_mask.at[\n            (\n                slice(hw_x, -hw_x),\n                slice(hw_y, -hw_y),\n                slice(hw_z, -hw_z),\n                slice(None),\n            )\n        ].set(False)\n        if solid_halo_voxels is not None:\n            solid_halo_voxels = solid_halo_voxels.at[:, 0].add(hw_x)\n            solid_halo_voxels = solid_halo_voxels.at[:, 1].add(hw_y)\n            solid_halo_voxels = solid_halo_voxels.at[:, 2].add(hw_z)\n            grid_mask = grid_mask.at[tuple(solid_halo_voxels.T)].set(True)\n        grid_mask = self.streaming(grid_mask)\n        return lax.with_sharding_constraint(grid_mask, self.sharding)\n</code></pre>"},{"location":"base/#src.base.LBMBase.distributed_array_init","title":"distributed_array_init","text":"<pre><code>distributed_array_init(shape, type, init_val=0, sharding=None)\n</code></pre> <p>Initialize a distributed array using JAX, with a specified shape, data type, and initial value. Optionally, provide a custom sharding strategy.</p>"},{"location":"base/#src.base.LBMBase.distributed_array_init--parameters","title":"Parameters","text":"<p>shape (tuple): The shape of the array to be created.</p> <p>type (dtype): The data type of the array to be created.</p> <p>init_val (scalar, optional): The initial value to fill the array with. Defaults to 0.</p> <p>sharding (Sharding, optional): The sharding strategy to use. Defaults to <code>self.sharding</code>.</p>"},{"location":"base/#src.base.LBMBase.distributed_array_init--returns","title":"Returns","text":"<p>jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 1, 2, 4))\ndef distributed_array_init(self, shape, type, init_val=0, sharding=None):\n    \"\"\"\n    Initialize a distributed array using JAX, with a specified shape, data type, and initial value.\n    Optionally, provide a custom sharding strategy.\n\n    Parameters\n    ----------\n    shape (tuple): The shape of the array to be created.\n\n    type (dtype): The data type of the array to be created.\n\n    init_val (scalar, optional): The initial value to fill the array with. Defaults to 0.\n\n    sharding (Sharding, optional): The sharding strategy to use. Defaults to `self.sharding`.\n\n    Returns\n    -------\n    jax.numpy.ndarray: A JAX array with the specified shape, data type, initial value, and sharding strategy.\n    \"\"\"\n    if sharding is None:\n        sharding = self.sharding\n    x = jnp.full(shape=shape, fill_value=init_val, dtype=type)\n    return jax.lax.with_sharding_constraint(x, sharding)\n</code></pre>"},{"location":"base/#src.base.LBMBase.equilibrium","title":"equilibrium","text":"<pre><code>equilibrium(rho, u, cast_output=True)\n</code></pre> <p>This function computes the equilibrium distribution function in the Lattice Boltzmann Method. The equilibrium distribution function is a function of the macroscopic density and velocity.</p> <p>The function first casts the density and velocity to the compute precision if the cast_output flag is True. The function finally casts the equilibrium distribution function to the output precision if the cast_output flag is True.</p>"},{"location":"base/#src.base.LBMBase.equilibrium--parameters","title":"Parameters","text":"<p>rho (jax.numpy.ndarray): The macroscopic density.</p> <p>u (jax.numpy.ndarray): The macroscopic velocity.</p> <p>cast_output (bool, optional): A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the compute and output precisions. Default is True.</p>"},{"location":"base/#src.base.LBMBase.equilibrium--returns","title":"Returns","text":"<p>feq (jax.numpy.ndarray): The equilibrium distribution function.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef equilibrium(self, rho, u, cast_output=True):\n    \"\"\"\n    This function computes the equilibrium distribution function in the Lattice Boltzmann Method.\n    The equilibrium distribution function is a function of the macroscopic density and velocity.\n\n    The function first casts the density and velocity to the compute precision if the cast_output flag is True.\n    The function finally casts the equilibrium distribution function to the output precision if the cast_output\n    flag is True.\n\n    Parameters\n    ----------\n    rho (jax.numpy.ndarray): The macroscopic density.\n\n    u (jax.numpy.ndarray): The macroscopic velocity.\n\n    cast_output (bool, optional): A flag indicating whether to cast the density, velocity, and equilibrium distribution function to the\n    compute and output precisions. Default is True.\n\n    Returns\n    -------\n    feq (jax.numpy.ndarray): The equilibrium distribution function.\n    \"\"\"\n    # Cast the density and velocity to the compute precision if the cast_output flag is True\n    if cast_output:\n        rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n\n    # Cast c to compute precision so that XLA call FXX matmul,\n    # which is faster (it is faster in some older versions of JAX, newer versions are smart enough to do this automatically)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n    cu = 3.0 * jnp.dot(u, c)\n    usqr = 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True)\n    feq = rho * self.w * (1.0 + cu * (1.0 + 0.5 * cu) - usqr)\n\n    if cast_output:\n        return self.precisionPolicy.cast_to_output(feq)\n    else:\n        return feq\n</code></pre>"},{"location":"base/#src.base.LBMBase.get_force","title":"get_force","text":"<pre><code>get_force()\n</code></pre> <p>This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.</p> <p>It is intended to be overwritten by the user to specify the force according to the specific problem being solved.</p> <p>By default, it does nothing and returns None. When overwritten, it could implement a constant force term.</p>"},{"location":"base/#src.base.LBMBase.get_force--returns","title":"Returns","text":"<p>force (jax.numpy.ndarray): The force to be applied to the fluid.</p> Source code in <code>src/base.py</code> <pre><code>def get_force(self):\n    \"\"\"\n    This function computes the force to be applied to the fluid in the Lattice Boltzmann Method.\n\n    It is intended to be overwritten by the user to specify the force according to the specific\n    problem being solved.\n\n    By default, it does nothing and returns None. When overwritten, it could implement a constant\n    force term.\n\n    Returns\n    -------\n    force (jax.numpy.ndarray): The force to be applied to the fluid.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.handle_io_timestep","title":"handle_io_timestep","text":"<pre><code>handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n</code></pre> <p>This function handles the input/output (I/O) operations at each time step of the simulation.</p> <p>It prepares the data to be saved and calls the output_data function, which can be overwritten by the user to customize the I/O operations.</p>"},{"location":"base/#src.base.LBMBase.handle_io_timestep--parameters","title":"Parameters","text":"<p>timestep (int): Current time step of the simulation.</p> <p>f (jax.numpy.ndarray): Post-streaming distribution functions at the current time step.</p> <p>fstar (jax.numpy.ndarray): Post-collision distribution functions at the current time step.</p> <p>rho (jax.numpy.ndarray): Density field at the current time step.</p> <p>u (jax.numpy.ndarray): Velocity field at the current time step.</p> Source code in <code>src/base.py</code> <pre><code>def handle_io_timestep(self, timestep, f, fstar, rho, u, rho_prev, u_prev):\n    \"\"\"\n    This function handles the input/output (I/O) operations at each time step of the simulation.\n\n    It prepares the data to be saved and calls the output_data function, which can be overwritten\n    by the user to customize the I/O operations.\n\n    Parameters\n    ----------\n    timestep (int): Current time step of the simulation.\n\n    f (jax.numpy.ndarray): Post-streaming distribution functions at the current time step.\n\n    fstar (jax.numpy.ndarray): Post-collision distribution functions at the current time step.\n\n    rho (jax.numpy.ndarray): Density field at the current time step.\n\n    u (jax.numpy.ndarray): Velocity field at the current time step.\n    \"\"\"\n    kwargs = {\n        \"timestep\": timestep,\n        \"rho\": rho,\n        \"rho_prev\": rho_prev,\n        \"u\": u,\n        \"u_prev\": u_prev,\n        \"f_poststreaming\": f,\n        \"f_postcollision\": fstar,\n    }\n    self.output_data(**kwargs)\n</code></pre>"},{"location":"base/#src.base.LBMBase.initialize_macroscopic_fields","title":"initialize_macroscopic_fields","text":"<pre><code>initialize_macroscopic_fields()\n</code></pre> <p>This function initializes the macroscopic fields (density and velocity) to their default values. The default density is 1 and the default velocity is 0.</p> <p>Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class to provide specific initial conditions.</p>"},{"location":"base/#src.base.LBMBase.initialize_macroscopic_fields--returns","title":"Returns","text":"<p>None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.</p> Source code in <code>src/base.py</code> <pre><code>def initialize_macroscopic_fields(self):\n    \"\"\"\n    This function initializes the macroscopic fields (density and velocity) to their default values.\n    The default density is 1 and the default velocity is 0.\n\n    Note: This function is a placeholder and should be overridden in a subclass or in an instance of the class\n    to provide specific initial conditions.\n\n    Returns\n    -------\n    None, None: The default density and velocity, both None. This indicates that the actual values should be set elsewhere.\n    \"\"\"\n    print(\"WARNING: Default initial conditions assumed: density = 1, velocity = 0\")\n    print(\"         To set explicit initial density and velocity, use self.initialize_macroscopic_fields.\")\n    return None, None\n</code></pre>"},{"location":"base/#src.base.LBMBase.initialize_populations","title":"initialize_populations","text":"<pre><code>initialize_populations(rho0, u0)\n</code></pre> <p>This function initializes the populations (distribution functions) for the simulation. It uses the equilibrium distribution function, which is a function of the macroscopic density and velocity.</p>"},{"location":"base/#src.base.LBMBase.initialize_populations--parameters","title":"Parameters","text":"<p>rho0 (jax.numpy.ndarray): Initial density field.</p> <p>u0 (jax.numpy.ndarray): Initial velocity field.</p>"},{"location":"base/#src.base.LBMBase.initialize_populations--returns","title":"Returns","text":"<p>f (jax.numpy.ndarray): The array holding the initialized distribution functions for the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def initialize_populations(self, rho0, u0):\n    \"\"\"\n    This function initializes the populations (distribution functions) for the simulation.\n    It uses the equilibrium distribution function, which is a function of the macroscopic\n    density and velocity.\n\n    Parameters\n    ----------\n    rho0 (jax.numpy.ndarray): Initial density field.\n\n    u0 (jax.numpy.ndarray): Initial velocity field.\n\n    Returns\n    -------\n    f (jax.numpy.ndarray): The array holding the initialized distribution functions for the simulation.\n    \"\"\"\n    return self.equilibrium(rho0, u0)\n</code></pre>"},{"location":"base/#src.base.LBMBase.momentum_flux","title":"momentum_flux","text":"<pre><code>momentum_flux(fneq)\n</code></pre> <p>This function computes the momentum flux, which is the product of the non-equilibrium distribution functions (fneq) and the lattice moments (cc).</p> <p>The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann Method (LBM).</p>"},{"location":"base/#src.base.LBMBase.momentum_flux--parameters","title":"Parameters","text":"<p>fneq (jax.numpy.ndarray): The non-equilibrium distribution functions.</p>"},{"location":"base/#src.base.LBMBase.momentum_flux--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): The computed momentum flux.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_flux(self, fneq):\n    \"\"\"\n    This function computes the momentum flux, which is the product of the non-equilibrium\n    distribution functions (fneq) and the lattice moments (cc).\n\n    The momentum flux is used in the computation of the stress tensor in the Lattice Boltzmann\n    Method (LBM).\n\n    Parameters\n    ----------\n    fneq (jax.numpy.ndarray): The non-equilibrium distribution functions.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): The computed momentum flux.\n    \"\"\"\n    return jnp.dot(fneq, self.lattice.cc)\n</code></pre>"},{"location":"base/#src.base.LBMBase.output_data","title":"output_data","text":"<pre><code>output_data(**kwargs)\n</code></pre> <p>This function is intended to be overwritten by the user to customize the input/output (I/O) operations of the simulation.</p> <p>By default, it does nothing. When overwritten, it could save the simulation data to files, display the simulation results in real time, send the data to another process for analysis, etc.</p>"},{"location":"base/#src.base.LBMBase.output_data--parameters","title":"Parameters","text":"<p>**kwargs (dict): A dictionary containing the simulation data to be outputted. The keys are the names of the data fields, and the values are the data fields themselves.</p> Source code in <code>src/base.py</code> <pre><code>def output_data(self, **kwargs):\n    \"\"\"\n    This function is intended to be overwritten by the user to customize the input/output (I/O)\n    operations of the simulation.\n\n    By default, it does nothing. When overwritten, it could save the simulation data to files,\n    display the simulation results in real time, send the data to another process for analysis, etc.\n\n    Parameters\n    ----------\n    **kwargs (dict): A dictionary containing the simulation data to be outputted. The keys are the names of the\n    data fields, and the values are the data fields themselves.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.run","title":"run","text":"<pre><code>run(t_max)\n</code></pre> <p>This function runs the LBM simulation for a specified number of time steps.</p> <p>It first initializes the distribution functions and then enters a loop where it performs the simulation steps (collision, streaming, and boundary conditions) for each time step.</p> <p>The function can also print the progress of the simulation, save the simulation data, and compute the performance of the simulation in million lattice updates per second (MLUPS).</p>"},{"location":"base/#src.base.LBMBase.run--parameters","title":"Parameters","text":"<p>t_max (int): The total number of time steps to run the simulation.</p>"},{"location":"base/#src.base.LBMBase.run--returns","title":"Returns","text":"<p>f (jax.numpy.ndarray): The distribution functions after the simulation.</p> Source code in <code>src/base.py</code> <pre><code>def run(self, t_max):\n    \"\"\"\n    This function runs the LBM simulation for a specified number of time steps.\n\n    It first initializes the distribution functions and then enters a loop where it performs the\n    simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n    The function can also print the progress of the simulation, save the simulation data, and\n    compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n    Parameters\n    ----------\n    t_max (int): The total number of time steps to run the simulation.\n\n    Returns\n    -------\n    f (jax.numpy.ndarray): The distribution functions after the simulation.\n    \"\"\"\n    f = self.assign_fields_sharded()\n    start_step = 0\n    if self.restore_checkpoint:\n        latest_step = self.mngr.latest_step()\n        if latest_step is not None:  # existing checkpoint present\n            # Assert that the checkpoint manager is not None\n            assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n            state = {\"f\": f}\n            # shardings = map(lambda x: x.sharding, state)\n            # restore_args = orb.checkpoint_utils.construct_restore_args(state, shardings)\n            try:\n                # f = self.mngr.restore(latest_step, restore_kwargs={'restore_args': restore_args})['f']\n                f = self.mngr.restore(latest_step, args=orb.args.StandardSave(state))[\"f\"]\n                print(f\"Restored checkpoint at step {latest_step}.\")\n            except ValueError:\n                raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n            start_step = latest_step + 1\n            if not (t_max &gt; start_step):\n                raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max = {t_max}). Consider increasing t_max.\")\n    if self.computeMLUPS:\n        start = time.time()\n    # Loop over all time steps\n    for timestep in range(start_step, t_max + 1):\n        io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n        print_iter_flag = self.printInfoRate &gt; 0 and timestep % self.printInfoRate == 0\n        checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n        if io_flag:\n            # Update the macroscopic variables and save the previous values (for error computation)\n            rho_prev, u_prev = self.update_macroscopic(f)\n            rho_prev = downsample_field(rho_prev, self.downsamplingFactor)\n            u_prev = downsample_field(u_prev, self.downsamplingFactor)\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            rho_prev = process_allgather(rho_prev)\n            u_prev = process_allgather(u_prev)\n\n        # Perform one time-step (collision, streaming, and boundary conditions)\n        f, fstar = self.step(f, timestep, return_fpost=self.returnFpost)\n        # Print the progress of the simulation\n        if print_iter_flag:\n            print(\n                colored(\"Timestep \", \"blue\")\n                + colored(f\"{timestep}\", \"green\")\n                + colored(\" of \", \"blue\")\n                + colored(f\"{t_max}\", \"green\")\n                + colored(\" completed\", \"blue\")\n            )\n\n        if io_flag:\n            # Save the simulation data\n            print(f\"Saving data at timestep {timestep}/{t_max}\")\n            rho, u = self.update_macroscopic(f)\n            rho = downsample_field(rho, self.downsamplingFactor)\n            u = downsample_field(u, self.downsamplingFactor)\n\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            rho = process_allgather(rho)\n            u = process_allgather(u)\n\n            # Save the data\n            self.handle_io_timestep(timestep, f, fstar, rho, u, rho_prev, u_prev)\n\n        if checkpoint_flag:\n            # Save the checkpoint\n            print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n            state = {\"f\": f}\n            # self.mngr.save(timestep, state)\n            self.mngr.save(timestep, args=orb.args.StandardSave(state))\n\n        # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n        if self.computeMLUPS and timestep == 1:\n            jax.block_until_ready(f)\n            start = time.time()\n\n    if self.computeMLUPS:\n        # Compute and print the performance of the simulation in MLUPS\n        jax.block_until_ready(f)\n        end = time.time()\n        if self.dim == 2:\n            print(\n                colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny}\", \"green\")\n                if self.dim == 2\n                else colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\")\n            )\n            print(\n                colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny}\", \"green\")\n                if self.dim == 2\n                else colored(f\"{self.nx * self.ny * self.nz}\", \"green\")\n            )\n            print(colored(\"MLUPS: \", \"blue\") + colored(f\"{self.nx * self.ny * t_max / (end - start) / 1e6}\", \"red\"))\n\n        elif self.dim == 3:\n            print(colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\"))\n            print(colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny * self.nz}\", \"green\"))\n            print(\n                colored(\"MLUPS: \", \"blue\")\n                + colored(\n                    f\"{self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\",\n                    \"red\",\n                )\n            )\n    if self.mngr is not None:\n        self.mngr.wait_until_finished()\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.send_left","title":"send_left","text":"<pre><code>send_left(x, axis_name)\n</code></pre> <p>This function sends the data to the left neighboring process in a parallel computing environment. It uses a permutation operation provided by the LAX library.</p>"},{"location":"base/#src.base.LBMBase.send_left--parameters","title":"Parameters","text":"<p>x (jax.numpy.ndarray): The data to be sent.</p> <p>axis_name (str): The name of the axis along which the data is sent.</p>"},{"location":"base/#src.base.LBMBase.send_left--returns","title":"Returns","text":"<p>The data after being sent to the left neighboring process.</p> Source code in <code>src/base.py</code> <pre><code>def send_left(self, x, axis_name):\n    \"\"\"\n    This function sends the data to the left neighboring process in a parallel computing environment.\n    It uses a permutation operation provided by the LAX library.\n\n    Parameters\n    ----------\n    x (jax.numpy.ndarray): The data to be sent.\n\n    axis_name (str): The name of the axis along which the data is sent.\n\n    Returns\n    -------\n    The data after being sent to the left neighboring process.\n    \"\"\"\n    return lax.ppermute(x, perm=self.leftPerm, axis_name=axis_name)\n</code></pre>"},{"location":"base/#src.base.LBMBase.send_right","title":"send_right","text":"<pre><code>send_right(x, axis_name)\n</code></pre> <p>This function sends the data to the right neighboring process in a parallel computing environment. It uses a permutation operation provided by the LAX library.</p>"},{"location":"base/#src.base.LBMBase.send_right--parameters","title":"Parameters","text":"<p>x (jax.numpy.ndarray): The data to be sent.</p> <p>axis_name (str): The name of the axis along which the data is sent.</p>"},{"location":"base/#src.base.LBMBase.send_right--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): The data after being sent to the right neighboring process.</p> Source code in <code>src/base.py</code> <pre><code>def send_right(self, x, axis_name):\n    \"\"\"\n    This function sends the data to the right neighboring process in a parallel computing environment.\n    It uses a permutation operation provided by the LAX library.\n\n    Parameters\n    ----------\n    x (jax.numpy.ndarray): The data to be sent.\n\n    axis_name (str): The name of the axis along which the data is sent.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): The data after being sent to the right neighboring process.\n    \"\"\"\n    return lax.ppermute(x, perm=self.rightPerm, axis_name=axis_name)\n</code></pre>"},{"location":"base/#src.base.LBMBase.set_boundary_conditions","title":"set_boundary_conditions","text":"<pre><code>set_boundary_conditions()\n</code></pre> <p>This function sets the boundary conditions for the simulation.</p> <p>It is intended to be overwritten by the user to specify the boundary conditions according to the specific problem being solved.</p> <p>By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip boundaries, inflow/outflow boundaries, etc.</p> Source code in <code>src/base.py</code> <pre><code>def set_boundary_conditions(self):\n    \"\"\"\n    This function sets the boundary conditions for the simulation.\n\n    It is intended to be overwritten by the user to specify the boundary conditions according to\n    the specific problem being solved.\n\n    By default, it does nothing. When overwritten, it could set periodic boundaries, no-slip\n    boundaries, inflow/outflow boundaries, etc.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base/#src.base.LBMBase.set_precisions","title":"set_precisions","text":"<pre><code>set_precisions(precision)\n</code></pre> <p>This function sets the precision of the computations. The precision is defined by a pair of values, representing the precision of the computation and the precision of the storage, respectively.</p>"},{"location":"base/#src.base.LBMBase.set_precisions--parameters","title":"Parameters","text":"<p>precision (str): A string representing the desired precision. The string should be in the format \u201ccomputation/storage\u201d, where \u201ccomputation\u201d and \u201cstorage\u201d are either \u201cf64\u201d, \u201cf32\u201d, or \u201cf16\u201d, representing 64-bit, 32-bit, or 16-bit floating point numbers, respectively.</p>"},{"location":"base/#src.base.LBMBase.set_precisions--returns","title":"Returns","text":"<p>tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively. If the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).</p> Source code in <code>src/base.py</code> <pre><code>def set_precisions(self, precision):\n    \"\"\"\n    This function sets the precision of the computations. The precision is defined by a pair of values,\n    representing the precision of the computation and the precision of the storage, respectively.\n\n    Parameters\n    ----------\n    precision (str): A string representing the desired precision. The string should be in the format\n    \"computation/storage\", where \"computation\" and \"storage\" are either \"f64\", \"f32\", or \"f16\",\n    representing 64-bit, 32-bit, or 16-bit floating point numbers, respectively.\n\n    Returns\n    -------\n    tuple: A pair of jax.numpy data types representing the computation and storage precisions, respectively.\n    If the input string does not match any of the predefined options, the function defaults to (jnp.float32, jnp.float32).\n    \"\"\"\n    return {\n        \"f64/f64\": (jnp.float64, jnp.float64),\n        \"f32/f32\": (jnp.float32, jnp.float32),\n        \"f32/f16\": (jnp.float32, jnp.float16),\n        \"f16/f16\": (jnp.float16, jnp.float16),\n        \"f64/f32\": (jnp.float64, jnp.float32),\n        \"f64/f16\": (jnp.float64, jnp.float16),\n    }.get(precision, (jnp.float32, jnp.float32))\n</code></pre>"},{"location":"base/#src.base.LBMBase.step","title":"step","text":"<pre><code>step(f_poststreaming, timestep, return_fpost=False)\n</code></pre> <p>This function performs a single step of the LBM simulation.</p> <p>It first performs the collision step, which is the relaxation of the distribution functions towards their equilibrium values. It then applies the respective boundary conditions to the post-collision distribution functions.</p> <p>The function then performs the streaming step, which is the propagation of the distribution functions in the lattice. It then applies the respective boundary conditions to the post-streaming distribution functions.</p>"},{"location":"base/#src.base.LBMBase.step--parameters","title":"Parameters","text":"<p>f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions.</p> <p>timestep (int): The current timestep of the simulation.</p> <p>return_fpost (bool, optional): If True, the function also returns the post-collision distribution functions.</p>"},{"location":"base/#src.base.LBMBase.step--returns","title":"Returns","text":"<p>f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions after the simulation step.</p> <p>f_postcollision (jax.numpy.ndarray or None): Post-collision distribution functions after the simulation step, or None if return_fpost is False.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\ndef step(self, f_poststreaming, timestep, return_fpost=False):\n    \"\"\"\n    This function performs a single step of the LBM simulation.\n\n    It first performs the collision step, which is the relaxation of the distribution functions\n    towards their equilibrium values. It then applies the respective boundary conditions to the\n    post-collision distribution functions.\n\n    The function then performs the streaming step, which is the propagation of the distribution\n    functions in the lattice. It then applies the respective boundary conditions to the post-streaming\n    distribution functions.\n\n    Parameters\n    ----------\n    f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions.\n\n    timestep (int): The current timestep of the simulation.\n\n    return_fpost (bool, optional): If True, the function also returns the post-collision distribution functions.\n\n    Returns\n    -------\n    f_poststreaming (jax.numpy.ndarray): Post-streaming distribution functions after the simulation step.\n\n    f_postcollision (jax.numpy.ndarray or None): Post-collision distribution functions after the simulation step, or None if\n    return_fpost is False.\n    \"\"\"\n    f_postcollision = self.collision(f_poststreaming)\n    f_postcollision = self.apply_bc(f_postcollision, f_poststreaming, timestep, \"PostCollision\")\n    f_poststreaming = self.streaming(f_postcollision)\n    f_poststreaming = self.apply_bc(f_poststreaming, f_postcollision, timestep, \"PostStreaming\")\n\n    if return_fpost:\n        return f_poststreaming, f_postcollision\n    else:\n        return f_poststreaming, None\n</code></pre>"},{"location":"base/#src.base.LBMBase.streaming_m","title":"streaming_m","text":"<pre><code>streaming_m(f)\n</code></pre> <p>This function performs the streaming step in the Lattice Boltzmann Method, which is the propagation of the distribution functions in the lattice.</p> <p>To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the distribution functions that need to be communicated to the neighboring processes.</p> <p>The function then sends the left boundary slice to the right neighboring process and the right boundary slice to the left neighboring process. The received data is then set to the corresponding indices in the receiving domain.</p>"},{"location":"base/#src.base.LBMBase.streaming_m--parameters","title":"Parameters","text":"<p>f (jax.numpy.ndarray): The array holding the distribution functions for the simulation.</p>"},{"location":"base/#src.base.LBMBase.streaming_m--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): The distribution functions after the streaming operation.</p> Source code in <code>src/base.py</code> <pre><code>def streaming_m(self, f):\n    \"\"\"\n    This function performs the streaming step in the Lattice Boltzmann Method, which is\n    the propagation of the distribution functions in the lattice.\n\n    To enable multi-GPU/TPU functionality, it extracts the left and right boundary slices of the\n    distribution functions that need to be communicated to the neighboring processes.\n\n    The function then sends the left boundary slice to the right neighboring process and the right\n    boundary slice to the left neighboring process. The received data is then set to the\n    corresponding indices in the receiving domain.\n\n    Parameters\n    ----------\n    f (jax.numpy.ndarray): The array holding the distribution functions for the simulation.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): The distribution functions after the streaming operation.\n    \"\"\"\n    f = self.streaming_p(f)\n    left_comm, right_comm = (\n        f[:1, ..., self.lattice.right_indices],\n        f[-1:, ..., self.lattice.left_indices],\n    )\n\n    left_comm, right_comm = (\n        self.send_right(left_comm, \"x\"),\n        self.send_left(right_comm, \"x\"),\n    )\n    f = f.at[:1, ..., self.lattice.right_indices].set(left_comm)\n    f = f.at[-1:, ..., self.lattice.left_indices].set(right_comm)\n    return f\n</code></pre>"},{"location":"base/#src.base.LBMBase.streaming_p","title":"streaming_p","text":"<pre><code>streaming_p(f)\n</code></pre> <p>Perform streaming operation on a partitioned (in the x-direction) distribution function.</p> <p>The function uses the vmap operation provided by the JAX library to vectorize the computation over all lattice directions.</p>"},{"location":"base/#src.base.LBMBase.streaming_p--parameters","title":"Parameters","text":"<p>f: The distribution function.</p>"},{"location":"base/#src.base.LBMBase.streaming_p--returns","title":"Returns","text":"<p>The updated distribution function after streaming.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef streaming_p(self, f):\n    \"\"\"\n    Perform streaming operation on a partitioned (in the x-direction) distribution function.\n\n    The function uses the vmap operation provided by the JAX library to vectorize the computation\n    over all lattice directions.\n\n    Parameters\n    ----------\n    f: The distribution function.\n\n    Returns\n    -------\n    The updated distribution function after streaming.\n    \"\"\"\n\n    def streaming_i(f, c):\n        \"\"\"\n        Perform individual streaming operation in a direction.\n\n        Parameters\n        ----------\n            f: The distribution function.\n            c: The streaming direction vector.\n\n        Returns\n        -------\n            jax.numpy.ndarray\n            The updated distribution function after streaming.\n        \"\"\"\n        if self.dim == 2:\n            return jnp.roll(f, (c[0], c[1]), axis=(0, 1))\n        elif self.dim == 3:\n            return jnp.roll(f, (c[0], c[1], c[2]), axis=(0, 1, 2))\n\n    return vmap(streaming_i, in_axes=(-1, 0), out_axes=-1)(f, self.c.T)\n</code></pre>"},{"location":"base/#src.base.LBMBase.update_macroscopic","title":"update_macroscopic","text":"<pre><code>update_macroscopic(f)\n</code></pre> <p>This function computes the macroscopic variables (density and velocity) based on the distribution functions (f).</p> <p>The density is computed as the sum of the distribution functions over all lattice directions. The velocity is computed as the dot product of the distribution functions and the lattice velocities, divided by the density.</p>"},{"location":"base/#src.base.LBMBase.update_macroscopic--parameters","title":"Parameters","text":"<p>f (jax.numpy.ndarray): The distribution functions.</p>"},{"location":"base/#src.base.LBMBase.update_macroscopic--returns","title":"Returns","text":"<p>rho (jax.numpy.ndarray): Computed density.</p> <p>u: (jax.numpy.ndarray): Computed velocity.</p> Source code in <code>src/base.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef update_macroscopic(self, f):\n    \"\"\"\n    This function computes the macroscopic variables (density and velocity) based on the\n    distribution functions (f).\n\n    The density is computed as the sum of the distribution functions over all lattice directions.\n    The velocity is computed as the dot product of the distribution functions and the lattice\n    velocities, divided by the density.\n\n    Parameters\n    ----------\n    f (jax.numpy.ndarray): The distribution functions.\n\n    Returns\n    -------\n    rho (jax.numpy.ndarray): Computed density.\n\n    u: (jax.numpy.ndarray): Computed velocity.\n    \"\"\"\n    rho = jnp.sum(f, axis=-1, keepdims=True)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    u = jnp.dot(f, c) / rho\n\n    return rho, u\n</code></pre>"},{"location":"boundary_conditions/","title":"JAX-LaB boundary conditions","text":"<p>               Bases: <code>object</code></p> <p>Base class for boundary conditions in a LBM simulation.</p> <p>This class provides a general structure for implementing boundary conditions. It includes methods for preparing the boundary attributes and for applying the boundary condition. Specific boundary conditions should be implemented as subclasses of this class, with the <code>apply</code> method overridden as necessary.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a full-way bounce-back boundary condition, where particles hitting the boundary are reflected back in the direction they came from. The boundary condition is applied after the collision step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Moving bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a moving bounce-back boundary condition, where particles hitting the boundary are reflected back in the direction they came from, with an additional velocity due to the movement of the boundary. The boundary condition is applied after the collision step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Halfway bounce-back boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a halfway bounce-back boundary condition. The boundary condition is applied after the streaming step.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Equilibrium boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements an equilibrium boundary condition, where the distribution function at the boundary nodes is set to the equilibrium distribution function. The boundary condition is applied after the streaming step.</p> <p>               Bases: <code>BoundaryCondition</code></p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class DoNothing(BoundaryCondition):\n    def __init__(self, indices, gridInfo, precision_policy):\n        \"\"\"\n        Do-nothing boundary condition for a lattice Boltzmann method simulation.\n\n        This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary\n        condition is applied after the streaming step.\n\n        Attributes\n        ----------\n        name : str\n            The name of the boundary condition. For this class, it is \"DoNothing\".\n        implementationStep : str\n            The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n            it is \"PostStreaming\".\n\n        Notes\n        -----\n        This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision\n        populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \"fout[self.indices]\n        is that the information that exit the domain on the opposite side of this boundary, would \"re-enter\". This is because\n        we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as\n        the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium.\n        Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary\n        may be even a wall (consider pipebend example). If we correct imissing directions and assign \"fin\", this method becomes\n        much less stable and also one needs to correctly take care of corner cases.\n        \"\"\"\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"DoNothing\"\n        self.implementationStep = \"PostStreaming\"\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the do-nothing boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the do-nothing boundary condition by simply returning the input distribution functions at the\n        boundary nodes.\n        \"\"\"\n        return fin[self.indices]\n</code></pre> <p>               Bases: <code>BoundaryCondition</code></p> <p>Zou-He boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the Zou-He boundary condition, which is a non-equilibrium bounce-back boundary condition. It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.</p> <p>               Bases: <code>ZouHe</code></p> <p>Regularized boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the regularized boundary condition, which is a non-equilibrium bounce-back boundary condition with additional regularization. It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.</p> <p>               Bases: <code>BoundaryCondition</code></p> <p>Extrapolation outflow boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements the extrapolation outflow boundary condition, which is a type of outflow boundary condition that uses extrapolation to avoid strong wave reflections.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition--attributes","title":"Attributes","text":"<p>lattice : Lattice     The lattice used in the simulation. nx:     The number of nodes in the x direction. ny:     The number of nodes in the y direction. nz:     The number of nodes in the z direction. dim : int     The number of dimensions in the simulation (2 or 3). precision_policy : PrecisionPolicy     The precision policy used in the simulation. indices : array-like     The indices of the boundary nodes. name : str or None     The name of the boundary condition. This should be set in subclasses. isSolid : bool     Whether the boundary condition is for a solid boundary. This should be set in subclasses. isDynamic : bool     Whether the boundary condition is dynamic (changes over time). This should be set in subclasses. needsExtraConfiguration : bool     Whether the boundary condition requires extra configuration. This should be set in subclasses. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. This should be set in subclasses.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BoundaryCondition(object):\n    \"\"\"\n    Base class for boundary conditions in a LBM simulation.\n\n    This class provides a general structure for implementing boundary conditions. It includes methods for preparing the\n    boundary attributes and for applying the boundary condition. Specific boundary conditions should be implemented as\n    subclasses of this class, with the `apply` method overridden as necessary.\n\n    Attributes\n    ----------\n    lattice : Lattice\n        The lattice used in the simulation.\n    nx:\n        The number of nodes in the x direction.\n    ny:\n        The number of nodes in the y direction.\n    nz:\n        The number of nodes in the z direction.\n    dim : int\n        The number of dimensions in the simulation (2 or 3).\n    precision_policy : PrecisionPolicy\n        The precision policy used in the simulation.\n    indices : array-like\n        The indices of the boundary nodes.\n    name : str or None\n        The name of the boundary condition. This should be set in subclasses.\n    isSolid : bool\n        Whether the boundary condition is for a solid boundary. This should be set in subclasses.\n    isDynamic : bool\n        Whether the boundary condition is dynamic (changes over time). This should be set in subclasses.\n    needsExtraConfiguration : bool\n        Whether the boundary condition requires extra configuration. This should be set in subclasses.\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. This should be set in subclasses.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy):\n        self.lattice = gridInfo[\"lattice\"]\n        self.nx = gridInfo[\"nx\"]\n        self.ny = gridInfo[\"ny\"]\n        self.nz = gridInfo[\"nz\"]\n        self.dim = gridInfo[\"dim\"]\n        self.precisionPolicy = precision_policy\n        self.indices = indices\n        self.name = None\n        self.isSolid = False\n        self.isDynamic = False\n        self.needsExtraConfiguration = False\n        self.implementationStep = \"PostStreaming\"\n\n    def create_local_mask_and_normal_arrays(self, grid_mask):\n        \"\"\"\n        Creates local mask and normal arrays for the boundary condition.\n\n        Parameters\n        ----------\n        grid_mask : array-like\n            The grid mask for the lattice.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method creates local mask and normal arrays for the boundary condition based on the grid mask.\n        If the boundary condition requires extra configuration, the `configure` method is called.\n        \"\"\"\n\n        if self.needsExtraConfiguration:\n            boundaryMask = self.get_boundary_mask(grid_mask)\n            self.configure(boundaryMask)\n            self.needsExtraConfiguration = False\n\n        boundaryMask = self.get_boundary_mask(grid_mask)\n        self.normals = self.get_normals(boundaryMask)\n        self.imissing, self.iknown = self.get_missing_indices(boundaryMask)\n        self.imissingMask, self.iknownMask, self.imiddleMask = self.get_missing_mask(boundaryMask)\n\n        return\n\n    def get_boundary_mask(self, grid_mask):\n        \"\"\"\n        Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions\n        This is to make sure the boundary condition is applied to the correct nodes as grid_mask is\n        expanded by (jax.device_count(), 1, 1)\n\n        Parameters\n        ----------\n        grid_mask : array-like\n            The grid mask for the lattice.\n\n        Returns\n        -------\n        boundaryMask : array-like\n        \"\"\"\n        shifted_indices = np.array(self.indices)\n        shifted_indices[0] += device_count()\n        shifted_indices[1:] += 1\n        # Convert back to tuple\n        shifted_indices = tuple(shifted_indices)\n        boundaryMask = np.array(grid_mask[shifted_indices])\n\n        return boundaryMask\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configures the boundary condition.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The grid mask for the boundary voxels.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method should be overridden in subclasses if the boundary condition requires extra configuration.\n        \"\"\"\n        return\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def prepare_populations(self, fout, fin, implementation_step):\n        \"\"\"\n        Prepares the distribution functions for the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The incoming distribution functions.\n        fin : jax.numpy.ndarray\n            The outgoing distribution functions.\n        implementation_step : str\n            The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The prepared distribution functions.\n\n        Notes\n        -----\n        This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.\n        \"\"\"\n        return fout\n\n    def get_normals(self, boundaryMask):\n        \"\"\"\n        Calculates the normal vectors at the boundary nodes.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        array-like\n            The normal vectors at the boundary nodes.\n\n        Notes\n        -----\n        This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.\n        \"\"\"\n        main_c = self.lattice.c.T[self.lattice.main_indices]\n        m = boundaryMask[..., self.lattice.main_indices]\n        normals = -np.dot(m, main_c)\n        return normals\n\n    def get_missing_indices(self, boundaryMask):\n        \"\"\"\n        Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing\n        directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        tuple of array-like\n            The missing and known indices for the boundary condition.\n\n        Notes\n        -----\n        This method calculates the missing and known indices based on the boundary mask. The missing indices are the\n        non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.\n        \"\"\"\n\n        # Find imissing, iknown 1-to-1 corresponding indices\n        # Note: the \"zero\" index is used as default value here and won't affect BC computations\n        nbd = len(self.indices[0])\n        imissing = np.vstack([np.arange(self.lattice.q, dtype=\"uint8\")] * nbd)\n        iknown = np.vstack([self.lattice.opp_indices] * nbd)\n        imissing[~boundaryMask] = 0\n        iknown[~boundaryMask] = 0\n        return imissing, iknown\n\n    def get_missing_mask(self, boundaryMask):\n        \"\"\"\n        Returns three boolean arrays the same shape as boundaryMask.\n        Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The boundary mask for the lattice.\n\n        Returns\n        -------\n        tuple of array-like\n            The missing, known, and middle masks for the boundary condition.\n\n        Notes\n        -----\n        This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask\n        is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask\n        is the directions that are neither missing nor known.\n        \"\"\"\n        # Find masks for imissing, iknown and imiddle\n        imissingMask = boundaryMask\n        iknownMask = imissingMask[:, self.lattice.opp_indices]\n        imiddleMask = ~(imissingMask | iknownMask)\n        return imissingMask, iknownMask, imiddleMask\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method should be overridden in subclasses to implement the specific boundary condition. The method should\n        modify the output distribution functions in place to apply the boundary condition.\n        \"\"\"\n        pass\n\n    @partial(jit, static_argnums=(0,))\n    def equilibrium(self, rho, u):\n        \"\"\"\n        Compute equilibrium distribution function.\n\n        Parameters\n        ----------\n        rho : jax.numpy.ndarray\n            The density at each node in the lattice.\n        u : jax.numpy.ndarray\n            The velocity at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The equilibrium distribution function at each node in the lattice.\n\n        Notes\n        -----\n        This method computes the equilibrium distribution function based on the density and velocity. The computation is\n        performed in the compute precision specified by the precision policy. The result is not cast to the output precision as\n        this is function is used inside other functions that require the compute precision.\n        \"\"\"\n        rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 3.0 * jnp.dot(u, c)\n        usqr = 1.5 * jnp.sum(u**2, axis=-1, keepdims=True)\n        feq = rho * self.lattice.w * (1.0 + 1.0 * cu + 0.5 * cu**2 - usqr)\n\n        return feq\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_flux(self, fneq):\n        \"\"\"\n        Compute the momentum flux.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.ndarray\n            The non-equilibrium distribution function at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The momentum flux at each node in the lattice.\n\n        Notes\n        -----\n        This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice\n        direction vectors.\n        \"\"\"\n        return jnp.dot(fneq, self.lattice.cc)\n\n    @partial(jit, static_argnums=(0,))\n    def momentum_exchange_force(self, f_poststreaming, f_postcollision):\n        \"\"\"\n        Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry\n        based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a\n        bounce-back method (e.g. Bouzidi) that accounts for curved boundaries.\n        NOTE: this function should be called after BC's are imposed.\n        [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.\n            Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339.\n        [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving\n            curved geometry, Phys. Rev. E 65 (2002) 041203.\n        [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange\n            algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.\n\n        Parameters\n        ----------\n        f_poststreaming : jax.numpy.ndarray\n            The post-streaming distribution function at each node in the lattice.\n        f_postcollision : jax.numpy.ndarray\n            The post-collision distribution function at each node in the lattice.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The force exerted on the solid geometry at each boundary node.\n\n        Notes\n        -----\n        This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method.\n        The force is computed based on the post-streaming and post-collision distribution functions. This method\n        should be called after the boundary conditions are imposed.\n        \"\"\"\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        phi = f_postcollision[self.indices][bindex, self.iknown] + f_poststreaming[self.indices][bindex, self.imissing]\n        force = jnp.sum(c[:, self.iknown] * phi, axis=-1).T\n        return force\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.apply--notes","title":"Notes","text":"<p>This method should be overridden in subclasses to implement the specific boundary condition. The method should modify the output distribution functions in place to apply the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method should be overridden in subclasses to implement the specific boundary condition. The method should\n    modify the output distribution functions in place to apply the boundary condition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configures the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The grid mask for the boundary voxels.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.configure--notes","title":"Notes","text":"<p>This method should be overridden in subclasses if the boundary condition requires extra configuration.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configures the boundary condition.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The grid mask for the boundary voxels.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method should be overridden in subclasses if the boundary condition requires extra configuration.\n    \"\"\"\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays","title":"create_local_mask_and_normal_arrays","text":"<pre><code>create_local_mask_and_normal_arrays(grid_mask)\n</code></pre> <p>Creates local mask and normal arrays for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--parameters","title":"Parameters","text":"<p>grid_mask : array-like     The grid mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.create_local_mask_and_normal_arrays--notes","title":"Notes","text":"<p>This method creates local mask and normal arrays for the boundary condition based on the grid mask. If the boundary condition requires extra configuration, the <code>configure</code> method is called.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def create_local_mask_and_normal_arrays(self, grid_mask):\n    \"\"\"\n    Creates local mask and normal arrays for the boundary condition.\n\n    Parameters\n    ----------\n    grid_mask : array-like\n        The grid mask for the lattice.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method creates local mask and normal arrays for the boundary condition based on the grid mask.\n    If the boundary condition requires extra configuration, the `configure` method is called.\n    \"\"\"\n\n    if self.needsExtraConfiguration:\n        boundaryMask = self.get_boundary_mask(grid_mask)\n        self.configure(boundaryMask)\n        self.needsExtraConfiguration = False\n\n    boundaryMask = self.get_boundary_mask(grid_mask)\n    self.normals = self.get_normals(boundaryMask)\n    self.imissing, self.iknown = self.get_missing_indices(boundaryMask)\n    self.imissingMask, self.iknownMask, self.imiddleMask = self.get_missing_mask(boundaryMask)\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium","title":"equilibrium","text":"<pre><code>equilibrium(rho, u)\n</code></pre> <p>Compute equilibrium distribution function.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--parameters","title":"Parameters","text":"<p>rho : jax.numpy.ndarray     The density at each node in the lattice. u : jax.numpy.ndarray     The velocity at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The equilibrium distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.equilibrium--notes","title":"Notes","text":"<p>This method computes the equilibrium distribution function based on the density and velocity. The computation is performed in the compute precision specified by the precision policy. The result is not cast to the output precision as this is function is used inside other functions that require the compute precision.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef equilibrium(self, rho, u):\n    \"\"\"\n    Compute equilibrium distribution function.\n\n    Parameters\n    ----------\n    rho : jax.numpy.ndarray\n        The density at each node in the lattice.\n    u : jax.numpy.ndarray\n        The velocity at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The equilibrium distribution function at each node in the lattice.\n\n    Notes\n    -----\n    This method computes the equilibrium distribution function based on the density and velocity. The computation is\n    performed in the compute precision specified by the precision policy. The result is not cast to the output precision as\n    this is function is used inside other functions that require the compute precision.\n    \"\"\"\n    rho, u = self.precisionPolicy.cast_to_compute((rho, u))\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    cu = 3.0 * jnp.dot(u, c)\n    usqr = 1.5 * jnp.sum(u**2, axis=-1, keepdims=True)\n    feq = rho * self.lattice.w * (1.0 + 1.0 * cu + 0.5 * cu**2 - usqr)\n\n    return feq\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask","title":"get_boundary_mask","text":"<pre><code>get_boundary_mask(grid_mask)\n</code></pre> <p>Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions This is to make sure the boundary condition is applied to the correct nodes as grid_mask is expanded by (jax.device_count(), 1, 1)</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask--parameters","title":"Parameters","text":"<p>grid_mask : array-like     The grid mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_boundary_mask--returns","title":"Returns","text":"<p>boundaryMask : array-like</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_boundary_mask(self, grid_mask):\n    \"\"\"\n    Add jax.device_count() to the self.indices in x-direction, and 1 to the self.indices other directions\n    This is to make sure the boundary condition is applied to the correct nodes as grid_mask is\n    expanded by (jax.device_count(), 1, 1)\n\n    Parameters\n    ----------\n    grid_mask : array-like\n        The grid mask for the lattice.\n\n    Returns\n    -------\n    boundaryMask : array-like\n    \"\"\"\n    shifted_indices = np.array(self.indices)\n    shifted_indices[0] += device_count()\n    shifted_indices[1:] += 1\n    # Convert back to tuple\n    shifted_indices = tuple(shifted_indices)\n    boundaryMask = np.array(grid_mask[shifted_indices])\n\n    return boundaryMask\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices","title":"get_missing_indices","text":"<pre><code>get_missing_indices(boundaryMask)\n</code></pre> <p>Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--returns","title":"Returns","text":"<p>tuple of array-like     The missing and known indices for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_indices--notes","title":"Notes","text":"<p>This method calculates the missing and known indices based on the boundary mask. The missing indices are the non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_missing_indices(self, boundaryMask):\n    \"\"\"\n    Returns two int8 arrays the same shape as boundaryMask. The non-zero entries of these arrays indicate missing\n    directions that require BCs (imissing) as well as their corresponding opposite directions (iknown).\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    tuple of array-like\n        The missing and known indices for the boundary condition.\n\n    Notes\n    -----\n    This method calculates the missing and known indices based on the boundary mask. The missing indices are the\n    non-zero entries of the boundary mask, and the known indices are their corresponding opposite directions.\n    \"\"\"\n\n    # Find imissing, iknown 1-to-1 corresponding indices\n    # Note: the \"zero\" index is used as default value here and won't affect BC computations\n    nbd = len(self.indices[0])\n    imissing = np.vstack([np.arange(self.lattice.q, dtype=\"uint8\")] * nbd)\n    iknown = np.vstack([self.lattice.opp_indices] * nbd)\n    imissing[~boundaryMask] = 0\n    iknown[~boundaryMask] = 0\n    return imissing, iknown\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask","title":"get_missing_mask","text":"<pre><code>get_missing_mask(boundaryMask)\n</code></pre> <p>Returns three boolean arrays the same shape as boundaryMask. Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--returns","title":"Returns","text":"<p>tuple of array-like     The missing, known, and middle masks for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_missing_mask--notes","title":"Notes","text":"<p>This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask is the directions that are neither missing nor known.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_missing_mask(self, boundaryMask):\n    \"\"\"\n    Returns three boolean arrays the same shape as boundaryMask.\n    Note: these boundary masks are useful for reduction (eg. summation) operators of selected q-directions.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    tuple of array-like\n        The missing, known, and middle masks for the boundary condition.\n\n    Notes\n    -----\n    This method calculates the missing, known, and middle masks based on the boundary mask. The missing mask\n    is the boundary mask, the known mask is the opposite directions of the missing mask, and the middle mask\n    is the directions that are neither missing nor known.\n    \"\"\"\n    # Find masks for imissing, iknown and imiddle\n    imissingMask = boundaryMask\n    iknownMask = imissingMask[:, self.lattice.opp_indices]\n    imiddleMask = ~(imissingMask | iknownMask)\n    return imissingMask, iknownMask, imiddleMask\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals","title":"get_normals","text":"<pre><code>get_normals(boundaryMask)\n</code></pre> <p>Calculates the normal vectors at the boundary nodes.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The boundary mask for the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--returns","title":"Returns","text":"<p>array-like     The normal vectors at the boundary nodes.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.get_normals--notes","title":"Notes","text":"<p>This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def get_normals(self, boundaryMask):\n    \"\"\"\n    Calculates the normal vectors at the boundary nodes.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The boundary mask for the lattice.\n\n    Returns\n    -------\n    array-like\n        The normal vectors at the boundary nodes.\n\n    Notes\n    -----\n    This method calculates the normal vectors by dotting the boundary mask with the main lattice directions.\n    \"\"\"\n    main_c = self.lattice.c.T[self.lattice.main_indices]\n    m = boundaryMask[..., self.lattice.main_indices]\n    normals = -np.dot(m, main_c)\n    return normals\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force","title":"momentum_exchange_force","text":"<pre><code>momentum_exchange_force(f_poststreaming, f_postcollision)\n</code></pre> <p>Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a bounce-back method (e.g. Bouzidi) that accounts for curved boundaries. NOTE: this function should be called after BC\u2019s are imposed. [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.     Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339. [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving     curved geometry, Phys. Rev. E 65 (2002) 041203. [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange     algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--parameters","title":"Parameters","text":"<p>f_poststreaming : jax.numpy.ndarray     The post-streaming distribution function at each node in the lattice. f_postcollision : jax.numpy.ndarray     The post-collision distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The force exerted on the solid geometry at each boundary node.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_exchange_force--notes","title":"Notes","text":"<p>This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method. The force is computed based on the post-streaming and post-collision distribution functions. This method should be called after the boundary conditions are imposed.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_exchange_force(self, f_poststreaming, f_postcollision):\n    \"\"\"\n    Using the momentum exchange method to compute the boundary force vector exerted on the solid geometry\n    based on [1] as described in [3]. Ref [2] shows how [1] is applicable to curved geometries only by using a\n    bounce-back method (e.g. Bouzidi) that accounts for curved boundaries.\n    NOTE: this function should be called after BC's are imposed.\n    [1] A.J.C. Ladd, Numerical simulations of particular suspensions via a discretized Boltzmann equation.\n        Part 2 (numerical results), J. Fluid Mech. 271 (1994) 311-339.\n    [2] R. Mei, D. Yu, W. Shyy, L.-S. Luo, Force evaluation in the lattice Boltzmann method involving\n        curved geometry, Phys. Rev. E 65 (2002) 041203.\n    [3] Caiazzo, A., &amp; Junk, M. (2008). Boundary forces in lattice Boltzmann: Analysis of momentum exchange\n        algorithm. Computers &amp; Mathematics with Applications, 55(7), 1415-1423.\n\n    Parameters\n    ----------\n    f_poststreaming : jax.numpy.ndarray\n        The post-streaming distribution function at each node in the lattice.\n    f_postcollision : jax.numpy.ndarray\n        The post-collision distribution function at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The force exerted on the solid geometry at each boundary node.\n\n    Notes\n    -----\n    This method computes the force exerted on the solid geometry at each boundary node using the momentum exchange method.\n    The force is computed based on the post-streaming and post-collision distribution functions. This method\n    should be called after the boundary conditions are imposed.\n    \"\"\"\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    phi = f_postcollision[self.indices][bindex, self.iknown] + f_poststreaming[self.indices][bindex, self.imissing]\n    force = jnp.sum(c[:, self.iknown] * phi, axis=-1).T\n    return force\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux","title":"momentum_flux","text":"<pre><code>momentum_flux(fneq)\n</code></pre> <p>Compute the momentum flux.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.ndarray     The non-equilibrium distribution function at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The momentum flux at each node in the lattice.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.momentum_flux--notes","title":"Notes","text":"<p>This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice direction vectors.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef momentum_flux(self, fneq):\n    \"\"\"\n    Compute the momentum flux.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.ndarray\n        The non-equilibrium distribution function at each node in the lattice.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The momentum flux at each node in the lattice.\n\n    Notes\n    -----\n    This method computes the momentum flux by dotting the non-equilibrium distribution function with the lattice\n    direction vectors.\n    \"\"\"\n    return jnp.dot(fneq, self.lattice.cc)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations","title":"prepare_populations","text":"<pre><code>prepare_populations(fout, fin, implementation_step)\n</code></pre> <p>Prepares the distribution functions for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The incoming distribution functions. fin : jax.numpy.ndarray     The outgoing distribution functions. implementation_step : str     The step in the lattice Boltzmann method algorithm at which the preparation is applied.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The prepared distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BoundaryCondition.prepare_populations--notes","title":"Notes","text":"<p>This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef prepare_populations(self, fout, fin, implementation_step):\n    \"\"\"\n    Prepares the distribution functions for the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The incoming distribution functions.\n    fin : jax.numpy.ndarray\n        The outgoing distribution functions.\n    implementation_step : str\n        The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The prepared distribution functions.\n\n    Notes\n    -----\n    This method should be overridden in subclasses if the boundary condition requires preparation of the distribution functions during post-collision or post-streaming. See ExtrapolationBoundaryCondition for an example.\n    \"\"\"\n    return fout\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackFullway\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostCollision\u201d. theta: jax.numpy.ndarray; Default: None     Contact angle, applied for multiphase flows and only set for wall boundary conditions. phi: jax.numpy.ndarray; Default: None     Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions. delta_rho: jax.numpy.ndarray; Default: None     Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBack(BoundaryCondition):\n    \"\"\"\n    Bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a full-way bounce-back boundary condition, where particles hitting the boundary are reflected\n    back in the direction they came from. The boundary condition is applied after the collision step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackFullway\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostCollision\".\n    theta: jax.numpy.ndarray; Default: None\n        Contact angle, applied for multiphase flows and only set for wall boundary conditions.\n    phi: jax.numpy.ndarray; Default: None\n        Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions.\n    delta_rho: jax.numpy.ndarray; Default: None\n        Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, theta=None, phi=None, delta_rho=None):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackFullway\"\n        self.implementationStep = \"PostCollision\"\n        self.theta = theta\n        self.phi = phi\n        self.delta_rho = delta_rho\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the bounce-back boundary condition by reflecting the input distribution functions at the\n        boundary nodes in the opposite direction.\n        \"\"\"\n\n        return fin[self.indices][..., self.lattice.opp_indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBack.apply--notes","title":"Notes","text":"<p>This method applies the bounce-back boundary condition by reflecting the input distribution functions at the boundary nodes in the opposite direction.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the bounce-back boundary condition by reflecting the input distribution functions at the\n    boundary nodes in the opposite direction.\n    \"\"\"\n\n    return fin[self.indices][..., self.lattice.opp_indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackFullwayMoving\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostCollision\u201d. isDynamic : bool     Whether the boundary condition is dynamic (changes over time). For this class, it is True. update_function : function     A function that updates the boundary condition. For this class, it is a function that updates the boundary     condition based on the current time step. The signature of the function is <code>update_function(time) -&gt; (indices, vel)</code>, theta: jax.numpy.ndarray; Default: None     Contact angle, applied for multiphase flows and only set for wall boundary conditions. phi: jax.numpy.ndarray; Default: None     Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions. delta_rho: pytree of jax.numpy.ndarray; Default: None     Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBackMoving(BoundaryCondition):\n    \"\"\"\n    Moving bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a moving bounce-back boundary condition, where particles hitting the boundary are reflected\n    back in the direction they came from, with an additional velocity due to the movement of the boundary. The boundary\n    condition is applied after the collision step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackFullwayMoving\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostCollision\".\n    isDynamic : bool\n        Whether the boundary condition is dynamic (changes over time). For this class, it is True.\n    update_function : function\n        A function that updates the boundary condition. For this class, it is a function that updates the boundary\n        condition based on the current time step. The signature of the function is `update_function(time) -&gt; (indices, vel)`,\n    theta: jax.numpy.ndarray; Default: None\n        Contact angle, applied for multiphase flows and only set for wall boundary conditions.\n    phi: jax.numpy.ndarray; Default: None\n        Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions.\n    delta_rho: pytree of jax.numpy.ndarray; Default: None\n        Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        gridInfo,\n        precision_policy,\n        update_function=None,\n        theta=None,\n        phi=None,\n        delta_rho=None,\n    ):\n        # We get the indices at time zero to pass to the parent class for initialization\n        indices, _ = update_function(0)\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackFullwayMoving\"\n        self.implementationStep = \"PostCollision\"\n        self.isDynamic = True\n        self.update_function = jit(update_function)\n        self.theta = theta\n        self.phi = phi\n        self.delta_rho = delta_rho\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin, time):\n        \"\"\"\n        Applies the moving bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n        time : int\n            The current time step.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        indices, vel = self.update_function(time)\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 6.0 * self.lattice.w * jnp.dot(vel, c)\n        return fout.at[indices].set(fin[indices][..., self.lattice.opp_indices] - cu)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply","title":"apply","text":"<pre><code>apply(fout, fin, time)\n</code></pre> <p>Applies the moving bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions. time : int     The current time step.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackMoving.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin, time):\n    \"\"\"\n    Applies the moving bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n    time : int\n        The current time step.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    indices, vel = self.update_function(time)\n    c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n    cu = 6.0 * self.lattice.w * jnp.dot(vel, c)\n    return fout.at[indices].set(fin[indices][..., self.lattice.opp_indices] - cu)\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cBounceBackHalfway\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. needsExtraConfiguration : bool     Whether the boundary condition needs extra configuration before it can be applied. For this class, it is True. isSolid : bool     Whether the boundary condition represents a solid boundary. For this class, it is True. vel : array-like     The prescribed value of velocity vector for the boundary condition. No-slip BC is assumed if vel=None (default). theta: jax.numpy.ndarray; Default: None     Contact angle, applied for multiphase flows and only set for wall boundary conditions. phi: jax.numpy.ndarray; Default: None     Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions. delta_rho: pytree of jax.numpy.ndarray; Default: None     Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class BounceBackHalfway(BoundaryCondition):\n    \"\"\"\n    Halfway bounce-back boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a halfway bounce-back boundary condition. The boundary condition is applied after\n    the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"BounceBackHalfway\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    needsExtraConfiguration : bool\n        Whether the boundary condition needs extra configuration before it can be applied. For this class, it is True.\n    isSolid : bool\n        Whether the boundary condition represents a solid boundary. For this class, it is True.\n    vel : array-like\n        The prescribed value of velocity vector for the boundary condition. No-slip BC is assumed if vel=None (default).\n    theta: jax.numpy.ndarray; Default: None\n        Contact angle, applied for multiphase flows and only set for wall boundary conditions.\n    phi: jax.numpy.ndarray; Default: None\n        Contact angle parameter phi, applied for multiphase flows and only set for wall boundary conditions.\n    delta_rho: pytree of jax.numpy.ndarray; Default: None\n        Contact angle parameter delta_rho, applied for multiphase flows and only set for wall boundary conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        indices,\n        gridInfo,\n        precision_policy,\n        vel=None,\n        theta=None,\n        phi=None,\n        delta_rho=None,\n    ):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"BounceBackHalfway\"\n        self.implementationStep = \"PostStreaming\"\n        self.needsExtraConfiguration = True\n        self.isSolid = True\n        self.vel = vel\n        self.theta = theta\n        self.phi = phi\n        self.delta_rho = delta_rho\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configures the boundary condition.\n\n        Parameters\n        ----------\n        boundaryMask : array-like\n            The grid mask for the boundary voxels.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of\n        the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.\n        \"\"\"\n        # Perform index shift for halfway BB.\n        hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n        nbd_orig = len(self.indices[0])\n        idx = np.array(self.indices).T\n        idx_trg = []\n        for i in range(self.lattice.q):\n            idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n        indices_new = np.unique(np.vstack(idx_trg), axis=0)\n        self.indices = tuple(indices_new.T)\n        nbd_modified = len(self.indices[0])\n        if (nbd_orig != nbd_modified) and self.vel is not None:\n            vel_avg = np.mean(self.vel, axis=0)\n            self.vel = jnp.zeros(indices_new.shape, dtype=self.precisionPolicy.compute_dtype) + vel_avg\n            print(\"WARNING: assuming a constant averaged velocity vector is imposed at all BC cells!\")\n\n        return\n\n    @partial(jit, static_argnums=(0,))\n    def impose_boundary_vel(self, fbd, bindex):\n        c = jnp.array(self.lattice.c, dtype=self.precisionPolicy.compute_dtype)\n        cu = 6.0 * self.lattice.w * jnp.dot(self.vel, c)\n        fbd = fbd.at[bindex, self.imissing].add(-cu[bindex, self.iknown])\n        return fbd\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the halfway bounce-back boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fout[self.indices]\n\n        fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n        if self.vel is not None:\n            fbd = self.impose_boundary_vel(fbd, bindex)\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the halfway bounce-back boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the halfway bounce-back boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fout[self.indices]\n\n    fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n    if self.vel is not None:\n        fbd = self.impose_boundary_vel(fbd, bindex)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configures the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--parameters","title":"Parameters","text":"<p>boundaryMask : array-like     The grid mask for the boundary voxels.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--returns","title":"Returns","text":"<p>None</p>"},{"location":"boundary_conditions/#src.boundary_conditions.BounceBackHalfway.configure--notes","title":"Notes","text":"<p>This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configures the boundary condition.\n\n    Parameters\n    ----------\n    boundaryMask : array-like\n        The grid mask for the boundary voxels.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method performs an index shift for the halfway bounce-back boundary condition. It updates the indices of\n    the boundary nodes to be the indices of fluid nodes adjacent of the solid nodes.\n    \"\"\"\n    # Perform index shift for halfway BB.\n    hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n    nbd_orig = len(self.indices[0])\n    idx = np.array(self.indices).T\n    idx_trg = []\n    for i in range(self.lattice.q):\n        idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n    indices_new = np.unique(np.vstack(idx_trg), axis=0)\n    self.indices = tuple(indices_new.T)\n    nbd_modified = len(self.indices[0])\n    if (nbd_orig != nbd_modified) and self.vel is not None:\n        vel_avg = np.mean(self.vel, axis=0)\n        self.vel = jnp.zeros(indices_new.shape, dtype=self.precisionPolicy.compute_dtype) + vel_avg\n        print(\"WARNING: assuming a constant averaged velocity vector is imposed at all BC cells!\")\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cEquilibriumBC\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. out : jax.numpy.ndarray     The equilibrium distribution function at the boundary nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class EquilibriumBC(BoundaryCondition):\n    \"\"\"\n    Equilibrium boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements an equilibrium boundary condition, where the distribution function at the boundary nodes is\n    set to the equilibrium distribution function. The boundary condition is applied after the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"EquilibriumBC\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    out : jax.numpy.ndarray\n        The equilibrium distribution function at the boundary nodes.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, rho, u):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.out = self.precisionPolicy.cast_to_output(self.equilibrium(rho, u))\n        self.name = \"EquilibriumBC\"\n        self.implementationStep = \"PostStreaming\"\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the equilibrium boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the equilibrium boundary condition by setting the output distribution functions at the\n        boundary nodes to the equilibrium distribution function.\n        \"\"\"\n        return self.out\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the equilibrium boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.EquilibriumBC.apply--notes","title":"Notes","text":"<p>This method applies the equilibrium boundary condition by setting the output distribution functions at the boundary nodes to the equilibrium distribution function.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the equilibrium boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the equilibrium boundary condition by setting the output distribution functions at the\n    boundary nodes to the equilibrium distribution function.\n    \"\"\"\n    return self.out\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__","title":"__init__","text":"<pre><code>__init__(indices, gridInfo, precision_policy)\n</code></pre> <p>Do-nothing boundary condition for a lattice Boltzmann method simulation.</p> <p>This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary condition is applied after the streaming step.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cDoNothing\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.__init__--notes","title":"Notes","text":"<p>This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \u201cfout[self.indices] is that the information that exit the domain on the opposite side of this boundary, would \u201cre-enter\u201d. This is because we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium. Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary may be even a wall (consider pipebend example). If we correct imissing directions and assign \u201cfin\u201d, this method becomes much less stable and also one needs to correctly take care of corner cases.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def __init__(self, indices, gridInfo, precision_policy):\n    \"\"\"\n    Do-nothing boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements a do-nothing boundary condition, where no action is taken at the boundary nodes. The boundary\n    condition is applied after the streaming step.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"DoNothing\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n\n    Notes\n    -----\n    This boundary condition enforces skipping of streaming altogether as it sets post-streaming equal to post-collision\n    populations (so no streaming at this BC voxels). The problem with returning post-streaming values or \"fout[self.indices]\n    is that the information that exit the domain on the opposite side of this boundary, would \"re-enter\". This is because\n    we roll the entire array and so the boundary condition acts like a one-way periodic BC. If EquilibriumBC is used as\n    the BC for that opposite boundary, then the rolled-in values are taken from the initial condition at equilibrium.\n    Otherwise if ZouHe is used for example the simulation looks like a run-down simulation at low-Re. The opposite boundary\n    may be even a wall (consider pipebend example). If we correct imissing directions and assign \"fin\", this method becomes\n    much less stable and also one needs to correctly take care of corner cases.\n    \"\"\"\n    super().__init__(indices, gridInfo, precision_policy)\n    self.name = \"DoNothing\"\n    self.implementationStep = \"PostStreaming\"\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the do-nothing boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.DoNothing.apply--notes","title":"Notes","text":"<p>This method applies the do-nothing boundary condition by simply returning the input distribution functions at the boundary nodes.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the do-nothing boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the do-nothing boundary condition by simply returning the input distribution functions at the\n    boundary nodes.\n    \"\"\"\n    return fin[self.indices]\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cZouHe\u201d. implementationStep : str     The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,     it is \u201cPostStreaming\u201d. type : str     The type of the boundary condition. It can be either \u2018velocity\u2019 for a prescribed velocity boundary condition,     or \u2018pressure\u2019 for a prescribed pressure boundary condition. prescribed : float or array-like     The prescribed values for the boundary condition. It can be either the prescribed velocities for a \u2018velocity\u2019     boundary condition, or the prescribed pressures for a \u2018pressure\u2019 boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe--references","title":"References","text":"<p>Zou, Q., &amp; He, X. (1997). On pressure and velocity boundary conditions for the lattice Boltzmann BGK model. Physics of Fluids, 9(6), 1591-1598. doi:10.1063/1.869307</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class ZouHe(BoundaryCondition):\n    \"\"\"\n    Zou-He boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the Zou-He boundary condition, which is a non-equilibrium bounce-back boundary condition.\n    It can be used to set inflow and outflow boundary conditions with prescribed pressure or velocity.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"ZouHe\".\n    implementationStep : str\n        The step in the lattice Boltzmann method algorithm at which the boundary condition is applied. For this class,\n        it is \"PostStreaming\".\n    type : str\n        The type of the boundary condition. It can be either 'velocity' for a prescribed velocity boundary condition,\n        or 'pressure' for a prescribed pressure boundary condition.\n    prescribed : float or array-like\n        The prescribed values for the boundary condition. It can be either the prescribed velocities for a 'velocity'\n        boundary condition, or the prescribed pressures for a 'pressure' boundary condition.\n\n    References\n    ----------\n    Zou, Q., &amp; He, X. (1997). On pressure and velocity boundary conditions for the lattice Boltzmann BGK model.\n    Physics of Fluids, 9(6), 1591-1598. doi:10.1063/1.869307\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, type, prescribed):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"ZouHe\"\n        self.implementationStep = \"PostStreaming\"\n        self.type = type\n        self.prescribed = prescribed\n        self.needsExtraConfiguration = True\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes\n        are assigned this type of BC.\n        \"\"\"\n        nv = np.dot(self.lattice.c, ~boundaryMask.T)\n        corner_voxels = np.count_nonzero(nv, axis=0) &gt; 1\n        # removed_voxels = np.array(self.indices)[:, corner_voxels]\n        self.indices = tuple(np.array(self.indices)[:, ~corner_voxels])\n        self.prescribed = self.prescribed[~corner_voxels]\n        return\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_vel(self, fpop, rho):\n        \"\"\"\n        Calculate velocity based on the prescribed pressure/density (Zou/He BC)\n        \"\"\"\n        unormal = -1.0 + 1.0 / rho * (\n            jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True)\n            + 2.0 * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True)\n        )\n\n        # Return the above unormal as a normal vector which sets the tangential velocities to zero\n        vel = unormal * self.normals\n        return vel\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_rho(self, fpop, vel):\n        \"\"\"\n        Calculate density based on the prescribed velocity (Zou/He BC)\n        \"\"\"\n        unormal = np.sum(self.normals * vel, axis=1)\n\n        rho = (1.0 / (1.0 + unormal))[..., None] * (\n            jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True)\n            + 2.0 * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True)\n        )\n        return rho\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def calculate_equilibrium(self, fpop):\n        \"\"\"\n        This is the ZouHe method of calculating the missing macroscopic variables at the boundary.\n        \"\"\"\n        if self.type == \"velocity\":\n            vel = self.prescribed\n            rho = self.calculate_rho(fpop, vel)\n        elif self.type == \"pressure\":\n            rho = self.prescribed\n            vel = self.calculate_vel(fpop, rho)\n        else:\n            raise ValueError(f\"type = {self.type} not supported! Use 'pressure' or 'velocity'.\")\n\n        # compute feq at the boundary\n        feq = self.equilibrium(rho, vel)\n        return feq\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def bounceback_nonequilibrium(self, fpop, feq):\n        \"\"\"\n        Calculate unknown populations using bounce-back of non-equilibrium populations\n        a la original Zou &amp; He formulation\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fpop[self.indices]\n        fknown = fpop[self.indices][bindex, self.iknown] + feq[bindex, self.imissing] - feq[bindex, self.iknown]\n        fbd = fbd.at[bindex, self.imissing].set(fknown)\n        return fbd\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, _):\n        \"\"\"\n        Applies the Zou-He boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        _ : jax.numpy.ndarray\n            The input distribution functions. This is not used in this method.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based\n        on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions\n        based on the non-equilibrium bounce-back method.\n        Tangential velocity is not ensured to be zero by adding transverse contributions based on\n        Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher\n        Reynolds numbers. One needs to use \"Regularized\" BC at higher Reynolds.\n        \"\"\"\n        # compute the equilibrium based on prescribed values and the type of BC\n        feq = self.calculate_equilibrium(fout)\n\n        # set the unknown f populations based on the non-equilibrium bounce-back method\n        fbd = self.bounceback_nonequilibrium(fout, feq)\n\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply","title":"apply","text":"<pre><code>apply(fout, _)\n</code></pre> <p>Applies the Zou-He boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. _ : jax.numpy.ndarray     The input distribution functions. This is not used in this method.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.apply--notes","title":"Notes","text":"<p>This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions based on the non-equilibrium bounce-back method. Tangential velocity is not ensured to be zero by adding transverse contributions based on Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher Reynolds numbers. One needs to use \u201cRegularized\u201d BC at higher Reynolds.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, _):\n    \"\"\"\n    Applies the Zou-He boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    _ : jax.numpy.ndarray\n        The input distribution functions. This is not used in this method.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the Zou-He boundary condition by first computing the equilibrium distribution functions based\n    on the prescribed values and the type of boundary condition, and then setting the unknown distribution functions\n    based on the non-equilibrium bounce-back method.\n    Tangential velocity is not ensured to be zero by adding transverse contributions based on\n    Hecth &amp; Harting (2010) (doi:10.1088/1742-5468/2010/01/P01018) as it caused numerical instabilities at higher\n    Reynolds numbers. One needs to use \"Regularized\" BC at higher Reynolds.\n    \"\"\"\n    # compute the equilibrium based on prescribed values and the type of BC\n    feq = self.calculate_equilibrium(fout)\n\n    # set the unknown f populations based on the non-equilibrium bounce-back method\n    fbd = self.bounceback_nonequilibrium(fout, feq)\n\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.bounceback_nonequilibrium","title":"bounceback_nonequilibrium","text":"<pre><code>bounceback_nonequilibrium(fpop, feq)\n</code></pre> <p>Calculate unknown populations using bounce-back of non-equilibrium populations a la original Zou &amp; He formulation</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef bounceback_nonequilibrium(self, fpop, feq):\n    \"\"\"\n    Calculate unknown populations using bounce-back of non-equilibrium populations\n    a la original Zou &amp; He formulation\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fpop[self.indices]\n    fknown = fpop[self.indices][bindex, self.iknown] + feq[bindex, self.imissing] - feq[bindex, self.iknown]\n    fbd = fbd.at[bindex, self.imissing].set(fknown)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_equilibrium","title":"calculate_equilibrium","text":"<pre><code>calculate_equilibrium(fpop)\n</code></pre> <p>This is the ZouHe method of calculating the missing macroscopic variables at the boundary.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_equilibrium(self, fpop):\n    \"\"\"\n    This is the ZouHe method of calculating the missing macroscopic variables at the boundary.\n    \"\"\"\n    if self.type == \"velocity\":\n        vel = self.prescribed\n        rho = self.calculate_rho(fpop, vel)\n    elif self.type == \"pressure\":\n        rho = self.prescribed\n        vel = self.calculate_vel(fpop, rho)\n    else:\n        raise ValueError(f\"type = {self.type} not supported! Use 'pressure' or 'velocity'.\")\n\n    # compute feq at the boundary\n    feq = self.equilibrium(rho, vel)\n    return feq\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_rho","title":"calculate_rho","text":"<pre><code>calculate_rho(fpop, vel)\n</code></pre> <p>Calculate density based on the prescribed velocity (Zou/He BC)</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_rho(self, fpop, vel):\n    \"\"\"\n    Calculate density based on the prescribed velocity (Zou/He BC)\n    \"\"\"\n    unormal = np.sum(self.normals * vel, axis=1)\n\n    rho = (1.0 / (1.0 + unormal))[..., None] * (\n        jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True)\n        + 2.0 * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True)\n    )\n    return rho\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.calculate_vel","title":"calculate_vel","text":"<pre><code>calculate_vel(fpop, rho)\n</code></pre> <p>Calculate velocity based on the prescribed pressure/density (Zou/He BC)</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef calculate_vel(self, fpop, rho):\n    \"\"\"\n    Calculate velocity based on the prescribed pressure/density (Zou/He BC)\n    \"\"\"\n    unormal = -1.0 + 1.0 / rho * (\n        jnp.sum(fpop[self.indices] * self.imiddleMask, axis=1, keepdims=True)\n        + 2.0 * jnp.sum(fpop[self.indices] * self.iknownMask, axis=1, keepdims=True)\n    )\n\n    # Return the above unormal as a normal vector which sets the tangential velocities to zero\n    vel = unormal * self.normals\n    return vel\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ZouHe.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes are assigned this type of BC.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Correct boundary indices to ensure that only voxelized surfaces with normal vectors along main cartesian axes\n    are assigned this type of BC.\n    \"\"\"\n    nv = np.dot(self.lattice.c, ~boundaryMask.T)\n    corner_voxels = np.count_nonzero(nv, axis=0) &gt; 1\n    # removed_voxels = np.array(self.indices)[:, corner_voxels]\n    self.indices = tuple(np.array(self.indices)[:, ~corner_voxels])\n    self.prescribed = self.prescribed[~corner_voxels]\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cRegularized\u201d. Qi : numpy.ndarray     The Qi tensor, which is used in the regularization of the distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized--references","title":"References","text":"<p>Latt, J. (2007). Hydrodynamic limit of lattice Boltzmann equations. PhD thesis, University of Geneva. Latt, J., Chopard, B., Malaspinas, O., Deville, M., &amp; Michler, A. (2008). Straight velocity boundaries in the lattice Boltzmann method. Physical Review E, 77(5), 056703. doi:10.1103/PhysRevE.77.056703</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class Regularized(ZouHe):\n    \"\"\"\n    Regularized boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the regularized boundary condition, which is a non-equilibrium bounce-back boundary condition\n    with additional regularization. It can be used to set inflow and outflow boundary conditions with prescribed pressure\n    or velocity.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"Regularized\".\n    Qi : numpy.ndarray\n        The Qi tensor, which is used in the regularization of the distribution functions.\n\n    References\n    ----------\n    Latt, J. (2007). Hydrodynamic limit of lattice Boltzmann equations. PhD thesis, University of Geneva.\n    Latt, J., Chopard, B., Malaspinas, O., Deville, M., &amp; Michler, A. (2008). Straight velocity boundaries in the\n    lattice Boltzmann method. Physical Review E, 77(5), 056703. doi:10.1103/PhysRevE.77.056703\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy, type, prescribed):\n        super().__init__(indices, gridInfo, precision_policy, type, prescribed)\n        self.name = \"Regularized\"\n        # TODO for Hesam: check to understand why corner cases cause instability here.\n        # self.needsExtraConfiguration = False\n        self.construct_symmetric_lattice_moment()\n\n    def construct_symmetric_lattice_moment(self):\n        \"\"\"\n        Construct the symmetric lattice moment Qi.\n\n        The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I,\n        where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.\n        \"\"\"\n        Qi = self.lattice.cc\n        if self.dim == 3:\n            diagonal = (0, 3, 5)\n            offdiagonal = (1, 2, 4)\n        elif self.dim == 2:\n            diagonal = (0, 2)\n            offdiagonal = (1,)\n        else:\n            raise ValueError(f\"dim = {self.dim} not supported\")\n\n        # Qi = cc - cs^2*I\n        Qi = Qi.at[:, diagonal].set(self.lattice.cc[:, diagonal] - 1.0 / 3.0)\n\n        # multiply off-diagonal elements by 2 because the Q tensor is symmetric\n        Qi = Qi.at[:, offdiagonal].set(self.lattice.cc[:, offdiagonal] * 2.0)\n\n        self.Qi = Qi.T\n        return\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def regularize_fpop(self, fpop, feq):\n        \"\"\"\n        Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.\n\n        Parameters\n        ----------\n        fpop : jax.numpy.ndarray\n            The distribution functions.\n        feq : jax.numpy.ndarray\n            The equilibrium distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The regularized distribution functions.\n        \"\"\"\n\n        # Compute momentum flux of off-equilibrium populations for regularization: Pi^1 = Pi^{neq}\n        f_neq = fpop - feq\n        PiNeq = self.momentum_flux(f_neq)\n        # PiNeq = self.momentum_flux(fpop) - self.momentum_flux(feq)\n\n        # Compute double dot product Qi:Pi1\n        # QiPi1 = np.zeros_like(fpop)\n        # Pi1 = PiNeq\n        # QiPi1 = jnp.dot(Qi, Pi1)\n        QiPi1 = jnp.dot(PiNeq, self.Qi)\n\n        # assign all populations based on eq 45 of Latt et al (2008)\n        # fneq ~ f^1\n        fpop1 = 9.0 / 2.0 * self.lattice.w[None, :] * QiPi1\n        fpop_regularized = feq + fpop1\n\n        return fpop_regularized\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, _):\n        \"\"\"\n        Applies the regularized boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        _ : jax.numpy.ndarray\n            The input distribution functions. This is not used in this method.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n\n        Notes\n        -----\n        This method applies the regularized boundary condition by first computing the equilibrium distribution functions based\n        on the prescribed values and the type of boundary condition, then setting the unknown distribution functions\n        based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.\n        \"\"\"\n\n        # compute the equilibrium based on prescribed values and the type of BC\n        feq = self.calculate_equilibrium(fout)\n\n        # set the unknown f populations based on the non-equilibrium bounce-back method\n        fbd = self.bounceback_nonequilibrium(fout, feq)\n\n        # Regularize the boundary fpop\n        fbd = self.regularize_fpop(fbd, feq)\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply","title":"apply","text":"<pre><code>apply(fout, _)\n</code></pre> <p>Applies the regularized boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. _ : jax.numpy.ndarray     The input distribution functions. This is not used in this method.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.apply--notes","title":"Notes","text":"<p>This method applies the regularized boundary condition by first computing the equilibrium distribution functions based on the prescribed values and the type of boundary condition, then setting the unknown distribution functions based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, _):\n    \"\"\"\n    Applies the regularized boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    _ : jax.numpy.ndarray\n        The input distribution functions. This is not used in this method.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n\n    Notes\n    -----\n    This method applies the regularized boundary condition by first computing the equilibrium distribution functions based\n    on the prescribed values and the type of boundary condition, then setting the unknown distribution functions\n    based on the non-equilibrium bounce-back method, and finally regularizing the distribution functions.\n    \"\"\"\n\n    # compute the equilibrium based on prescribed values and the type of BC\n    feq = self.calculate_equilibrium(fout)\n\n    # set the unknown f populations based on the non-equilibrium bounce-back method\n    fbd = self.bounceback_nonequilibrium(fout, feq)\n\n    # Regularize the boundary fpop\n    fbd = self.regularize_fpop(fbd, feq)\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.construct_symmetric_lattice_moment","title":"construct_symmetric_lattice_moment","text":"<pre><code>construct_symmetric_lattice_moment()\n</code></pre> <p>Construct the symmetric lattice moment Qi.</p> <p>The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I, where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def construct_symmetric_lattice_moment(self):\n    \"\"\"\n    Construct the symmetric lattice moment Qi.\n\n    The Qi tensor is used in the regularization of the distribution functions. It is defined as Qi = cc - cs^2*I,\n    where cc is the tensor of lattice velocities, cs is the speed of sound, and I is the identity tensor.\n    \"\"\"\n    Qi = self.lattice.cc\n    if self.dim == 3:\n        diagonal = (0, 3, 5)\n        offdiagonal = (1, 2, 4)\n    elif self.dim == 2:\n        diagonal = (0, 2)\n        offdiagonal = (1,)\n    else:\n        raise ValueError(f\"dim = {self.dim} not supported\")\n\n    # Qi = cc - cs^2*I\n    Qi = Qi.at[:, diagonal].set(self.lattice.cc[:, diagonal] - 1.0 / 3.0)\n\n    # multiply off-diagonal elements by 2 because the Q tensor is symmetric\n    Qi = Qi.at[:, offdiagonal].set(self.lattice.cc[:, offdiagonal] * 2.0)\n\n    self.Qi = Qi.T\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop","title":"regularize_fpop","text":"<pre><code>regularize_fpop(fpop, feq)\n</code></pre> <p>Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop--parameters","title":"Parameters","text":"<p>fpop : jax.numpy.ndarray     The distribution functions. feq : jax.numpy.ndarray     The equilibrium distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.Regularized.regularize_fpop--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The regularized distribution functions.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef regularize_fpop(self, fpop, feq):\n    \"\"\"\n    Regularizes the distribution functions by adding non-equilibrium contributions based on second moments of fpop.\n\n    Parameters\n    ----------\n    fpop : jax.numpy.ndarray\n        The distribution functions.\n    feq : jax.numpy.ndarray\n        The equilibrium distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The regularized distribution functions.\n    \"\"\"\n\n    # Compute momentum flux of off-equilibrium populations for regularization: Pi^1 = Pi^{neq}\n    f_neq = fpop - feq\n    PiNeq = self.momentum_flux(f_neq)\n    # PiNeq = self.momentum_flux(fpop) - self.momentum_flux(feq)\n\n    # Compute double dot product Qi:Pi1\n    # QiPi1 = np.zeros_like(fpop)\n    # Pi1 = PiNeq\n    # QiPi1 = jnp.dot(Qi, Pi1)\n    QiPi1 = jnp.dot(PiNeq, self.Qi)\n\n    # assign all populations based on eq 45 of Latt et al (2008)\n    # fneq ~ f^1\n    fpop1 = 9.0 / 2.0 * self.lattice.w[None, :] * QiPi1\n    fpop_regularized = feq + fpop1\n\n    return fpop_regularized\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow--attributes","title":"Attributes","text":"<p>name : str     The name of the boundary condition. For this class, it is \u201cExtrapolationOutflow\u201d. sound_speed : float     The speed of sound in the simulation.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow--references","title":"References","text":"<p>Geier, M., Sch\u00f6nherr, M., Pasquali, A., &amp; Krafczyk, M. (2015). The cumulant lattice Boltzmann equation in three dimensions: Theory and validation. Computers &amp; Mathematics with Applications, 70(4), 507\u2013547. doi:10.1016/j.camwa.2015.05.001.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>class ExtrapolationOutflow(BoundaryCondition):\n    \"\"\"\n    Extrapolation outflow boundary condition for a lattice Boltzmann method simulation.\n\n    This class implements the extrapolation outflow boundary condition, which is a type of outflow boundary condition\n    that uses extrapolation to avoid strong wave reflections.\n\n    Attributes\n    ----------\n    name : str\n        The name of the boundary condition. For this class, it is \"ExtrapolationOutflow\".\n    sound_speed : float\n        The speed of sound in the simulation.\n\n    References\n    ----------\n    Geier, M., Sch\u00f6nherr, M., Pasquali, A., &amp; Krafczyk, M. (2015). The cumulant lattice Boltzmann equation in three\n    dimensions: Theory and validation. Computers &amp; Mathematics with Applications, 70(4), 507\u2013547.\n    doi:10.1016/j.camwa.2015.05.001.\n    \"\"\"\n\n    def __init__(self, indices, gridInfo, precision_policy):\n        super().__init__(indices, gridInfo, precision_policy)\n        self.name = \"ExtrapolationOutflow\"\n        self.needsExtraConfiguration = True\n        self.sound_speed = 1.0 / jnp.sqrt(3.0)\n\n    def configure(self, boundaryMask):\n        \"\"\"\n        Configure the boundary condition by finding neighbouring voxel indices.\n\n        Parameters\n        ----------\n        boundaryMask : np.ndarray\n            The grid mask for the boundary voxels.\n        \"\"\"\n        hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n        idx = np.array(self.indices).T\n        idx_trg = []\n        for i in range(self.lattice.q):\n            idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n        indices_nbr = np.unique(np.vstack(idx_trg), axis=0)\n        self.indices_nbr = tuple(indices_nbr.T)\n\n        return\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def prepare_populations(self, fout, fin, implementation_step):\n        \"\"\"\n        Prepares the distribution functions for the boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The incoming distribution functions.\n        fin : jax.numpy.ndarray\n            The outgoing distribution functions.\n        implementation_step : str\n            The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The prepared distribution functions.\n\n        Notes\n        -----\n        Because this function is called \"PostCollision\", f_poststreaming refers to previous time step or t-1\n        \"\"\"\n        f_postcollision = fout\n        f_poststreaming = fin\n        if implementation_step == \"PostStreaming\":\n            return f_postcollision\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fps_bdr = f_poststreaming[self.indices]\n        fps_nbr = f_poststreaming[self.indices_nbr]\n        fpc_bdr = f_postcollision[self.indices]\n        fpop = fps_bdr[bindex, self.imissing]\n        fpop_neighbour = fps_nbr[bindex, self.imissing]\n        fpop_extrapolated = self.sound_speed * fpop_neighbour + (1.0 - self.sound_speed) * fpop\n\n        # Use the iknown directions of f_postcollision that leave the domain during streaming to store the BC data\n        fpc_bdr = fpc_bdr.at[bindex, self.iknown].set(fpop_extrapolated)\n        f_postcollision = f_postcollision.at[self.indices].set(fpc_bdr)\n        return f_postcollision\n\n    @partial(jit, static_argnums=(0,))\n    def apply(self, fout, fin):\n        \"\"\"\n        Applies the extrapolation outflow boundary condition.\n\n        Parameters\n        ----------\n        fout : jax.numpy.ndarray\n            The output distribution functions.\n        fin : jax.numpy.ndarray\n            The input distribution functions.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            The modified output distribution functions after applying the boundary condition.\n        \"\"\"\n        nbd = len(self.indices[0])\n        bindex = np.arange(nbd)[:, None]\n        fbd = fout[self.indices]\n        fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n        return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply","title":"apply","text":"<pre><code>apply(fout, fin)\n</code></pre> <p>Applies the extrapolation outflow boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The output distribution functions. fin : jax.numpy.ndarray     The input distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.apply--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The modified output distribution functions after applying the boundary condition.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply(self, fout, fin):\n    \"\"\"\n    Applies the extrapolation outflow boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The output distribution functions.\n    fin : jax.numpy.ndarray\n        The input distribution functions.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The modified output distribution functions after applying the boundary condition.\n    \"\"\"\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fbd = fout[self.indices]\n    fbd = fbd.at[bindex, self.imissing].set(fin[self.indices][bindex, self.iknown])\n    return fbd\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.configure","title":"configure","text":"<pre><code>configure(boundaryMask)\n</code></pre> <p>Configure the boundary condition by finding neighbouring voxel indices.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.configure--parameters","title":"Parameters","text":"<p>boundaryMask : np.ndarray     The grid mask for the boundary voxels.</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>def configure(self, boundaryMask):\n    \"\"\"\n    Configure the boundary condition by finding neighbouring voxel indices.\n\n    Parameters\n    ----------\n    boundaryMask : np.ndarray\n        The grid mask for the boundary voxels.\n    \"\"\"\n    hasFluidNeighbour = ~boundaryMask[:, self.lattice.opp_indices]\n    idx = np.array(self.indices).T\n    idx_trg = []\n    for i in range(self.lattice.q):\n        idx_trg.append(idx[hasFluidNeighbour[:, i], :] + self.lattice.c[:, i])\n    indices_nbr = np.unique(np.vstack(idx_trg), axis=0)\n    self.indices_nbr = tuple(indices_nbr.T)\n\n    return\n</code></pre>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations","title":"prepare_populations","text":"<pre><code>prepare_populations(fout, fin, implementation_step)\n</code></pre> <p>Prepares the distribution functions for the boundary condition.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--parameters","title":"Parameters","text":"<p>fout : jax.numpy.ndarray     The incoming distribution functions. fin : jax.numpy.ndarray     The outgoing distribution functions. implementation_step : str     The step in the lattice Boltzmann method algorithm at which the preparation is applied.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The prepared distribution functions.</p>"},{"location":"boundary_conditions/#src.boundary_conditions.ExtrapolationOutflow.prepare_populations--notes","title":"Notes","text":"<p>Because this function is called \u201cPostCollision\u201d, f_poststreaming refers to previous time step or t-1</p> Source code in <code>src/boundary_conditions.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef prepare_populations(self, fout, fin, implementation_step):\n    \"\"\"\n    Prepares the distribution functions for the boundary condition.\n\n    Parameters\n    ----------\n    fout : jax.numpy.ndarray\n        The incoming distribution functions.\n    fin : jax.numpy.ndarray\n        The outgoing distribution functions.\n    implementation_step : str\n        The step in the lattice Boltzmann method algorithm at which the preparation is applied.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The prepared distribution functions.\n\n    Notes\n    -----\n    Because this function is called \"PostCollision\", f_poststreaming refers to previous time step or t-1\n    \"\"\"\n    f_postcollision = fout\n    f_poststreaming = fin\n    if implementation_step == \"PostStreaming\":\n        return f_postcollision\n    nbd = len(self.indices[0])\n    bindex = np.arange(nbd)[:, None]\n    fps_bdr = f_poststreaming[self.indices]\n    fps_nbr = f_poststreaming[self.indices_nbr]\n    fpc_bdr = f_postcollision[self.indices]\n    fpop = fps_bdr[bindex, self.imissing]\n    fpop_neighbour = fps_nbr[bindex, self.imissing]\n    fpop_extrapolated = self.sound_speed * fpop_neighbour + (1.0 - self.sound_speed) * fpop\n\n    # Use the iknown directions of f_postcollision that leave the domain during streaming to store the BC data\n    fpc_bdr = fpc_bdr.at[bindex, self.iknown].set(fpop_extrapolated)\n    f_postcollision = f_postcollision.at[self.indices].set(fpc_bdr)\n    return f_postcollision\n</code></pre>"},{"location":"lattice/","title":"JAX-LaB lattice","text":"<p>               Bases: <code>object</code></p> <p>This class represents a lattice in the Lattice Boltzmann Method.</p> <p>It stores the properties of the lattice, including the dimensions, the number of velocities, the velocity vectors, the weights, the moments, and the indices of the opposite, main, right, and left velocities.</p> <p>The class also provides methods to construct these properties based on the name of the lattice.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 2D D2Q9 lattice.</p> <p>D2Q9 stands for two-dimensional nine-velocity model. It is a common model used in the Lat tice Boltzmann Method for simulating fluid flows in two dimensions.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 3D D3Q19 lattice.</p> <p>D3Q19 stands for three-dimensional nineteen-velocity model. It is a common model used in the Lattice Boltzmann Method for simulating fluid flows in three dimensions.</p> <p>               Bases: <code>Lattice</code></p> <p>Lattice class for 3D D3Q27 lattice.</p> <p>D3Q27 stands for three-dimensional twenty-seven-velocity model. It is a common model used in the Lattice Boltzmann Method for simulating fluid flows in three dimensions.</p>"},{"location":"lattice/#src.lattice.Lattice--parameters","title":"Parameters","text":"<p>name (str): The name of the lattice, which specifies the dimensions and the number of velocities. For example, \u201cD2Q9\u201d represents a 2D lattice with 9 velocities.</p> <p>precision (str, optional): The precision of the computations. It can be \u201cf32/f32\u201d, \u201cf32/f16\u201d, \u201cf64/f64\u201d, \u201cf64/f32\u201d, or \u201cf64/f16\u201d. The first part before the slash is the precision of the computations, and the second part after the slash is the precision of the outputs.</p> Source code in <code>src/lattice.py</code> <pre><code>class Lattice(object):\n    \"\"\"\n    This class represents a lattice in the Lattice Boltzmann Method.\n\n    It stores the properties of the lattice, including the dimensions, the number of\n    velocities, the velocity vectors, the weights, the moments, and the indices of the\n    opposite, main, right, and left velocities.\n\n    The class also provides methods to construct these properties based on the name of the\n    lattice.\n\n    Parameters\n    ----------\n    name (str): The name of the lattice, which specifies the dimensions and the number of velocities.\n    For example, \"D2Q9\" represents a 2D lattice with 9 velocities.\n\n    precision (str, optional): The precision of the computations. It can be \"f32/f32\", \"f32/f16\", \"f64/f64\",\n    \"f64/f32\", or \"f64/f16\". The first part before the slash is the precision of the\n    computations, and the second part after the slash is the precision of the outputs.\n    \"\"\"\n\n    def __init__(self, name, precision=\"f32/f32\") -&gt; None:\n        self.name = name\n        dq = re.findall(r\"\\d+\", name)\n        self.precision = precision\n        self.d = int(dq[0])\n        self.q = int(dq[1])\n        if precision == \"f32/f32\" or precision == \"f32/f16\":\n            self.precisionPolicy = jnp.float32\n        elif precision == \"f64/f64\" or precision == \"f64/f32\" or precision == \"f64/f16\":\n            self.precisionPolicy = jnp.float64\n        elif precision == \"f16/f16\":\n            self.precisionPolicy = jnp.float16\n        else:\n            raise ValueError(\"precision not supported\")\n\n        # Construct the properties of the lattice\n        self.c = jnp.array(self.construct_lattice_velocity(), dtype=jnp.int8)\n        self.w = jnp.array(self.construct_lattice_weight(), dtype=self.precisionPolicy)\n        self.cc = jnp.array(self.construct_lattice_moment(), dtype=self.precisionPolicy)\n        self.opp_indices = jnp.array(self.construct_opposite_indices(), dtype=jnp.int8)\n        self.main_indices = jnp.array(self.construct_main_indices(), dtype=jnp.int8)\n        self.right_indices = np.array(self.construct_right_indices(), dtype=jnp.int8)\n        self.left_indices = np.array(self.construct_left_indices(), dtype=jnp.int8)\n\n    def construct_opposite_indices(self):\n        \"\"\"\n        This function constructs the indices of the opposite velocities for each velocity.\n\n        The opposite velocity of a velocity is the velocity that has the same magnitude but the\n        opposite direction.\n\n        Returns\n        -------\n        opposite (numpy.ndarray): The indices of the opposite velocities.\n        \"\"\"\n        c = self.c.T\n        opposite = np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])\n        return opposite\n\n    def construct_right_indices(self):\n        \"\"\"\n        This function constructs the indices of the velocities that point in the positive\n        x-direction.\n\n        Returns\n        -------\n        (numpy.ndarray): The indices of the right velocities.\n        \"\"\"\n        c = self.c.T\n        return np.nonzero(c[:, 0] == 1)[0]\n\n    def construct_left_indices(self):\n        \"\"\"\n        This function constructs the indices of the velocities that point in the negative\n        x-direction.\n\n        Returns\n        -------\n        (numpy.ndarray): The indices of the left velocities.\n        \"\"\"\n        c = self.c.T\n        return np.nonzero(c[:, 0] == -1)[0]\n\n    def construct_main_indices(self):\n        \"\"\"\n        This function constructs the indices of the main velocities.\n\n        The main velocities are the velocities that have a magnitude of 1 in lattice units.\n\n        Returns\n        -------\n        (numpy.ndarray): The indices of the main velocities.\n        \"\"\"\n        c = self.c.T\n        if self.d == 2:\n            return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]\n\n        elif self.d == 3:\n            return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) + np.abs(c[:, 2]) == 1))[0]\n\n    def construct_lattice_velocity(self):\n        \"\"\"\n        This function constructs the velocity vectors of the lattice.\n\n        The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9\n        lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1),\n        (1,-1), and (-1,1).\n\n        Returns\n        -------\n        c.T (numpy.ndarray): The velocity vectors of the lattice, transposed.\n        \"\"\"\n        if self.name == \"D2Q9\":  # D2Q9\n            cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]\n            cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]\n            c = np.array(tuple(zip(cx, cy)))\n        elif self.name == \"D3Q19\":  # D3Q19\n            c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n            c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n        elif self.name == \"D3Q27\":  # D3Q27\n            c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n            # c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n            c = np.array(c)\n        else:\n            raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n        return c.T\n\n    def construct_lattice_weight(self):\n        \"\"\"\n        This function constructs the weights of the lattice.\n\n        The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice,\n        the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the\n        diagonal velocities.\n\n        Returns\n        -------\n        w (numpy.ndarray): The weights of the lattice.\n        \"\"\"\n        # Get the transpose of the lattice vector\n        c = self.c.T\n\n        # Initialize the weights to be 1/36\n        w = 1.0 / 36.0 * np.ones(self.q)\n\n        # Update the weights for 2D and 3D lattices\n        if self.name == \"D2Q9\":\n            w[np.linalg.norm(c, axis=1) &lt; 1.1] = 1.0 / 9.0\n            w[0] = 4.0 / 9.0\n        elif self.name == \"D3Q19\":\n            w[np.linalg.norm(c, axis=1) &lt; 1.1] = 2.0 / 36.0\n            w[0] = 1.0 / 3.0\n        elif self.name == \"D3Q27\":\n            cl = np.linalg.norm(c, axis=1)\n            w[np.isclose(cl, 1.0, atol=1e-8)] = 2.0 / 27.0\n            w[(cl &gt; 1) &amp; (cl &lt;= np.sqrt(2))] = 1.0 / 54.0\n            w[(cl &gt; np.sqrt(2)) &amp; (cl &lt;= np.sqrt(3))] = 1.0 / 216.0\n            w[0] = 8.0 / 27.0\n        else:\n            raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n        # Return the weights\n        return w\n\n    def construct_lattice_moment(self):\n        \"\"\"\n        This function constructs the moments of the lattice.\n\n        The moments are the products of the velocity vectors, which are used in the computation of\n        the equilibrium distribution functions and the collision operator in the Lattice Boltzmann\n        Method (LBM).\n\n        Returns\n        -------\n        cc (numpy.ndarray): The moments of the lattice.\n        \"\"\"\n        c = self.c.T\n        # Counter for the loop\n        cntr = 0\n\n        # nt: number of independent elements of a symmetric tensor\n        nt = self.d * (self.d + 1) // 2\n\n        cc = np.zeros((self.q, nt))\n        for a in range(0, self.d):\n            for b in range(a, self.d):\n                cc[:, cntr] = c[:, a] * c[:, b]\n                cntr += 1\n\n        return cc\n\n    def __str__(self):\n        return self.name\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_moment","title":"construct_lattice_moment","text":"<pre><code>construct_lattice_moment()\n</code></pre> <p>This function constructs the moments of the lattice.</p> <p>The moments are the products of the velocity vectors, which are used in the computation of the equilibrium distribution functions and the collision operator in the Lattice Boltzmann Method (LBM).</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_moment--returns","title":"Returns","text":"<p>cc (numpy.ndarray): The moments of the lattice.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_moment(self):\n    \"\"\"\n    This function constructs the moments of the lattice.\n\n    The moments are the products of the velocity vectors, which are used in the computation of\n    the equilibrium distribution functions and the collision operator in the Lattice Boltzmann\n    Method (LBM).\n\n    Returns\n    -------\n    cc (numpy.ndarray): The moments of the lattice.\n    \"\"\"\n    c = self.c.T\n    # Counter for the loop\n    cntr = 0\n\n    # nt: number of independent elements of a symmetric tensor\n    nt = self.d * (self.d + 1) // 2\n\n    cc = np.zeros((self.q, nt))\n    for a in range(0, self.d):\n        for b in range(a, self.d):\n            cc[:, cntr] = c[:, a] * c[:, b]\n            cntr += 1\n\n    return cc\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_velocity","title":"construct_lattice_velocity","text":"<pre><code>construct_lattice_velocity()\n</code></pre> <p>This function constructs the velocity vectors of the lattice.</p> <p>The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9 lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), and (-1,1).</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_velocity--returns","title":"Returns","text":"<p>c.T (numpy.ndarray): The velocity vectors of the lattice, transposed.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_velocity(self):\n    \"\"\"\n    This function constructs the velocity vectors of the lattice.\n\n    The velocity vectors are defined based on the name of the lattice. For example, for a D2Q9\n    lattice, there are 9 velocities: (0,0), (1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1),\n    (1,-1), and (-1,1).\n\n    Returns\n    -------\n    c.T (numpy.ndarray): The velocity vectors of the lattice, transposed.\n    \"\"\"\n    if self.name == \"D2Q9\":  # D2Q9\n        cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]\n        cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]\n        c = np.array(tuple(zip(cx, cy)))\n    elif self.name == \"D3Q19\":  # D3Q19\n        c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n        c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n    elif self.name == \"D3Q27\":  # D3Q27\n        c = [(x, y, z) for x in [0, -1, 1] for y in [0, -1, 1] for z in [0, -1, 1]]\n        # c = np.array([ci for ci in c if np.linalg.norm(ci) &lt; 1.5])\n        c = np.array(c)\n    else:\n        raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n    return c.T\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_weight","title":"construct_lattice_weight","text":"<pre><code>construct_lattice_weight()\n</code></pre> <p>This function constructs the weights of the lattice.</p> <p>The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice, the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the diagonal velocities.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_lattice_weight--returns","title":"Returns","text":"<p>w (numpy.ndarray): The weights of the lattice.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_lattice_weight(self):\n    \"\"\"\n    This function constructs the weights of the lattice.\n\n    The weights are defined based on the name of the lattice. For example, for a D2Q9 lattice,\n    the weights are 4/9 for the rest velocity, 1/9 for the main velocities, and 1/36 for the\n    diagonal velocities.\n\n    Returns\n    -------\n    w (numpy.ndarray): The weights of the lattice.\n    \"\"\"\n    # Get the transpose of the lattice vector\n    c = self.c.T\n\n    # Initialize the weights to be 1/36\n    w = 1.0 / 36.0 * np.ones(self.q)\n\n    # Update the weights for 2D and 3D lattices\n    if self.name == \"D2Q9\":\n        w[np.linalg.norm(c, axis=1) &lt; 1.1] = 1.0 / 9.0\n        w[0] = 4.0 / 9.0\n    elif self.name == \"D3Q19\":\n        w[np.linalg.norm(c, axis=1) &lt; 1.1] = 2.0 / 36.0\n        w[0] = 1.0 / 3.0\n    elif self.name == \"D3Q27\":\n        cl = np.linalg.norm(c, axis=1)\n        w[np.isclose(cl, 1.0, atol=1e-8)] = 2.0 / 27.0\n        w[(cl &gt; 1) &amp; (cl &lt;= np.sqrt(2))] = 1.0 / 54.0\n        w[(cl &gt; np.sqrt(2)) &amp; (cl &lt;= np.sqrt(3))] = 1.0 / 216.0\n        w[0] = 8.0 / 27.0\n    else:\n        raise ValueError(\"Supported Lattice types are D2Q9, D3Q19 and D3Q27\")\n\n    # Return the weights\n    return w\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_left_indices","title":"construct_left_indices","text":"<pre><code>construct_left_indices()\n</code></pre> <p>This function constructs the indices of the velocities that point in the negative x-direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_left_indices--returns","title":"Returns","text":"<p>(numpy.ndarray): The indices of the left velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_left_indices(self):\n    \"\"\"\n    This function constructs the indices of the velocities that point in the negative\n    x-direction.\n\n    Returns\n    -------\n    (numpy.ndarray): The indices of the left velocities.\n    \"\"\"\n    c = self.c.T\n    return np.nonzero(c[:, 0] == -1)[0]\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_main_indices","title":"construct_main_indices","text":"<pre><code>construct_main_indices()\n</code></pre> <p>This function constructs the indices of the main velocities.</p> <p>The main velocities are the velocities that have a magnitude of 1 in lattice units.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_main_indices--returns","title":"Returns","text":"<p>(numpy.ndarray): The indices of the main velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_main_indices(self):\n    \"\"\"\n    This function constructs the indices of the main velocities.\n\n    The main velocities are the velocities that have a magnitude of 1 in lattice units.\n\n    Returns\n    -------\n    (numpy.ndarray): The indices of the main velocities.\n    \"\"\"\n    c = self.c.T\n    if self.d == 2:\n        return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]\n\n    elif self.d == 3:\n        return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) + np.abs(c[:, 2]) == 1))[0]\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_opposite_indices","title":"construct_opposite_indices","text":"<pre><code>construct_opposite_indices()\n</code></pre> <p>This function constructs the indices of the opposite velocities for each velocity.</p> <p>The opposite velocity of a velocity is the velocity that has the same magnitude but the opposite direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_opposite_indices--returns","title":"Returns","text":"<p>opposite (numpy.ndarray): The indices of the opposite velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_opposite_indices(self):\n    \"\"\"\n    This function constructs the indices of the opposite velocities for each velocity.\n\n    The opposite velocity of a velocity is the velocity that has the same magnitude but the\n    opposite direction.\n\n    Returns\n    -------\n    opposite (numpy.ndarray): The indices of the opposite velocities.\n    \"\"\"\n    c = self.c.T\n    opposite = np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])\n    return opposite\n</code></pre>"},{"location":"lattice/#src.lattice.Lattice.construct_right_indices","title":"construct_right_indices","text":"<pre><code>construct_right_indices()\n</code></pre> <p>This function constructs the indices of the velocities that point in the positive x-direction.</p>"},{"location":"lattice/#src.lattice.Lattice.construct_right_indices--returns","title":"Returns","text":"<p>(numpy.ndarray): The indices of the right velocities.</p> Source code in <code>src/lattice.py</code> <pre><code>def construct_right_indices(self):\n    \"\"\"\n    This function constructs the indices of the velocities that point in the positive\n    x-direction.\n\n    Returns\n    -------\n    (numpy.ndarray): The indices of the right velocities.\n    \"\"\"\n    c = self.c.T\n    return np.nonzero(c[:, 0] == 1)[0]\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD2Q9--parameters","title":"Parameters","text":"<p>precision (str, optional): The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD2Q9(Lattice):\n    \"\"\"\n    Lattice class for 2D D2Q9 lattice.\n\n    D2Q9 stands for two-dimensional nine-velocity model. It is a common model used in the\n    Lat tice Boltzmann Method for simulating fluid flows in two dimensions.\n\n    Parameters\n    ----------\n    precision (str, optional): The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D2Q9\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(9)), dtype=jnp.int8)\n        self.im = 3  # Number of imiddles (includes center)\n        self.ik = 3  # Number of iknowns or iunknowns\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD3Q19--parameters","title":"Parameters","text":"<p>precision (str, optional): The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD3Q19(Lattice):\n    \"\"\"\n    Lattice class for 3D D3Q19 lattice.\n\n    D3Q19 stands for three-dimensional nineteen-velocity model. It is a common model used in the\n    Lattice Boltzmann Method for simulating fluid flows in three dimensions.\n\n    Parameters\n    ----------\n    precision (str, optional): The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D3Q19\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(19)), dtype=jnp.int8)\n\n        self.im = 9  # Number of imiddles (includes center)\n        self.ik = 5  # Number of iknowns or iunknowns\n</code></pre>"},{"location":"lattice/#src.lattice.LatticeD3Q27--parameters","title":"Parameters","text":"<p>precision (str, optional): The precision of the lattice. The default is \u201cf32/f32\u201d</p> Source code in <code>src/lattice.py</code> <pre><code>class LatticeD3Q27(Lattice):\n    \"\"\"\n    Lattice class for 3D D3Q27 lattice.\n\n    D3Q27 stands for three-dimensional twenty-seven-velocity model. It is a common model used in the\n    Lattice Boltzmann Method for simulating fluid flows in three dimensions.\n\n    Parameters\n    ----------\n    precision (str, optional): The precision of the lattice. The default is \"f32/f32\"\n    \"\"\"\n\n    def __init__(self, precision=\"f32/f32\"):\n        super().__init__(\"D3Q27\", precision)\n        self._set_constants()\n\n    def _set_constants(self):\n        self.cs = jnp.sqrt(3) / 3.0\n        self.cs2 = 1.0 / 3.0\n        self.inv_cs2 = 3.0\n        self.i_s = jnp.asarray(list(range(27)), dtype=jnp.int8)\n</code></pre>"},{"location":"models/","title":"JAX-LaB models","text":"<p>               Bases: <code>LBMBase</code></p> <p>BGK simulation class.</p> <p>This class implements the Bhatnagar-Gross-Krook (BGK) approximation for the collision step in the Lattice Boltzmann Method.</p> Source code in <code>src/models.py</code> <pre><code>class BGKSim(LBMBase):\n    \"\"\"\n    BGK simulation class.\n\n    This class implements the Bhatnagar-Gross-Krook (BGK) approximation for the collision step in the Lattice Boltzmann Method.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        BGK collision step for lattice.\n\n        The collision step is where the main physics of the LBM is applied. In the BGK approximation,\n        the distribution function is relaxed towards the equilibrium distribution function.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, cast_output=False)\n        fneq = f - feq\n        fout = f - self.omega * fneq\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>KBC simulation class.</p> <p>This class implements the Karlin-B\u00f6sch-Chikatamarla (KBC) model for the collision step in the Lattice Boltzmann Method.</p> Source code in <code>src/models.py</code> <pre><code>class KBCSim(LBMBase):\n    \"\"\"\n    KBC simulation class.\n\n    This class implements the Karlin-B\u00f6sch-Chikatamarla (KBC) model for the collision step in the Lattice Boltzmann Method.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        if kwargs.get(\"lattice\").name != \"D3Q27\" and kwargs.get(\"nz\") &gt; 0:\n            raise ValueError(\"KBC collision operator in 3D must only be used with D3Q27 lattice.\")\n        super().__init__(**kwargs)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        KBC collision step for lattice.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        tiny = 1e-32\n        beta = self.omega * 0.5\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, cast_output=False)\n        fneq = f - feq\n        if self.dim == 2:\n            deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n        else:\n            deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n        deltaH = fneq - deltaS\n        invBeta = 1.0 / beta\n        gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (\n            tiny + self.entropic_scalar_product(deltaH, deltaH, feq)\n        )\n\n        fout = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n\n        # add external force\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision_modified(self, f):\n        \"\"\"\n        Alternative KBC collision step for lattice.\n        Note:\n        At low Reynolds number the orignal KBC collision above produces inaccurate results because\n        it does not check for the entropy increase/decrease. The KBC stabalizations should only be\n        applied in principle to cells whose entropy decrease after a regular BGK collision. This is\n        the case in most cells at higher Reynolds numbers and hence a check may not be needed.\n        Overall the following alternative collision is more reliable and may replace the original\n        implementation. The issue at the moment is that it is about 60-80% slower than the above method.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        tiny = 1e-32\n        beta = self.omega * 0.5\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u, castOutput=False)\n\n        # Alternative KBC: only stabalizes for voxels whose entropy decreases after BGK collision.\n        f_bgk = f - self.omega * (f - feq)\n        H_fin = jnp.sum(f * jnp.log(f / self.w), axis=-1, keepdims=True)\n        H_fout = jnp.sum(f_bgk * jnp.log(f_bgk / self.w), axis=-1, keepdims=True)\n\n        # the rest is identical to collision_deprecated\n        fneq = f - feq\n        if self.dim == 2:\n            deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n        else:\n            deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n        deltaH = fneq - deltaS\n        invBeta = 1.0 / beta\n        gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (\n            tiny + self.entropic_scalar_product(deltaH, deltaH, feq)\n        )\n\n        f_kbc = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n        fout = jnp.where(H_fout &gt; H_fin, f_kbc, f_bgk)\n\n        # add external force\n        if self.force is not None:\n            fout = self.apply_force(fout, feq, rho, u)\n        return self.precisionPolicy.cast_to_output(fout)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def entropic_scalar_product(self, x, y, feq):\n        \"\"\"\n        Compute the entropic scalar product of x and y to approximate gamma in KBC.\n\n        Returns\n        -------\n        jax.numpy.array\n            Entropic scalar product of x, y, and feq.\n        \"\"\"\n        return jnp.sum(x * y / feq, axis=-1)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def fdecompose_shear_d2q9(self, fneq):\n        \"\"\"\n        Decompose fneq into shear components for D2Q9 lattice.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.array\n            Non-equilibrium distribution function.\n\n        Returns\n        -------\n        jax.numpy.array\n            Shear components of fneq.\n        \"\"\"\n        Pi = self.momentum_flux(fneq)\n        N = Pi[..., 0] - Pi[..., 2]\n        s = jnp.zeros_like(fneq)\n        s = s.at[..., 6].set(N)\n        s = s.at[..., 3].set(N)\n        s = s.at[..., 2].set(-N)\n        s = s.at[..., 1].set(-N)\n        s = s.at[..., 8].set(Pi[..., 1])\n        s = s.at[..., 4].set(-Pi[..., 1])\n        s = s.at[..., 5].set(-Pi[..., 1])\n        s = s.at[..., 7].set(Pi[..., 1])\n\n        return s\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def fdecompose_shear_d3q27(self, fneq):\n        \"\"\"\n        Decompose fneq into shear components for D3Q27 lattice.\n\n        Parameters\n        ----------\n        fneq : jax.numpy.ndarray\n            Non-equilibrium distribution function.\n\n        Returns\n        -------\n        jax.numpy.ndarray\n            Shear components of fneq.\n        \"\"\"\n        # if self.grid.dim == 3:\n        #     diagonal    = (0, 3, 5)\n        #     offdiagonal = (1, 2, 4)\n        # elif self.grid.dim == 2:\n        #     diagonal    = (0, 2)\n        #     offdiagonal = (1,)\n\n        # c=\n        # array([[0, 0, 0],-----0\n        #        [0, 0, -1],----1\n        #        [0, 0, 1],-----2\n        #        [0, -1, 0],----3\n        #        [0, -1, -1],---4\n        #        [0, -1, 1],----5\n        #        [0, 1, 0],-----6\n        #        [0, 1, -1],----7\n        #        [0, 1, 1],-----8\n        #        [-1, 0, 0],----9\n        #        [-1, 0, -1],--10\n        #        [-1, 0, 1],---11\n        #        [-1, -1, 0],--12\n        #        [-1, -1, -1],-13\n        #        [-1, -1, 1],--14\n        #        [-1, 1, 0],---15\n        #        [-1, 1, -1],--16\n        #        [-1, 1, 1],---17\n        #        [1, 0, 0],----18\n        #        [1, 0, -1],---19\n        #        [1, 0, 1],----20\n        #        [1, -1, 0],---21\n        #        [1, -1, -1],--22\n        #        [1, -1, 1],---23\n        #        [1, 1, 0],----24\n        #        [1, 1, -1],---25\n        #        [1, 1, 1]])---26\n        Pi = self.momentum_flux(fneq)\n        Nxz = Pi[..., 0] - Pi[..., 5]\n        Nyz = Pi[..., 3] - Pi[..., 5]\n\n        # For c = (i, 0, 0), c = (0, j, 0) and c = (0, 0, k)\n        s = jnp.zeros_like(fneq)\n        s = s.at[..., 9].set((2.0 * Nxz - Nyz) / 6.0)\n        s = s.at[..., 18].set((2.0 * Nxz - Nyz) / 6.0)\n        s = s.at[..., 3].set((-Nxz + 2.0 * Nyz) / 6.0)\n        s = s.at[..., 6].set((-Nxz + 2.0 * Nyz) / 6.0)\n        s = s.at[..., 1].set((-Nxz - Nyz) / 6.0)\n        s = s.at[..., 2].set((-Nxz - Nyz) / 6.0)\n\n        # For c = (i, j, 0)\n        s = s.at[..., 12].set(Pi[..., 1] / 4.0)\n        s = s.at[..., 24].set(Pi[..., 1] / 4.0)\n        s = s.at[..., 21].set(-Pi[..., 1] / 4.0)\n        s = s.at[..., 15].set(-Pi[..., 1] / 4.0)\n\n        # For c = (i, 0, k)\n        s = s.at[..., 10].set(Pi[..., 2] / 4.0)\n        s = s.at[..., 20].set(Pi[..., 2] / 4.0)\n        s = s.at[..., 19].set(-Pi[..., 2] / 4.0)\n        s = s.at[..., 11].set(-Pi[..., 2] / 4.0)\n\n        # For c = (0, j, k)\n        s = s.at[..., 8].set(Pi[..., 4] / 4.0)\n        s = s.at[..., 4].set(Pi[..., 4] / 4.0)\n        s = s.at[..., 7].set(-Pi[..., 4] / 4.0)\n        s = s.at[..., 5].set(-Pi[..., 4] / 4.0)\n\n        return s\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>Advection Diffusion Model based on the BGK model.</p> Source code in <code>src/models.py</code> <pre><code>class AdvectionDiffusionBGK(LBMBase):\n    \"\"\"\n    Advection Diffusion Model based on the BGK model.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.vel = kwargs.get(\"vel\", None)\n        if self.vel is None:\n            raise ValueError(\"Velocity must be specified for AdvectionDiffusionBGK.\")\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        BGK collision step for lattice.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        rho = jnp.sum(f, axis=-1, keepdims=True)\n        feq = self.equilibrium(rho, self.vel, cast_output=False)\n        fneq = f - feq\n        fout = f - self.omega * fneq\n        return self.precisionPolicy.cast_to_output(fout)\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>Multi-relaxation time model.</p> Source code in <code>src/models.py</code> <pre><code>class MRTSim(LBMBase):\n    \"\"\"\n    Multi-relaxation time model.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs.update({\"omega\": 1.0})\n        super().__init__(**kwargs)\n        self.s_rho = kwargs.get(\"s_rho\")\n        self.s_e = kwargs.get(\"s_e\")\n        self.s_eta = kwargs.get(\"s_eta\")\n        self.s_j = kwargs.get(\"s_j\")\n        self.s_q = kwargs.get(\"s_q\")\n        self.s_v = self.omega\n        self.M_inv = jnp.array(\n            np.transpose(np.linalg.inv(kwargs.get(\"M\"))),\n            dtype=self.precisionPolicy.compute_dtype,\n        )\n        self.M = jnp.array(np.transpose(kwargs.get(\"M\")), dtype=self.precisionPolicy.compute_dtype)\n        if isinstance(self.lattice, LatticeD2Q9):\n            self.S = jnp.array(\n                np.diag([self.s_rho, self.s_e, self.s_eta, self.s_j, self.s_q, self.s_j, self.s_q, self.s_v, self.s_v]),\n                dtype=self.precisionPolicy.compute_dtype,\n            )\n        elif isinstance(self.lattice, LatticeD3Q19):\n            self.s_pi = kwargs.get(\"s_pi\")\n            self.s_m = kwargs.get(\"s_m\")\n            self.S = jnp.array(\n                np.diag([\n                    self.s_rho,\n                    self.s_e,\n                    self.s_eta,\n                    self.s_j,\n                    self.s_q,\n                    self.s_j,\n                    self.s_q,\n                    self.s_j,\n                    self.s_q,\n                    self.s_v,\n                    self.s_pi,\n                    self.s_v,\n                    self.s_pi,\n                    self.s_v,\n                    self.s_v,\n                    self.s_v,\n                    self.s_m,\n                    self.s_m,\n                    self.s_m,\n                ]),\n                dtype=self.precisionPolicy.compute_dtype,\n            )\n        else:\n            NotImplementedError(f\"Lattice type {self.lattice.name} has not been implemented\")\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, f):\n        \"\"\"\n        MRT collision step for lattice.\n        \"\"\"\n        f = self.precisionPolicy.cast_to_compute(f)\n        m = jnp.dot(f, self.M)\n        rho, u = self.update_macroscopic(f)\n        feq = self.equilibrium(rho, u)\n        meq = jnp.dot(feq, self.M)\n        mout = -jnp.dot(m - meq, self.S)\n        if self.force is not None:\n            mout = self.apply_force(mout, meq, rho, u)\n        return self.precisionPolicy.cast_to_output(f + jnp.dot(mout, self.M_inv))\n</code></pre> <p>               Bases: <code>LBMBase</code></p> <p>Central moment (cascaded) collision model.</p> Source code in <code>src/models.py</code> <pre><code>class CLBMSim(LBMBase):\n    \"\"\"\n    Central moment (cascaded) collision model.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs.update({\"omega\": 1.0})\n        super().__init__(**kwargs)\n        self.M_inv = jnp.array(\n            np.transpose(np.linalg.inv(kwargs.get(\"M\"))),\n            dtype=self.precisionPolicy.compute_dtype,\n        )\n        self.M = jnp.array(np.transpose(kwargs.get(\"M\")), dtype=self.precisionPolicy.compute_dtype)\n        self.s_0 = kwargs.get(\"s_0\")\n        self.s_1 = kwargs.get(\"s_1\")\n        self.s_b = kwargs.get(\"s_b\")\n        self.s_2 = kwargs.get(\"s_2\")\n        self.s_3 = kwargs.get(\"s_3\")\n        self.s_4 = kwargs.get(\"s_4\")\n        self.s_v = self.omega\n        if isinstance(self.lattice, LatticeD2Q9):\n            self.S = jnp.array(\n                np.diag([self.s_0, self.s_1, self.s_1, self.s_b, self.s_2, self.s_2, self.s_3, self.s_3, self.s_4]),\n                dtype=self.precisionPolicy.compute_dtype,\n            )\n        elif isinstance(self.lattice, LatticeD3Q19):\n            self.s_plus = (self.s_b + 2 * self.s_2) / 3\n            self.s_minus = (self.s_b - self.s_2) / 3\n\n            S = np.diag([\n                self.s_0,\n                self.s_1,\n                self.s_1,\n                self.s_1,\n                self.s_v,\n                self.s_v,\n                self.s_v,\n                self.s_plus,\n                self.s_plus,\n                self.s_plus,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_4,\n                self.s_4,\n                self.s_4,\n            ])\n            S[7, 8] = self.s_minus\n            S[7, 9] = self.s_minus\n            S[8, 7] = self.s_minus\n            S[8, 9] = self.s_minus\n            S[9, 7] = self.s_minus\n            S[9, 8] = self.s_minus\n            self.S = jnp.array(S, dtype=self.precisionPolicy.compute_dtype)\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n            self.s_plus = (self.s_b + 2 * self.s_2) / 3\n            self.s_minus = (self.s_b - self.s_2) / 3\n            self.s_3b = kwargs.get(\"s_3b\")\n            self.s_4b = kwargs.get(\"s_4b\")\n            self.s_5 = kwargs.get(\"s_5\")\n            self.s_6 = kwargs.get(\"s_6\")\n\n            S = np.diag([\n                self.s_0,\n                self.s_1,\n                self.s_1,\n                self.s_1,\n                self.s_v,\n                self.s_v,\n                self.s_v,\n                self.s_plus,\n                self.s_plus,\n                self.s_plus,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3,\n                self.s_3b,\n                self.s_4,\n                self.s_4,\n                self.s_4,\n                self.s_4b,\n                self.s_4b,\n                self.s_4b,\n                self.s_5,\n                self.s_5,\n                self.s_5,\n                self.s_6,\n            ])\n            S[7, 8] = self.s_minus\n            S[7, 9] = self.s_minus\n            S[8, 7] = self.s_minus\n            S[8, 9] = self.s_minus\n            S[9, 7] = self.s_minus\n            S[9, 8] = self.s_minus\n            self.S = jnp.array(S, dtype=self.precisionPolicy.compute_dtype)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def macroscopic_velocity(self, f, rho):\n        \"\"\"\n        macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models\n        and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.\n\n        Parameters\n        ----------\n        f: jax.numpy.ndarray\n            Distribution arrays.\n        rho: jax.numpy.ndarray\n            Density fields.\n\n        Returns\n        -------\n        u: jax.numpy.ndarray\n            Velocity fields.\n        \"\"\"\n        # rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        u = jnp.dot(f, c) / rho\n        if self.force is not None:\n            return u + 0.5 * self.force / rho\n        else:\n            return u\n\n    @partial(jit, static_argnums=(0,))\n    def compute_central_moment(self, m, u):\n        if isinstance(self.lattice, LatticeD2Q9):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                usq = ux**2 + uy**2\n                udiff = ux**2 - uy**2\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(-ux * m[..., 0] + m[..., 1])\n                T = T.at[..., 2].set(-uy * m[..., 0] + m[..., 2])\n                T = T.at[..., 3].set(usq * m[..., 0] - 2 * ux * m[..., 1] - 2 * uy * m[..., 2] + m[..., 3])\n                T = T.at[..., 4].set(udiff * m[..., 0] - 2 * ux * m[..., 1] + 2 * uy * m[..., 2] + m[..., 4])\n                T = T.at[..., 5].set(ux * uy * m[..., 0] - uy * m[..., 1] - ux * m[..., 2] + m[..., 5])\n                T = T.at[..., 6].set(\n                    -(ux**2) * uy * m[..., 0]\n                    + 2 * ux * uy * m[..., 1]\n                    + ux**2 * m[..., 2]\n                    - 0.5 * uy * m[..., 3]\n                    - 0.5 * uy * m[..., 4]\n                    - 2 * ux * m[..., 5]\n                    + m[..., 6]\n                )\n                T = T.at[..., 7].set(\n                    -(uy**2) * ux * m[..., 0]\n                    + uy**2 * m[..., 1]\n                    + 2 * ux * uy * m[..., 2]\n                    - 0.5 * ux * m[..., 3]\n                    + 0.5 * ux * m[..., 4]\n                    - 2 * uy * m[..., 5]\n                    + m[..., 7]\n                )\n                T = T.at[..., 8].set(\n                    (uy**2 * ux**2) * m[..., 0]\n                    - 2 * ux * uy**2 * m[..., 1]\n                    - 2 * uy * ux**2 * m[..., 2]\n                    + 0.5 * usq * m[..., 3]\n                    - 0.5 * udiff * m[..., 4]\n                    + 4 * ux * uy * m[..., 5]\n                    - 2 * uy * m[..., 6]\n                    - 2 * ux * m[..., 7]\n                    + m[..., 8]\n                )\n                return T\n\n            return shift(m, u)\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(-ux * m[..., 0] + m[..., 1])\n                T = T.at[..., 2].set(-uy * m[..., 0] + m[..., 2])\n                T = T.at[..., 3].set(-uz * m[..., 0] + m[..., 3])\n                T = T.at[..., 4].set(ux * uy * m[..., 0] - uy * m[..., 1] - ux * m[..., 2] + m[..., 4])\n                T = T.at[..., 5].set(ux * uz * m[..., 0] - uz * m[..., 1] - ux * m[..., 3] + m[..., 5])\n                T = T.at[..., 6].set(uy * uz * m[..., 0] - uz * m[..., 2] - uy * m[..., 3] + m[..., 6])\n                T = T.at[..., 7].set((ux**2) * m[..., 0] - 2 * ux * m[..., 1] + m[..., 7])\n                T = T.at[..., 8].set((uy**2) * m[..., 0] - 2 * uy * m[..., 2] + m[..., 8])\n                T = T.at[..., 9].set((uz**2) * m[..., 0] - 2 * uz * m[..., 3] + m[..., 9])\n                T = T.at[..., 10].set(\n                    -ux * (uy**2) * m[..., 0] + (uy**2) * m[..., 1] + 2 * ux * uy * m[..., 2] - 2 * uy * m[..., 4] - ux * m[..., 8] + m[..., 10]\n                )\n                T = T.at[..., 11].set(\n                    -ux * (uz**2) * m[..., 0] + (uz**2) * m[..., 1] + 2 * ux * uz * m[..., 3] - 2 * uz * m[..., 5] - ux * m[..., 9] + m[..., 11]\n                )\n                T = T.at[..., 12].set(\n                    -(ux**2) * uy * m[..., 0] + 2 * ux * uy * m[..., 1] + (ux**2) * m[..., 2] - 2 * ux * m[..., 4] - uy * m[..., 7] + m[..., 12]\n                )\n                T = T.at[..., 13].set(\n                    -(ux**2) * uz * m[..., 0] + 2 * ux * uz * m[..., 1] + (ux**2) * m[..., 3] - 2 * ux * m[..., 5] - uz * m[..., 7] + m[..., 13]\n                )\n                T = T.at[..., 14].set(\n                    -uy * (uz**2) * m[..., 0] + (uz**2) * m[..., 2] + 2 * uy * uz * m[..., 3] - 2 * uz * m[..., 6] - uy * m[..., 9] + m[..., 14]\n                )\n                T = T.at[..., 15].set(\n                    -(uy**2) * uz * m[..., 0] + 2 * uy * uz * m[..., 2] + (uy**2) * m[..., 3] - 2 * uy * m[..., 6] - uz * m[..., 8] + m[..., 15]\n                )\n                T = T.at[..., 16].set(\n                    (ux**2) * (uy**2) * m[..., 0]\n                    - 2 * ux * (uy**2) * m[..., 1]\n                    - 2 * uy * (ux**2) * m[..., 2]\n                    + 4 * ux * uy * m[..., 4]\n                    + (uy**2) * m[..., 7]\n                    + (ux**2) * m[..., 8]\n                    - 2 * ux * m[..., 10]\n                    - 2 * uy * m[..., 12]\n                    + m[..., 16]\n                )\n                T = T.at[..., 17].set(\n                    (ux**2) * (uz**2) * m[..., 0]\n                    - 2 * ux * (uz**2) * m[..., 1]\n                    - 2 * uz * (ux**2) * m[..., 3]\n                    + 4 * ux * uz * m[..., 5]\n                    + (uz**2) * m[..., 7]\n                    + (ux**2) * m[..., 9]\n                    - 2 * ux * m[..., 11]\n                    - 2 * uz * m[..., 13]\n                    + m[..., 17]\n                )\n                T = T.at[..., 18].set(\n                    (uy**2) * (uz**2) * m[..., 0]\n                    - 2 * uy * (uz**2) * m[..., 2]\n                    - 2 * uz * (uy**2) * m[..., 3]\n                    + 4 * uy * uz * m[..., 6]\n                    + (uz**2) * m[..., 8]\n                    + (uy**2) * m[..., 9]\n                    - 2 * uy * m[..., 14]\n                    - 2 * uz * m[..., 15]\n                    + m[..., 18]\n                )\n                return T\n\n            return shift(m, u)\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(m[..., 1] - m[..., 0] * ux)\n                T = T.at[..., 2].set(m[..., 2] - m[..., 0] * uy)\n                T = T.at[..., 3].set(m[..., 3] - m[..., 0] * uz)\n                T = T.at[..., 4].set(m[..., 4] - m[..., 2] * ux - m[..., 1] * uy + m[..., 0] * ux * uy)\n                T = T.at[..., 5].set(m[..., 5] - m[..., 3] * ux - m[..., 1] * uz + m[..., 0] * ux * uz)\n                T = T.at[..., 6].set(m[..., 6] - m[..., 3] * uy - m[..., 2] * uz + m[..., 0] * uy * uz)\n                T = T.at[..., 7].set(m[..., 0] * ux**2 - 2 * m[..., 1] * ux + m[..., 7])\n                T = T.at[..., 8].set(m[..., 0] * uy**2 - 2 * m[..., 2] * uy + m[..., 8])\n                T = T.at[..., 9].set(m[..., 0] * uz**2 - 2 * m[..., 3] * uz + m[..., 9])\n                T = T.at[..., 10].set(\n                    m[..., 10] - m[..., 8] * ux - 2 * m[..., 4] * uy + m[..., 1] * uy**2 - m[..., 0] * ux * uy**2 + 2 * m[..., 2] * ux * uy\n                )\n                T = T.at[..., 11].set(\n                    m[..., 11] - m[..., 9] * ux - 2 * m[..., 5] * uz + m[..., 1] * uz**2 - m[..., 0] * ux * uz**2 + 2 * m[..., 3] * ux * uz\n                )\n                T = T.at[..., 12].set(\n                    m[..., 12] - 2 * m[..., 4] * ux - m[..., 7] * uy + m[..., 2] * ux**2 - m[..., 0] * ux**2 * uy + 2 * m[..., 1] * ux * uy\n                )\n                T = T.at[..., 13].set(\n                    m[..., 13] - 2 * m[..., 5] * ux - m[..., 7] * uz + m[..., 3] * ux**2 - m[..., 0] * ux**2 * uz + 2 * m[..., 1] * ux * uz\n                )\n                T = T.at[..., 14].set(\n                    m[..., 14] - m[..., 9] * uy - 2 * m[..., 6] * uz + m[..., 2] * uz**2 - m[..., 0] * uy * uz**2 + 2 * m[..., 3] * uy * uz\n                )\n                T = T.at[..., 15].set(\n                    m[..., 15] - 2 * m[..., 6] * uy - m[..., 8] * uz + m[..., 3] * uy**2 - m[..., 0] * uy**2 * uz + 2 * m[..., 2] * uy * uz\n                )\n                T = T.at[..., 16].set(\n                    m[..., 16]\n                    - m[..., 6] * ux\n                    - m[..., 5] * uy\n                    - m[..., 4] * uz\n                    + m[..., 3] * ux * uy\n                    + m[..., 2] * ux * uz\n                    + m[..., 1] * uy * uz\n                    - m[..., 0] * ux * uy * uz\n                )\n                T = T.at[..., 17].set(\n                    m[..., 0] * ux**2 * uy**2\n                    - 2 * m[..., 2] * ux**2 * uy\n                    + m[..., 8] * ux**2\n                    - 2 * m[..., 1] * ux * uy**2\n                    + 4 * m[..., 4] * ux * uy\n                    - 2 * m[..., 10] * ux\n                    + m[..., 7] * uy**2\n                    - 2 * m[..., 12] * uy\n                    + m[..., 17]\n                )\n                T = T.at[..., 18].set(\n                    m[..., 0] * ux**2 * uz**2\n                    - 2 * m[..., 3] * ux**2 * uz\n                    + m[..., 9] * ux**2\n                    - 2 * m[..., 1] * ux * uz**2\n                    + 4 * m[..., 5] * ux * uz\n                    - 2 * m[..., 11] * ux\n                    + m[..., 7] * uz**2\n                    - 2 * m[..., 13] * uz\n                    + m[..., 18]\n                )\n                T = T.at[..., 19].set(\n                    m[..., 0] * uy**2 * uz**2\n                    - 2 * m[..., 3] * uy**2 * uz\n                    + m[..., 9] * uy**2\n                    - 2 * m[..., 2] * uy * uz**2\n                    + 4 * m[..., 6] * uy * uz\n                    - 2 * m[..., 14] * uy\n                    + m[..., 8] * uz**2\n                    - 2 * m[..., 15] * uz\n                    + m[..., 19]\n                )\n                T = T.at[..., 20].set(\n                    m[..., 20]\n                    - 2 * m[..., 16] * ux\n                    - m[..., 13] * uy\n                    - m[..., 12] * uz\n                    + m[..., 6] * ux**2\n                    - m[..., 3] * ux**2 * uy\n                    - m[..., 2] * ux**2 * uz\n                    + 2 * m[..., 5] * ux * uy\n                    + 2 * m[..., 4] * ux * uz\n                    + m[..., 7] * uy * uz\n                    - 2 * m[..., 1] * ux * uy * uz\n                    + m[..., 0] * ux**2 * uy * uz\n                )\n                T = T.at[..., 21].set(\n                    m[..., 21]\n                    - m[..., 15] * ux\n                    - 2 * m[..., 16] * uy\n                    - m[..., 10] * uz\n                    + m[..., 5] * uy**2\n                    - m[..., 3] * ux * uy**2\n                    - m[..., 1] * uy**2 * uz\n                    + 2 * m[..., 6] * ux * uy\n                    + m[..., 8] * ux * uz\n                    + 2 * m[..., 4] * uy * uz\n                    - 2 * m[..., 2] * ux * uy * uz\n                    + m[..., 0] * ux * uy**2 * uz\n                )\n                T = T.at[..., 22].set(\n                    m[..., 22]\n                    - m[..., 14] * ux\n                    - m[..., 11] * uy\n                    - 2 * m[..., 16] * uz\n                    + m[..., 4] * uz**2\n                    - m[..., 2] * ux * uz**2\n                    - m[..., 1] * uy * uz**2\n                    + m[..., 9] * ux * uy\n                    + 2 * m[..., 6] * ux * uz\n                    + 2 * m[..., 5] * uy * uz\n                    - 2 * m[..., 3] * ux * uy * uz\n                    + m[..., 0] * ux * uy * uz**2\n                )\n                T = T.at[..., 23].set(\n                    m[..., 23]\n                    - m[..., 19] * ux\n                    - 2 * m[..., 22] * uy\n                    - 2 * m[..., 21] * uz\n                    + m[..., 11] * uy**2\n                    + m[..., 10] * uz**2\n                    - m[..., 9] * ux * uy**2\n                    - m[..., 8] * ux * uz**2\n                    - 2 * m[..., 4] * uy * uz**2\n                    - 2 * m[..., 5] * uy**2 * uz\n                    + m[..., 1] * uy**2 * uz**2\n                    + 2 * m[..., 14] * ux * uy\n                    + 2 * m[..., 15] * ux * uz\n                    + 4 * m[..., 16] * uy * uz\n                    - 4 * m[..., 6] * ux * uy * uz\n                    + 2 * m[..., 2] * ux * uy * uz**2\n                    + 2 * m[..., 3] * ux * uy**2 * uz\n                    - m[..., 0] * ux * uy**2 * uz**2\n                )\n                T = T.at[..., 24].set(\n                    m[..., 24]\n                    - 2 * m[..., 22] * ux\n                    - m[..., 18] * uy\n                    - 2 * m[..., 20] * uz\n                    + m[..., 14] * ux**2\n                    + m[..., 12] * uz**2\n                    - m[..., 9] * ux**2 * uy\n                    - 2 * m[..., 4] * ux * uz**2\n                    - 2 * m[..., 6] * ux**2 * uz\n                    - m[..., 7] * uy * uz**2\n                    + m[..., 2] * ux**2 * uz**2\n                    + 2 * m[..., 11] * ux * uy\n                    + 4 * m[..., 16] * ux * uz\n                    + 2 * m[..., 13] * uy * uz\n                    - 4 * m[..., 5] * ux * uy * uz\n                    + 2 * m[..., 1] * ux * uy * uz**2\n                    + 2 * m[..., 3] * ux**2 * uy * uz\n                    - m[..., 0] * ux**2 * uy * uz**2\n                )\n                T = T.at[..., 25].set(\n                    m[..., 25]\n                    - 2 * m[..., 21] * ux\n                    - 2 * m[..., 20] * uy\n                    - m[..., 17] * uz\n                    + m[..., 15] * ux**2\n                    + m[..., 13] * uy**2\n                    - 2 * m[..., 5] * ux * uy**2\n                    - 2 * m[..., 6] * ux**2 * uy\n                    - m[..., 8] * ux**2 * uz\n                    - m[..., 7] * uy**2 * uz\n                    + m[..., 3] * ux**2 * uy**2\n                    + 4 * m[..., 16] * ux * uy\n                    + 2 * m[..., 10] * ux * uz\n                    + 2 * m[..., 12] * uy * uz\n                    - 4 * m[..., 4] * ux * uy * uz\n                    + 2 * m[..., 1] * ux * uy**2 * uz\n                    + 2 * m[..., 2] * ux**2 * uy * uz\n                    - m[..., 0] * ux**2 * uy**2 * uz\n                )\n                T = T.at[..., 26].set(\n                    m[..., 0] * ux**2 * uy**2 * uz**2\n                    - 2 * m[..., 3] * ux**2 * uy**2 * uz\n                    + m[..., 9] * ux**2 * uy**2\n                    - 2 * m[..., 2] * ux**2 * uy * uz**2\n                    + 4 * m[..., 6] * ux**2 * uy * uz\n                    - 2 * m[..., 14] * ux**2 * uy\n                    + m[..., 8] * ux**2 * uz**2\n                    - 2 * m[..., 15] * ux**2 * uz\n                    + m[..., 19] * ux**2\n                    - 2 * m[..., 1] * ux * uy**2 * uz**2\n                    + 4 * m[..., 5] * ux * uy**2 * uz\n                    - 2 * m[..., 11] * ux * uy**2\n                    + 4 * m[..., 4] * ux * uy * uz**2\n                    - 8 * m[..., 16] * ux * uy * uz\n                    + 4 * m[..., 22] * ux * uy\n                    - 2 * m[..., 10] * ux * uz**2\n                    + 4 * m[..., 21] * ux * uz\n                    - 2 * m[..., 23] * ux\n                    + m[..., 7] * uy**2 * uz**2\n                    - 2 * m[..., 13] * uy**2 * uz\n                    + m[..., 18] * uy**2\n                    - 2 * m[..., 12] * uy * uz**2\n                    + 4 * m[..., 20] * uy * uz\n                    - 2 * m[..., 24] * uy\n                    + m[..., 17] * uz**2\n                    - 2 * m[..., 25] * uz\n                    + m[..., 26]\n                )\n\n                return T\n\n            return shift(m, u)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_central_moment_inverse(self, T, u):\n        if isinstance(self.lattice, LatticeD2Q9):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                usq = ux**2 + uy**2\n                udiff = ux**2 - uy**2\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(ux * T[..., 0] + T[..., 1])\n                m = m.at[..., 2].set(uy * T[..., 0] + T[..., 2])\n                m = m.at[..., 3].set(usq * T[..., 0] + 2 * ux * T[..., 1] + 2 * uy * T[..., 2] + T[..., 3])\n                m = m.at[..., 4].set(udiff * T[..., 0] + 2 * ux * T[..., 1] - 2 * uy * T[..., 2] + T[..., 4])\n                m = m.at[..., 5].set(ux * uy * T[..., 0] + uy * T[..., 1] + ux * T[..., 2] + T[..., 5])\n                m = m.at[..., 6].set(\n                    (ux**2) * uy * T[..., 0]\n                    + 2 * ux * uy * T[..., 1]\n                    + ux**2 * T[..., 2]\n                    + 0.5 * uy * T[..., 3]\n                    + 0.5 * uy * T[..., 4]\n                    + 2 * ux * T[..., 5]\n                    + T[..., 6]\n                )\n                m = m.at[..., 7].set(\n                    (uy**2) * ux * T[..., 0]\n                    + uy**2 * T[..., 1]\n                    + 2 * ux * uy * T[..., 2]\n                    + 0.5 * ux * T[..., 3]\n                    - 0.5 * ux * T[..., 4]\n                    + 2 * uy * T[..., 5]\n                    + T[..., 7]\n                )\n                m = m.at[..., 8].set(\n                    (uy**2 * ux**2) * T[..., 0]\n                    + 2 * ux * uy**2 * T[..., 1]\n                    + 2 * uy * ux**2 * T[..., 2]\n                    + 0.5 * usq * T[..., 3]\n                    - 0.5 * udiff * T[..., 4]\n                    + 4 * ux * uy * T[..., 5]\n                    + 2 * uy * T[..., 6]\n                    + 2 * ux * T[..., 7]\n                    + T[..., 8]\n                )\n                return m\n\n            return shift_inverse(T, u)\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(ux * T[..., 0] + T[..., 1])\n                m = m.at[..., 2].set(uy * T[..., 0] + T[..., 2])\n                m = m.at[..., 3].set(uz * T[..., 0] + T[..., 3])\n                m = m.at[..., 4].set(ux * uy * T[..., 0] + uy * T[..., 1] + ux * T[..., 2] + T[..., 4])\n                m = m.at[..., 5].set(ux * uz * T[..., 0] + uz * T[..., 1] + ux * T[..., 3] + T[..., 5])\n                m = m.at[..., 6].set(uy * uz * T[..., 0] + uz * T[..., 2] + uy * T[..., 3] + T[..., 6])\n                m = m.at[..., 7].set((ux**2) * T[..., 0] + 2 * ux * T[..., 1] + T[..., 7])\n                m = m.at[..., 8].set((uy**2) * T[..., 0] + 2 * uy * T[..., 2] + T[..., 8])\n                m = m.at[..., 9].set((uz**2) * T[..., 0] + 2 * uz * T[..., 3] + T[..., 9])\n                m = m.at[..., 10].set(\n                    ux * (uy**2) * T[..., 0] + (uy**2) * T[..., 1] + 2 * ux * uy * T[..., 2] + 2 * uy * T[..., 4] + ux * T[..., 8] + T[..., 10]\n                )\n                m = m.at[..., 11].set(\n                    ux * (uz**2) * T[..., 0] + (uz**2) * T[..., 1] + 2 * ux * uz * T[..., 3] + 2 * uz * T[..., 5] + ux * T[..., 9] + T[..., 11]\n                )\n                m = m.at[..., 12].set(\n                    (ux**2) * uy * T[..., 0] + 2 * ux * uy * T[..., 1] + (ux**2) * T[..., 2] + 2 * ux * T[..., 4] + uy * T[..., 7] + T[..., 12]\n                )\n                m = m.at[..., 13].set(\n                    (ux**2) * uz * T[..., 0] + 2 * ux * uz * T[..., 1] + (ux**2) * T[..., 3] + 2 * ux * T[..., 5] + uz * T[..., 7] + T[..., 13]\n                )\n                m = m.at[..., 14].set(\n                    uy * (uz**2) * T[..., 0] + (uz**2) * T[..., 2] + 2 * uy * uz * T[..., 3] + 2 * uz * T[..., 6] + uy * T[..., 9] + T[..., 14]\n                )\n                m = m.at[..., 15].set(\n                    (uy**2) * uz * T[..., 0] + 2 * uy * uz * T[..., 2] + (uy**2) * T[..., 3] + 2 * uy * T[..., 6] + uz * T[..., 8] + T[..., 15]\n                )\n                m = m.at[..., 16].set(\n                    (ux**2) * (uy**2) * T[..., 0]\n                    + 2 * ux * (uy**2) * T[..., 1]\n                    + 2 * uy * (ux**2) * T[..., 2]\n                    + 4 * ux * uy * T[..., 4]\n                    + (uy**2) * T[..., 7]\n                    + (ux**2) * T[..., 8]\n                    + 2 * ux * T[..., 10]\n                    + 2 * uy * T[..., 12]\n                    + T[..., 16]\n                )\n                m = m.at[..., 17].set(\n                    (ux**2) * (uz**2) * T[..., 0]\n                    + 2 * ux * (uz**2) * T[..., 1]\n                    + 2 * uz * (ux**2) * T[..., 3]\n                    + 4 * ux * uz * T[..., 5]\n                    + (uz**2) * T[..., 7]\n                    + (ux**2) * T[..., 9]\n                    + 2 * ux * T[..., 11]\n                    + 2 * uz * T[..., 13]\n                    + T[..., 17]\n                )\n                m = m.at[..., 18].set(\n                    (uy**2) * (uz**2) * T[..., 0]\n                    + 2 * uy * (uz**2) * T[..., 2]\n                    + 2 * uz * (uy**2) * T[..., 3]\n                    + 4 * uy * uz * T[..., 6]\n                    + (uz**2) * T[..., 8]\n                    + (uy**2) * T[..., 9]\n                    + 2 * uy * T[..., 14]\n                    + 2 * uz * T[..., 15]\n                    + T[..., 18]\n                )\n                return m\n\n            return shift_inverse(T, u)\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(T[..., 1] + T[..., 0] * ux)\n                m = m.at[..., 2].set(T[..., 2] + T[..., 0] * uy)\n                m = m.at[..., 3].set(T[..., 3] + T[..., 0] * uz)\n                m = m.at[..., 4].set(T[..., 4] + T[..., 2] * ux + T[..., 1] * uy + T[..., 0] * ux * uy)\n                m = m.at[..., 5].set(T[..., 5] + T[..., 3] * ux + T[..., 1] * uz + T[..., 0] * ux * uz)\n                m = m.at[..., 6].set(T[..., 6] + T[..., 3] * uy + T[..., 2] * uz + T[..., 0] * uy * uz)\n                m = m.at[..., 7].set(T[..., 0] * ux**2 + 2 * T[..., 1] * ux + T[..., 7])\n                m = m.at[..., 8].set(T[..., 0] * uy**2 + 2 * T[..., 2] * uy + T[..., 8])\n                m = m.at[..., 9].set(T[..., 0] * uz**2 + 2 * T[..., 3] * uz + T[..., 9])\n                m = m.at[..., 10].set(\n                    T[..., 10] + T[..., 8] * ux + 2 * T[..., 4] * uy + T[..., 1] * uy**2 + T[..., 0] * ux * uy**2 + 2 * T[..., 2] * ux * uy\n                )\n                m = m.at[..., 11].set(\n                    T[..., 11] + T[..., 9] * ux + 2 * T[..., 5] * uz + T[..., 1] * uz**2 + T[..., 0] * ux * uz**2 + 2 * T[..., 3] * ux * uz\n                )\n                m = m.at[..., 12].set(\n                    T[..., 12] + 2 * T[..., 4] * ux + T[..., 7] * uy + T[..., 2] * ux**2 + T[..., 0] * ux**2 * uy + 2 * T[..., 1] * ux * uy\n                )\n                m = m.at[..., 13].set(\n                    T[..., 13] + 2 * T[..., 5] * ux + T[..., 7] * uz + T[..., 3] * ux**2 + T[..., 0] * ux**2 * uz + 2 * T[..., 1] * ux * uz\n                )\n                m = m.at[..., 14].set(\n                    T[..., 14] + T[..., 9] * uy + 2 * T[..., 6] * uz + T[..., 2] * uz**2 + T[..., 0] * uy * uz**2 + 2 * T[..., 3] * uy * uz\n                )\n                m = m.at[..., 15].set(\n                    T[..., 15] + 2 * T[..., 6] * uy + T[..., 8] * uz + T[..., 3] * uy**2 + T[..., 0] * uy**2 * uz + 2 * T[..., 2] * uy * uz\n                )\n                m = m.at[..., 16].set(\n                    T[..., 16]\n                    + T[..., 6] * ux\n                    + T[..., 5] * uy\n                    + T[..., 4] * uz\n                    + T[..., 3] * ux * uy\n                    + T[..., 2] * ux * uz\n                    + T[..., 1] * uy * uz\n                    + T[..., 0] * ux * uy * uz\n                )\n                m = m.at[..., 17].set(\n                    T[..., 0] * ux**2 * uy**2\n                    + 2 * T[..., 2] * ux**2 * uy\n                    + T[..., 8] * ux**2\n                    + 2 * T[..., 1] * ux * uy**2\n                    + 4 * T[..., 4] * ux * uy\n                    + 2 * T[..., 10] * ux\n                    + T[..., 7] * uy**2\n                    + 2 * T[..., 12] * uy\n                    + T[..., 17]\n                )\n                m = m.at[..., 18].set(\n                    T[..., 0] * ux**2 * uz**2\n                    + 2 * T[..., 3] * ux**2 * uz\n                    + T[..., 9] * ux**2\n                    + 2 * T[..., 1] * ux * uz**2\n                    + 4 * T[..., 5] * ux * uz\n                    + 2 * T[..., 11] * ux\n                    + T[..., 7] * uz**2\n                    + 2 * T[..., 13] * uz\n                    + T[..., 18]\n                )\n                m = m.at[..., 19].set(\n                    T[..., 0] * uy**2 * uz**2\n                    + 2 * T[..., 3] * uy**2 * uz\n                    + T[..., 9] * uy**2\n                    + 2 * T[..., 2] * uy * uz**2\n                    + 4 * T[..., 6] * uy * uz\n                    + 2 * T[..., 14] * uy\n                    + T[..., 8] * uz**2\n                    + 2 * T[..., 15] * uz\n                    + T[..., 19]\n                )\n                m = m.at[..., 20].set(\n                    T[..., 20]\n                    + 2 * T[..., 16] * ux\n                    + T[..., 13] * uy\n                    + T[..., 12] * uz\n                    + T[..., 6] * ux**2\n                    + T[..., 3] * ux**2 * uy\n                    + T[..., 2] * ux**2 * uz\n                    + 2 * T[..., 5] * ux * uy\n                    + 2 * T[..., 4] * ux * uz\n                    + T[..., 7] * uy * uz\n                    + 2 * T[..., 1] * ux * uy * uz\n                    + T[..., 0] * ux**2 * uy * uz\n                )\n                m = m.at[..., 21].set(\n                    T[..., 21]\n                    + T[..., 15] * ux\n                    + 2 * T[..., 16] * uy\n                    + T[..., 10] * uz\n                    + T[..., 5] * uy**2\n                    + T[..., 3] * ux * uy**2\n                    + T[..., 1] * uy**2 * uz\n                    + 2 * T[..., 6] * ux * uy\n                    + T[..., 8] * ux * uz\n                    + 2 * T[..., 4] * uy * uz\n                    + 2 * T[..., 2] * ux * uy * uz\n                    + T[..., 0] * ux * uy**2 * uz\n                )\n                m = m.at[..., 22].set(\n                    T[..., 22]\n                    + T[..., 14] * ux\n                    + T[..., 11] * uy\n                    + 2 * T[..., 16] * uz\n                    + T[..., 4] * uz**2\n                    + T[..., 2] * ux * uz**2\n                    + T[..., 1] * uy * uz**2\n                    + T[..., 9] * ux * uy\n                    + 2 * T[..., 6] * ux * uz\n                    + 2 * T[..., 5] * uy * uz\n                    + 2 * T[..., 3] * ux * uy * uz\n                    + T[..., 0] * ux * uy * uz**2\n                )\n                m = m.at[..., 23].set(\n                    T[..., 23]\n                    + T[..., 19] * ux\n                    + 2 * T[..., 22] * uy\n                    + 2 * T[..., 21] * uz\n                    + T[..., 11] * uy**2\n                    + T[..., 10] * uz**2\n                    + T[..., 9] * ux * uy**2\n                    + T[..., 8] * ux * uz**2\n                    + 2 * T[..., 4] * uy * uz**2\n                    + 2 * T[..., 5] * uy**2 * uz\n                    + T[..., 1] * uy**2 * uz**2\n                    + 2 * T[..., 14] * ux * uy\n                    + 2 * T[..., 15] * ux * uz\n                    + 4 * T[..., 16] * uy * uz\n                    + 4 * T[..., 6] * ux * uy * uz\n                    + 2 * T[..., 2] * ux * uy * uz**2\n                    + 2 * T[..., 3] * ux * uy**2 * uz\n                    + T[..., 0] * ux * uy**2 * uz**2\n                )\n                m = m.at[..., 24].set(\n                    T[..., 24]\n                    + 2 * T[..., 22] * ux\n                    + T[..., 18] * uy\n                    + 2 * T[..., 20] * uz\n                    + T[..., 14] * ux**2\n                    + T[..., 12] * uz**2\n                    + T[..., 9] * ux**2 * uy\n                    + 2 * T[..., 4] * ux * uz**2\n                    + 2 * T[..., 6] * ux**2 * uz\n                    + T[..., 7] * uy * uz**2\n                    + T[..., 2] * ux**2 * uz**2\n                    + 2 * T[..., 11] * ux * uy\n                    + 4 * T[..., 16] * ux * uz\n                    + 2 * T[..., 13] * uy * uz\n                    + 4 * T[..., 5] * ux * uy * uz\n                    + 2 * T[..., 1] * ux * uy * uz**2\n                    + 2 * T[..., 3] * ux**2 * uy * uz\n                    + T[..., 0] * ux**2 * uy * uz**2\n                )\n                m = m.at[..., 25].set(\n                    T[..., 25]\n                    + 2 * T[..., 21] * ux\n                    + 2 * T[..., 20] * uy\n                    + T[..., 17] * uz\n                    + T[..., 15] * ux**2\n                    + T[..., 13] * uy**2\n                    + 2 * T[..., 5] * ux * uy**2\n                    + 2 * T[..., 6] * ux**2 * uy\n                    + T[..., 8] * ux**2 * uz\n                    + T[..., 7] * uy**2 * uz\n                    + T[..., 3] * ux**2 * uy**2\n                    + 4 * T[..., 16] * ux * uy\n                    + 2 * T[..., 10] * ux * uz\n                    + 2 * T[..., 12] * uy * uz\n                    + 4 * T[..., 4] * ux * uy * uz\n                    + 2 * T[..., 1] * ux * uy**2 * uz\n                    + 2 * T[..., 2] * ux**2 * uy * uz\n                    + T[..., 0] * ux**2 * uy**2 * uz\n                )\n                m = m.at[..., 26].set(\n                    T[..., 0] * ux**2 * uy**2 * uz**2\n                    + 2 * T[..., 3] * ux**2 * uy**2 * uz\n                    + T[..., 9] * ux**2 * uy**2\n                    + 2 * T[..., 2] * ux**2 * uy * uz**2\n                    + 4 * T[..., 6] * ux**2 * uy * uz\n                    + 2 * T[..., 14] * ux**2 * uy\n                    + T[..., 8] * ux**2 * uz**2\n                    + 2 * T[..., 15] * ux**2 * uz\n                    + T[..., 19] * ux**2\n                    + 2 * T[..., 1] * ux * uy**2 * uz**2\n                    + 4 * T[..., 5] * ux * uy**2 * uz\n                    + 2 * T[..., 11] * ux * uy**2\n                    + 4 * T[..., 4] * ux * uy * uz**2\n                    + 8 * T[..., 16] * ux * uy * uz\n                    + 4 * T[..., 22] * ux * uy\n                    + 2 * T[..., 10] * ux * uz**2\n                    + 4 * T[..., 21] * ux * uz\n                    + 2 * T[..., 23] * ux\n                    + T[..., 7] * uy**2 * uz**2\n                    + 2 * T[..., 13] * uy**2 * uz\n                    + T[..., 18] * uy**2\n                    + 2 * T[..., 12] * uy * uz**2\n                    + 4 * T[..., 20] * uy * uz\n                    + 2 * T[..., 24] * uy\n                    + T[..., 17] * uz**2\n                    + 2 * T[..., 25] * uz\n                    + T[..., 26]\n                )\n                return m\n\n            return shift_inverse(T, u)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_eq_central_moments(self, rho):\n        \"\"\"\n        Calculate the central moments of the equilibrium distribution.\n\n        Parameters:\n        ----------\n        rho: jax.numpy.ndarray\n           Density field.\n\n        Returns:\n        -------\n        T_eq: jax.numpy.ndarray\n            central moment of the equilibrium distribution.\n        \"\"\"\n\n        if isinstance(self.lattice, LatticeD2Q9):\n            T_eq = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 3].set(2 * rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs**4)\n\n            return T_eq\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n            T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 16].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n\n            return T_eq\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n            T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 19].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 26].set(rho[..., 0] * self.lattice.cs**6)\n\n            return T_eq\n\n    @partial(jit, static_argnums=(0,))\n    def compute_force_central_moments(self, F):\n        \"\"\"\n        Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.\n\n        Parameters:\n        ----------\n        F: pytree of jax.numpy.ndarray\n            Force field.\n\n        Returns:\n        -------\n        T_eq: pytree of jax.numpy.ndarray\n            Central moments of the force distribution.\n        \"\"\"\n\n        if isinstance(self.lattice, LatticeD2Q9):\n            C = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 6].set(Fy * self.lattice.cs2)\n            C = C.at[..., 7].set(Fx * self.lattice.cs2)\n\n            return C\n        elif isinstance(self.lattice, LatticeD3Q19):\n            C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            Fz = F[..., 2]\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 3].set(Fz)\n            C = C.at[..., 10].set(Fx * self.lattice.cs2)\n            C = C.at[..., 11].set(Fx * self.lattice.cs2)\n            C = C.at[..., 12].set(Fy * self.lattice.cs2)\n            C = C.at[..., 13].set(Fz * self.lattice.cs2)\n            C = C.at[..., 14].set(Fy * self.lattice.cs2)\n            C = C.at[..., 15].set(Fz * self.lattice.cs2)\n\n            return C\n        elif isinstance(self.lattice, LatticeD3Q27):\n            C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            Fz = F[..., 2]\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 3].set(Fz)\n            C = C.at[..., 10].set(Fx * self.lattice.cs2)\n            C = C.at[..., 11].set(Fx * self.lattice.cs2)\n            C = C.at[..., 12].set(Fy * self.lattice.cs2)\n            C = C.at[..., 13].set(Fz * self.lattice.cs2)\n            C = C.at[..., 14].set(Fy * self.lattice.cs2)\n            C = C.at[..., 15].set(Fz * self.lattice.cs2)\n            C = C.at[..., 23].set(Fx * self.lattice.cs**4)\n            C = C.at[..., 24].set(Fy * self.lattice.cs**4)\n            C = C.at[..., 25].set(Fz * self.lattice.cs**4)\n\n            return C\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, Tdash, rho, u):\n        \"\"\"\n        Modified version of the apply_force defined in LBMBase to account for modified force.\n\n        Parameters\n        ----------\n            Tdash (jax.numpy.ndarray): Central moments post-collision distribution functions.\n            rho (jax.numpy.ndarray): Density field.\n            u (jax.numpy.ndarray): Velocity field.\n\n        Returns\n        -------\n            f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n        \"\"\"\n        F = self.get_force()\n        if F is None:\n            F = jnp.zeros_like(u)\n        C = self.compute_force_central_moments(F)\n        Tf = jnp.dot(C, jnp.eye(self.lattice.q) - 0.5 * self.S)\n        return Tdash + Tf\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin):\n        \"\"\"\n        Cascaded LBM collision step for lattice.\n        \"\"\"\n        fin = self.precisionPolicy.cast_to_compute(fin)\n        rho, _ = self.update_macroscopic(fin)\n        u = self.macroscopic_velocity(fin, rho)\n        T = jnp.dot(fin, self.M)\n        Tdash = self.compute_central_moment(T, u)\n        Tdash_eq = self.compute_eq_central_moments(rho)\n        Tout = jnp.dot(Tdash, jnp.eye(self.lattice.q) - self.S) + jnp.dot(Tdash_eq, self.S)\n        Tout = self.apply_force(Tout, rho, u)\n        Tout = self.compute_central_moment_inverse(Tout, u)\n        fout = jnp.dot(T, self.M_inv)\n        return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.BGKSim.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>BGK collision step for lattice.</p> <p>The collision step is where the main physics of the LBM is applied. In the BGK approximation, the distribution function is relaxed towards the equilibrium distribution function.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    BGK collision step for lattice.\n\n    The collision step is where the main physics of the LBM is applied. In the BGK approximation,\n    the distribution function is relaxed towards the equilibrium distribution function.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, cast_output=False)\n    fneq = f - feq\n    fout = f - self.omega * fneq\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>KBC collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    KBC collision step for lattice.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    tiny = 1e-32\n    beta = self.omega * 0.5\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, cast_output=False)\n    fneq = f - feq\n    if self.dim == 2:\n        deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n    else:\n        deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n    deltaH = fneq - deltaS\n    invBeta = 1.0 / beta\n    gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (\n        tiny + self.entropic_scalar_product(deltaH, deltaH, feq)\n    )\n\n    fout = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n\n    # add external force\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.collision_modified","title":"collision_modified","text":"<pre><code>collision_modified(f)\n</code></pre> <p>Alternative KBC collision step for lattice. Note: At low Reynolds number the orignal KBC collision above produces inaccurate results because it does not check for the entropy increase/decrease. The KBC stabalizations should only be applied in principle to cells whose entropy decrease after a regular BGK collision. This is the case in most cells at higher Reynolds numbers and hence a check may not be needed. Overall the following alternative collision is more reliable and may replace the original implementation. The issue at the moment is that it is about 60-80% slower than the above method.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision_modified(self, f):\n    \"\"\"\n    Alternative KBC collision step for lattice.\n    Note:\n    At low Reynolds number the orignal KBC collision above produces inaccurate results because\n    it does not check for the entropy increase/decrease. The KBC stabalizations should only be\n    applied in principle to cells whose entropy decrease after a regular BGK collision. This is\n    the case in most cells at higher Reynolds numbers and hence a check may not be needed.\n    Overall the following alternative collision is more reliable and may replace the original\n    implementation. The issue at the moment is that it is about 60-80% slower than the above method.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    tiny = 1e-32\n    beta = self.omega * 0.5\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u, castOutput=False)\n\n    # Alternative KBC: only stabalizes for voxels whose entropy decreases after BGK collision.\n    f_bgk = f - self.omega * (f - feq)\n    H_fin = jnp.sum(f * jnp.log(f / self.w), axis=-1, keepdims=True)\n    H_fout = jnp.sum(f_bgk * jnp.log(f_bgk / self.w), axis=-1, keepdims=True)\n\n    # the rest is identical to collision_deprecated\n    fneq = f - feq\n    if self.dim == 2:\n        deltaS = self.fdecompose_shear_d2q9(fneq) * rho / 4.0\n    else:\n        deltaS = self.fdecompose_shear_d3q27(fneq) * rho\n    deltaH = fneq - deltaS\n    invBeta = 1.0 / beta\n    gamma = invBeta - (2.0 - invBeta) * self.entropic_scalar_product(deltaS, deltaH, feq) / (\n        tiny + self.entropic_scalar_product(deltaH, deltaH, feq)\n    )\n\n    f_kbc = f - beta * (2.0 * deltaS + gamma[..., None] * deltaH)\n    fout = jnp.where(H_fout &gt; H_fin, f_kbc, f_bgk)\n\n    # add external force\n    if self.force is not None:\n        fout = self.apply_force(fout, feq, rho, u)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.KBCSim.entropic_scalar_product","title":"entropic_scalar_product","text":"<pre><code>entropic_scalar_product(x, y, feq)\n</code></pre> <p>Compute the entropic scalar product of x and y to approximate gamma in KBC.</p>"},{"location":"models/#src.models.KBCSim.entropic_scalar_product--returns","title":"Returns","text":"<p>jax.numpy.array     Entropic scalar product of x, y, and feq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef entropic_scalar_product(self, x, y, feq):\n    \"\"\"\n    Compute the entropic scalar product of x and y to approximate gamma in KBC.\n\n    Returns\n    -------\n    jax.numpy.array\n        Entropic scalar product of x, y, and feq.\n    \"\"\"\n    return jnp.sum(x * y / feq, axis=-1)\n</code></pre>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9","title":"fdecompose_shear_d2q9","text":"<pre><code>fdecompose_shear_d2q9(fneq)\n</code></pre> <p>Decompose fneq into shear components for D2Q9 lattice.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.array     Non-equilibrium distribution function.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d2q9--returns","title":"Returns","text":"<p>jax.numpy.array     Shear components of fneq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef fdecompose_shear_d2q9(self, fneq):\n    \"\"\"\n    Decompose fneq into shear components for D2Q9 lattice.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.array\n        Non-equilibrium distribution function.\n\n    Returns\n    -------\n    jax.numpy.array\n        Shear components of fneq.\n    \"\"\"\n    Pi = self.momentum_flux(fneq)\n    N = Pi[..., 0] - Pi[..., 2]\n    s = jnp.zeros_like(fneq)\n    s = s.at[..., 6].set(N)\n    s = s.at[..., 3].set(N)\n    s = s.at[..., 2].set(-N)\n    s = s.at[..., 1].set(-N)\n    s = s.at[..., 8].set(Pi[..., 1])\n    s = s.at[..., 4].set(-Pi[..., 1])\n    s = s.at[..., 5].set(-Pi[..., 1])\n    s = s.at[..., 7].set(Pi[..., 1])\n\n    return s\n</code></pre>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27","title":"fdecompose_shear_d3q27","text":"<pre><code>fdecompose_shear_d3q27(fneq)\n</code></pre> <p>Decompose fneq into shear components for D3Q27 lattice.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27--parameters","title":"Parameters","text":"<p>fneq : jax.numpy.ndarray     Non-equilibrium distribution function.</p>"},{"location":"models/#src.models.KBCSim.fdecompose_shear_d3q27--returns","title":"Returns","text":"<p>jax.numpy.ndarray     Shear components of fneq.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef fdecompose_shear_d3q27(self, fneq):\n    \"\"\"\n    Decompose fneq into shear components for D3Q27 lattice.\n\n    Parameters\n    ----------\n    fneq : jax.numpy.ndarray\n        Non-equilibrium distribution function.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        Shear components of fneq.\n    \"\"\"\n    # if self.grid.dim == 3:\n    #     diagonal    = (0, 3, 5)\n    #     offdiagonal = (1, 2, 4)\n    # elif self.grid.dim == 2:\n    #     diagonal    = (0, 2)\n    #     offdiagonal = (1,)\n\n    # c=\n    # array([[0, 0, 0],-----0\n    #        [0, 0, -1],----1\n    #        [0, 0, 1],-----2\n    #        [0, -1, 0],----3\n    #        [0, -1, -1],---4\n    #        [0, -1, 1],----5\n    #        [0, 1, 0],-----6\n    #        [0, 1, -1],----7\n    #        [0, 1, 1],-----8\n    #        [-1, 0, 0],----9\n    #        [-1, 0, -1],--10\n    #        [-1, 0, 1],---11\n    #        [-1, -1, 0],--12\n    #        [-1, -1, -1],-13\n    #        [-1, -1, 1],--14\n    #        [-1, 1, 0],---15\n    #        [-1, 1, -1],--16\n    #        [-1, 1, 1],---17\n    #        [1, 0, 0],----18\n    #        [1, 0, -1],---19\n    #        [1, 0, 1],----20\n    #        [1, -1, 0],---21\n    #        [1, -1, -1],--22\n    #        [1, -1, 1],---23\n    #        [1, 1, 0],----24\n    #        [1, 1, -1],---25\n    #        [1, 1, 1]])---26\n    Pi = self.momentum_flux(fneq)\n    Nxz = Pi[..., 0] - Pi[..., 5]\n    Nyz = Pi[..., 3] - Pi[..., 5]\n\n    # For c = (i, 0, 0), c = (0, j, 0) and c = (0, 0, k)\n    s = jnp.zeros_like(fneq)\n    s = s.at[..., 9].set((2.0 * Nxz - Nyz) / 6.0)\n    s = s.at[..., 18].set((2.0 * Nxz - Nyz) / 6.0)\n    s = s.at[..., 3].set((-Nxz + 2.0 * Nyz) / 6.0)\n    s = s.at[..., 6].set((-Nxz + 2.0 * Nyz) / 6.0)\n    s = s.at[..., 1].set((-Nxz - Nyz) / 6.0)\n    s = s.at[..., 2].set((-Nxz - Nyz) / 6.0)\n\n    # For c = (i, j, 0)\n    s = s.at[..., 12].set(Pi[..., 1] / 4.0)\n    s = s.at[..., 24].set(Pi[..., 1] / 4.0)\n    s = s.at[..., 21].set(-Pi[..., 1] / 4.0)\n    s = s.at[..., 15].set(-Pi[..., 1] / 4.0)\n\n    # For c = (i, 0, k)\n    s = s.at[..., 10].set(Pi[..., 2] / 4.0)\n    s = s.at[..., 20].set(Pi[..., 2] / 4.0)\n    s = s.at[..., 19].set(-Pi[..., 2] / 4.0)\n    s = s.at[..., 11].set(-Pi[..., 2] / 4.0)\n\n    # For c = (0, j, k)\n    s = s.at[..., 8].set(Pi[..., 4] / 4.0)\n    s = s.at[..., 4].set(Pi[..., 4] / 4.0)\n    s = s.at[..., 7].set(-Pi[..., 4] / 4.0)\n    s = s.at[..., 5].set(-Pi[..., 4] / 4.0)\n\n    return s\n</code></pre>"},{"location":"models/#src.models.AdvectionDiffusionBGK.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>BGK collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    BGK collision step for lattice.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    rho = jnp.sum(f, axis=-1, keepdims=True)\n    feq = self.equilibrium(rho, self.vel, cast_output=False)\n    fneq = f - feq\n    fout = f - self.omega * fneq\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.MRTSim.collision","title":"collision","text":"<pre><code>collision(f)\n</code></pre> <p>MRT collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, f):\n    \"\"\"\n    MRT collision step for lattice.\n    \"\"\"\n    f = self.precisionPolicy.cast_to_compute(f)\n    m = jnp.dot(f, self.M)\n    rho, u = self.update_macroscopic(f)\n    feq = self.equilibrium(rho, u)\n    meq = jnp.dot(feq, self.M)\n    mout = -jnp.dot(m - meq, self.S)\n    if self.force is not None:\n        mout = self.apply_force(mout, meq, rho, u)\n    return self.precisionPolicy.cast_to_output(f + jnp.dot(mout, self.M_inv))\n</code></pre>"},{"location":"models/#src.models.CLBMSim.apply_force","title":"apply_force","text":"<pre><code>apply_force(Tdash, rho, u)\n</code></pre> <p>Modified version of the apply_force defined in LBMBase to account for modified force.</p>"},{"location":"models/#src.models.CLBMSim.apply_force--parameters","title":"Parameters","text":"<pre><code>Tdash (jax.numpy.ndarray): Central moments post-collision distribution functions.\nrho (jax.numpy.ndarray): Density field.\nu (jax.numpy.ndarray): Velocity field.\n</code></pre>"},{"location":"models/#src.models.CLBMSim.apply_force--returns","title":"Returns","text":"<pre><code>f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n</code></pre> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, Tdash, rho, u):\n    \"\"\"\n    Modified version of the apply_force defined in LBMBase to account for modified force.\n\n    Parameters\n    ----------\n        Tdash (jax.numpy.ndarray): Central moments post-collision distribution functions.\n        rho (jax.numpy.ndarray): Density field.\n        u (jax.numpy.ndarray): Velocity field.\n\n    Returns\n    -------\n        f_postcollision (jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n    \"\"\"\n    F = self.get_force()\n    if F is None:\n        F = jnp.zeros_like(u)\n    C = self.compute_force_central_moments(F)\n    Tf = jnp.dot(C, jnp.eye(self.lattice.q) - 0.5 * self.S)\n    return Tdash + Tf\n</code></pre>"},{"location":"models/#src.models.CLBMSim.collision","title":"collision","text":"<pre><code>collision(fin)\n</code></pre> <p>Cascaded LBM collision step for lattice.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin):\n    \"\"\"\n    Cascaded LBM collision step for lattice.\n    \"\"\"\n    fin = self.precisionPolicy.cast_to_compute(fin)\n    rho, _ = self.update_macroscopic(fin)\n    u = self.macroscopic_velocity(fin, rho)\n    T = jnp.dot(fin, self.M)\n    Tdash = self.compute_central_moment(T, u)\n    Tdash_eq = self.compute_eq_central_moments(rho)\n    Tout = jnp.dot(Tdash, jnp.eye(self.lattice.q) - self.S) + jnp.dot(Tdash_eq, self.S)\n    Tout = self.apply_force(Tout, rho, u)\n    Tout = self.compute_central_moment_inverse(Tout, u)\n    fout = jnp.dot(T, self.M_inv)\n    return self.precisionPolicy.cast_to_output(fout)\n</code></pre>"},{"location":"models/#src.models.CLBMSim.compute_eq_central_moments","title":"compute_eq_central_moments","text":"<pre><code>compute_eq_central_moments(rho)\n</code></pre> <p>Calculate the central moments of the equilibrium distribution.</p>"},{"location":"models/#src.models.CLBMSim.compute_eq_central_moments--parameters","title":"Parameters:","text":"<p>rho: jax.numpy.ndarray    Density field.</p>"},{"location":"models/#src.models.CLBMSim.compute_eq_central_moments--returns","title":"Returns:","text":"<p>T_eq: jax.numpy.ndarray     central moment of the equilibrium distribution.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_eq_central_moments(self, rho):\n    \"\"\"\n    Calculate the central moments of the equilibrium distribution.\n\n    Parameters:\n    ----------\n    rho: jax.numpy.ndarray\n       Density field.\n\n    Returns:\n    -------\n    T_eq: jax.numpy.ndarray\n        central moment of the equilibrium distribution.\n    \"\"\"\n\n    if isinstance(self.lattice, LatticeD2Q9):\n        T_eq = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        T_eq = T_eq.at[..., 0].set(rho[..., 0])\n        T_eq = T_eq.at[..., 3].set(2 * rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs**4)\n\n        return T_eq\n\n    elif isinstance(self.lattice, LatticeD3Q19):\n        T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        T_eq = T_eq.at[..., 0].set(rho[..., 0])\n        T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 16].set(rho[..., 0] * self.lattice.cs**4)\n        T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n        T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n\n        return T_eq\n\n    elif isinstance(self.lattice, LatticeD3Q27):\n        T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        T_eq = T_eq.at[..., 0].set(rho[..., 0])\n        T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n        T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n        T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n        T_eq = T_eq.at[..., 19].set(rho[..., 0] * self.lattice.cs**4)\n        T_eq = T_eq.at[..., 26].set(rho[..., 0] * self.lattice.cs**6)\n\n        return T_eq\n</code></pre>"},{"location":"models/#src.models.CLBMSim.compute_force_central_moments","title":"compute_force_central_moments","text":"<pre><code>compute_force_central_moments(F)\n</code></pre> <p>Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.</p>"},{"location":"models/#src.models.CLBMSim.compute_force_central_moments--parameters","title":"Parameters:","text":"<p>F: pytree of jax.numpy.ndarray     Force field.</p>"},{"location":"models/#src.models.CLBMSim.compute_force_central_moments--returns","title":"Returns:","text":"<p>T_eq: pytree of jax.numpy.ndarray     Central moments of the force distribution.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_force_central_moments(self, F):\n    \"\"\"\n    Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.\n\n    Parameters:\n    ----------\n    F: pytree of jax.numpy.ndarray\n        Force field.\n\n    Returns:\n    -------\n    T_eq: pytree of jax.numpy.ndarray\n        Central moments of the force distribution.\n    \"\"\"\n\n    if isinstance(self.lattice, LatticeD2Q9):\n        C = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        Fx = F[..., 0]\n        Fy = F[..., 1]\n        C = C.at[..., 1].set(Fx)\n        C = C.at[..., 2].set(Fy)\n        C = C.at[..., 6].set(Fy * self.lattice.cs2)\n        C = C.at[..., 7].set(Fx * self.lattice.cs2)\n\n        return C\n    elif isinstance(self.lattice, LatticeD3Q19):\n        C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        Fx = F[..., 0]\n        Fy = F[..., 1]\n        Fz = F[..., 2]\n        C = C.at[..., 1].set(Fx)\n        C = C.at[..., 2].set(Fy)\n        C = C.at[..., 3].set(Fz)\n        C = C.at[..., 10].set(Fx * self.lattice.cs2)\n        C = C.at[..., 11].set(Fx * self.lattice.cs2)\n        C = C.at[..., 12].set(Fy * self.lattice.cs2)\n        C = C.at[..., 13].set(Fz * self.lattice.cs2)\n        C = C.at[..., 14].set(Fy * self.lattice.cs2)\n        C = C.at[..., 15].set(Fz * self.lattice.cs2)\n\n        return C\n    elif isinstance(self.lattice, LatticeD3Q27):\n        C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n        Fx = F[..., 0]\n        Fy = F[..., 1]\n        Fz = F[..., 2]\n        C = C.at[..., 1].set(Fx)\n        C = C.at[..., 2].set(Fy)\n        C = C.at[..., 3].set(Fz)\n        C = C.at[..., 10].set(Fx * self.lattice.cs2)\n        C = C.at[..., 11].set(Fx * self.lattice.cs2)\n        C = C.at[..., 12].set(Fy * self.lattice.cs2)\n        C = C.at[..., 13].set(Fz * self.lattice.cs2)\n        C = C.at[..., 14].set(Fy * self.lattice.cs2)\n        C = C.at[..., 15].set(Fz * self.lattice.cs2)\n        C = C.at[..., 23].set(Fx * self.lattice.cs**4)\n        C = C.at[..., 24].set(Fy * self.lattice.cs**4)\n        C = C.at[..., 25].set(Fz * self.lattice.cs**4)\n\n        return C\n</code></pre>"},{"location":"models/#src.models.CLBMSim.macroscopic_velocity","title":"macroscopic_velocity","text":"<pre><code>macroscopic_velocity(f, rho)\n</code></pre> <p>macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.</p>"},{"location":"models/#src.models.CLBMSim.macroscopic_velocity--parameters","title":"Parameters","text":"<p>f: jax.numpy.ndarray     Distribution arrays. rho: jax.numpy.ndarray     Density fields.</p>"},{"location":"models/#src.models.CLBMSim.macroscopic_velocity--returns","title":"Returns","text":"<p>u: jax.numpy.ndarray     Velocity fields.</p> Source code in <code>src/models.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef macroscopic_velocity(self, f, rho):\n    \"\"\"\n    macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models\n    and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.\n\n    Parameters\n    ----------\n    f: jax.numpy.ndarray\n        Distribution arrays.\n    rho: jax.numpy.ndarray\n        Density fields.\n\n    Returns\n    -------\n    u: jax.numpy.ndarray\n        Velocity fields.\n    \"\"\"\n    # rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    u = jnp.dot(f, c) / rho\n    if self.force is not None:\n        return u + 0.5 * self.force / rho\n    else:\n        return u\n</code></pre>"},{"location":"multiphase/","title":"JAX-LaB multiphase","text":"<p>               Bases: <code>LBMBase</code></p> <p>Multiphase model, based on the Shan-Chen method. To model the fluid, an equation of state (EOS) is defined by the user. Sequence of computation is pressure (EOS, dependent on the density and temperature) \u2013&gt; effective mass (phi). Can model both single component multiphase (SCMP) and multi-component multiphase (MCMP).</p> <p>               Bases: <code>Multiphase</code></p> Source code in <code>src/multiphase.py</code> <pre><code>class MultiphaseBGK(Multiphase):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin_tree):\n        \"\"\"\n        BGK collision step for lattice, extended to pytrees.\n\n        The collision step is where the main physics of the LBM is applied. In the BGK approximation,\n        the distribution function is relaxed towards the equilibrium distribution function.\n        \"\"\"\n        fin_tree = map(lambda fin: self.precisionPolicy.cast_to_compute(fin), fin_tree)\n        rho_tree, u_tree = self.update_macroscopic(fin_tree)\n        feq_tree = self.equilibrium(rho_tree, u_tree, cast_output=False)\n        fneq_tree = map(lambda feq, fin: feq - fin, feq_tree, fin_tree)\n        fout_tree = map(lambda fin, fneq, omega: fin + omega * fneq, fin_tree, fneq_tree, self.omega)\n\n        fout_tree = self.apply_force(fout_tree, feq_tree, rho_tree, u_tree)\n\n        return map(lambda fout: self.precisionPolicy.cast_to_output(fout), fout_tree)\n</code></pre> <p>               Bases: <code>Multiphase</code></p> Source code in <code>src/multiphase.py</code> <pre><code>class MultiphaseMRT(Multiphase):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.kappa = kwargs.get(\"kappa\")\n        self.s_rho = kwargs.get(\"s_rho\")\n        self.s_e = kwargs.get(\"s_e\")\n        self.s_eta = kwargs.get(\"s_eta\")\n        self.s_j = kwargs.get(\"s_j\")\n        self.s_q = kwargs.get(\"s_q\")\n        self.s_v = kwargs.get(\"s_v\")\n        self.M_inv = map(\n            lambda M: jnp.array(\n                np.linalg.inv(M).T,\n                dtype=self.precisionPolicy.compute_dtype,\n            ),\n            kwargs.get(\"M\"),\n        )\n        self.M = map(\n            lambda M: jnp.array(M.T, dtype=self.precisionPolicy.compute_dtype),\n            kwargs.get(\"M\"),\n        )\n        if isinstance(self.lattice, LatticeD2Q9):\n            self.S = map(\n                lambda s_rho, s_e, s_eta, s_j, s_q, s_v: jnp.array(\n                    np.diag([s_rho, s_e, s_eta, s_j, s_q, s_j, s_q, s_v, s_v]),\n                    dtype=self.precisionPolicy.compute_dtype,\n                ),\n                self.s_rho,\n                self.s_e,\n                self.s_eta,\n                self.s_j,\n                self.s_q,\n                self.s_v,\n            )\n        elif isinstance(self.lattice, LatticeD3Q19):\n            self.s_pi = kwargs.get(\"s_pi\")\n            self.s_m = kwargs.get(\"s_m\")\n            self.S = map(\n                lambda s_rho, s_e, s_eta, s_j, s_q, s_v, s_pi, s_m: jnp.array(\n                    np.diag([\n                        s_rho,\n                        s_e,\n                        s_eta,\n                        s_j,\n                        s_q,\n                        s_j,\n                        s_q,\n                        s_j,\n                        s_q,\n                        s_v,\n                        s_pi,\n                        s_v,\n                        s_pi,\n                        s_v,\n                        s_v,\n                        s_v,\n                        s_m,\n                        s_m,\n                        s_m,\n                    ]),\n                    dtype=self.precisionPolicy.compute_dtype,\n                ),\n                self.s_rho,\n                self.s_e,\n                self.s_eta,\n                self.s_j,\n                self.s_q,\n                self.s_v,\n                self.s_pi,\n                self.s_m,\n            )\n\n    @property\n    def omega(self):\n        return self._omega\n\n    @omega.setter\n    def omega(self, value=None):\n        self._omega = value\n\n    @property\n    def M(self):\n        return self._M\n\n    @M.setter\n    def M(self, value):\n        if not isinstance(value, list):\n            raise ValueError(\"Matrix M must be a list\")\n        if len(value) != self.n_components:\n            raise ValueError(\"Number of components does not match number of matrix M passed\")\n        self._M = value\n\n    @partial(jit, static_argnums=(0,))\n    def adjust_surface_tension(self, psi_tree):\n        psi_s_tree = map(lambda psi: self.streaming(jnp.repeat(psi, axis=-1, repeats=self.q)), psi_tree)\n        c = jnp.transpose(self.c)\n        if isinstance(self.lattice, LatticeD2Q9):\n            tm1 = lambda i, j, psi, psi_s: psi[..., 0] * jnp.dot(self.G_ff * (psi_s - psi), c[:, i] * c[:, j])\n            tm2 = lambda i, j, psi, psi_s: jnp.dot(self.G_ff * (psi_s**2 - psi**2), c[:, i] * c[:, j])\n\n            def compute_C(kappa, A, s_v, s_e, s_eta, psi, psi_s):\n                C = jnp.zeros_like(\n                    psi_s,\n                    dtype=self.precisionPolicy.compute_dtype,\n                )\n                qxx = -kappa * ((1 - A) * tm1(0, 0, psi, psi_s) + 0.5 * A * tm2(0, 0, psi, psi_s))\n                qxy = -kappa * ((1 - A) * tm1(0, 1, psi, psi_s) + 0.5 * A * tm2(0, 1, psi, psi_s))\n                qyy = -kappa * ((1 - A) * tm1(1, 1, psi, psi_s) + 0.5 * A * tm2(1, 1, psi, psi_s))\n                C = C.at[..., 1].set(1.5 * s_e * (qxx + qyy))\n                C = C.at[..., 2].set(-1.5 * s_eta * (qxx + qyy))\n                C = C.at[..., 7].set(-s_v * (qxx - qyy))\n                C = C.at[..., 8].set(-s_v * qxy)\n                return C\n\n            C_tree = map(\n                lambda kappa, A, s_v, s_e, s_eta, psi, psi_s: compute_C(kappa, A, s_v, s_e, s_eta, psi, psi_s),\n                self.kappa,\n                list(self.A.diagonal()),\n                self.s_v,\n                self.s_e,\n                self.s_eta,\n                psi_tree,\n                psi_s_tree,\n            )\n            return C_tree\n        elif isinstance(self.lattice, LatticeD3Q19):\n            tm1 = lambda i, j, psi, psi_s: psi[..., 0] * jnp.dot(self.G_ff * (psi_s - psi), c[:, i] * c[:, j])\n            tm2 = lambda i, j, psi, psi_s: jnp.dot(self.G_ff * (psi_s**2 - psi**2), c[:, i] * c[:, j])\n\n            def compute_C(kappa, A, s_v, s_e, s_eta, psi, psi_s):\n                C = jnp.zeros_like(\n                    psi_s,\n                    dtype=self.precisionPolicy.compute_dtype,\n                )\n                qxx = -kappa * ((1 - A) * tm1(0, 0, psi, psi_s) + 0.5 * A * tm2(0, 0, psi, psi_s))\n                qxy = -kappa * ((1 - A) * tm1(0, 1, psi, psi_s) + 0.5 * A * tm2(0, 1, psi, psi_s))\n                qxz = -kappa * ((1 - A) * tm1(0, 2, psi, psi_s) + 0.5 * A * tm2(0, 2, psi, psi_s))\n                qyy = -kappa * ((1 - A) * tm1(1, 1, psi, psi_s) + 0.5 * A * tm2(1, 1, psi, psi_s))\n                qyz = -kappa * ((1 - A) * tm1(1, 2, psi, psi_s) + 0.5 * A * tm2(1, 2, psi, psi_s))\n                qzz = -kappa * ((1 - A) * tm1(2, 2, psi, psi_s) + 0.5 * A * tm2(2, 2, psi, psi_s))\n                C = C.at[..., 1].set((2 / 5) * s_e * (qxx + qyy + qzz))\n                C = C.at[..., 9].set(-s_v * (2 * qxx - qyy - qzz))\n                C = C.at[..., 11].set(-s_v * (qyy - qzz))\n                C = C.at[..., 13].set(-s_v * qxy)\n                C = C.at[..., 14].set(-s_v * qyz)\n                C = C.at[..., 15].set(-s_v * qxz)\n                return C\n\n            C_tree = map(\n                lambda kappa, A, s_v, s_e, s_eta, psi, psi_s: compute_C(kappa, A, s_v, s_e, s_eta, psi, psi_s),\n                self.kappa,\n                list(self.A.diagonal()),\n                self.s_v,\n                self.s_e,\n                self.s_eta,\n                psi_tree,\n                psi_s_tree,\n            )\n            return C_tree\n        else:\n            raise NotImplementedError(\"MRT model with D3Q27 model has not been implemented\")\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, m_tree, meq_tree, rho_tree, u_tree):\n        \"\"\"\n        Modified version of the apply_force defined in LBMBase to account for modified force.\n\n        Parameters\n        ----------\n        m_tree (pytree of jax.numpy.ndarray): Post-collision distribution function.\n\n        meq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution function.\n\n        rho_tree (pytree of jax.numpy.ndarray): Density field for all components.\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field for all components.\n\n        Returns\n        -------\n        f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n        \"\"\"\n        F_tree = self.compute_force(rho_tree)\n\n        delta_u_tree = map(lambda F, rho: F / rho, F_tree, rho_tree)\n        u_temp_tree = map(lambda u, delta_u: u + delta_u, u_tree, delta_u_tree)\n        feq_force_tree = self.equilibrium(rho_tree, u_temp_tree, cast_output=False)\n        meq_force_tree = map(lambda feq, M: jnp.dot(feq, M), feq_force_tree, self.M)\n        return map(\n            lambda m, meq_force, meq: m + meq_force - meq,\n            m_tree,\n            meq_force_tree,\n            meq_tree,\n        )\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin_tree):\n        \"\"\"\n        MRT collision step for lattice.\n        \"\"\"\n        fin_tree = map(lambda f: self.precisionPolicy.cast_to_compute(f), fin_tree)\n        rho_tree, u_tree = self.update_macroscopic(fin_tree)\n        m_tree = map(lambda f, M: jnp.dot(f, M), fin_tree, self.M)\n        feq_tree = self.equilibrium(rho_tree, u_tree, cast_output=False)\n        meq_tree = map(lambda feq, M: jnp.dot(feq, M), feq_tree, self.M)\n        psi_tree, _ = self.compute_potential(rho_tree)\n        C_tree = self.adjust_surface_tension(psi_tree)\n        mout_tree = map(\n            lambda m, meq, S: m - jnp.dot(m - meq, S),\n            m_tree,\n            meq_tree,\n            self.S,\n        )\n        mout_tree = self.apply_force(mout_tree, meq_tree, rho_tree, u_tree)\n        fout_tree = map(lambda m, Minv, C: jnp.dot(m + C, Minv), mout_tree, self.M_inv, C_tree)\n        # fout_tree = self.apply_force(fout_tree, feq_tree, rho_tree, u_tree)\n        return map(\n            lambda fout: self.precisionPolicy.cast_to_output(fout),\n            fout_tree,\n        )\n</code></pre> <p>               Bases: <code>Multiphase</code></p> <p>Cascaded LBM collision model transforms the distribution to central moments and then relaxation them. The central moments are obtained by first transforming distributions to raw-moment using transformation matrix similar to MRT model. The raw-moments are subsequently transformed to central moments using shift-matrix. CLBM gives independent control over vapor diffusivity, binary diffusivity and Schmidt number, which is not possible using SRT model.</p> <p>The current implementation is based on: 1. Fei, L. &amp; Luo, K. H. Consistent forcing scheme in the cascaded lattice Boltzmann method. Phys. Rev. E 96, 053307 (2017).</p> <ol> <li>Fei, L., Luo, K. H. &amp; Li, Q. Three-dimensional cascaded lattice Boltzmann method: Improved implementation and consistent forcing scheme. Phys. Rev. E 97, 053309 (2018).</li> </ol> Source code in <code>src/multiphase.py</code> <pre><code>class MultiphaseCascade(Multiphase):\n    \"\"\"\n    Cascaded LBM collision model transforms the distribution to central moments and then relaxation them. The central moments are obtained by first\n    transforming distributions to raw-moment using transformation matrix similar to MRT model. The raw-moments are subsequently transformed to central\n    moments using shift-matrix. CLBM gives independent control over vapor diffusivity, binary diffusivity and Schmidt number, which is not possible using SRT model.\n\n    The current implementation is based on:\n    1. Fei, L. &amp; Luo, K. H. Consistent forcing scheme in the cascaded lattice Boltzmann method. Phys. Rev. E 96, 053307 (2017).\n\n    2. Fei, L., Luo, K. H. &amp; Li, Q. Three-dimensional cascaded lattice Boltzmann method: Improved implementation and consistent forcing scheme. Phys. Rev. E 97, 053309 (2018).\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.sigma = kwargs.get(\"sigma\")\n        self.s_0 = kwargs.get(\"s_0\")\n        self.s_1 = kwargs.get(\"s_1\")\n        self.s_b = kwargs.get(\"s_b\")\n        self.s_2 = kwargs.get(\"s_2\")\n        self.s_3 = kwargs.get(\"s_3\")\n        self.s_4 = kwargs.get(\"s_4\")\n        self.M_inv = map(\n            lambda M: jnp.array(\n                np.linalg.inv(M).T,\n                dtype=self.precisionPolicy.compute_dtype,\n            ),\n            kwargs.get(\"M\"),\n        )\n        self.M = map(\n            lambda M: jnp.array(M.T, dtype=self.precisionPolicy.compute_dtype),\n            kwargs.get(\"M\"),\n        )\n\n        if isinstance(self.lattice, LatticeD2Q9):\n            self.S = map(\n                lambda s_0, s_1, s_b, s_2, s_3, s_4: jnp.array(\n                    np.diag([s_0, s_1, s_1, s_b, s_2, s_2, s_3, s_3, s_4]),\n                    dtype=self.precisionPolicy.compute_dtype,\n                ),\n                self.s_0,\n                self.s_1,\n                self.s_b,\n                self.s_2,\n                self.s_3,\n                self.s_4,\n            )\n        elif isinstance(self.lattice, LatticeD3Q19):\n            self.s_plus = map(lambda s_b, s_2: (s_b + 2 * s_2) / 3, self.s_b, self.s_2)\n            self.s_minus = map(lambda s_b, s_2: (s_b - s_2) / 3, self.s_b, self.s_2)\n\n            def f(s_0, s_1, s_v, s_plus, s_minus, s_3, s_4):\n                S = np.diag([s_0, s_1, s_1, s_1, s_v, s_v, s_v, s_plus, s_plus, s_plus, s_3, s_3, s_3, s_3, s_3, s_3, s_4, s_4, s_4])\n                S[7, 8] = s_minus\n                S[7, 9] = s_minus\n                S[8, 7] = s_minus\n                S[8, 9] = s_minus\n                S[9, 7] = s_minus\n                S[9, 8] = s_minus\n                return jnp.array(S, dtype=self.precisionPolicy.compute_dtype)\n\n            self.S = map(\n                lambda s_0, s_1, s_v, s_plus, s_minus, s_3, s_4: f(s_0, s_1, s_v, s_plus, s_minus, s_3, s_4),\n                self.s_0,\n                self.s_1,\n                self.s_2,\n                self.s_plus,\n                self.s_minus,\n                self.s_3,\n                self.s_4,\n            )\n        elif isinstance(self.lattice, LatticeD3Q27):\n            self.s_plus = map(lambda s_b, s_2: (s_b + 2 * s_2) / 3, self.s_b, self.s_2)\n            self.s_minus = map(lambda s_b, s_2: (s_b - s_2) / 3, self.s_b, self.s_2)\n            self.s_3b = kwargs.get(\"s_3b\")\n            self.s_4b = kwargs.get(\"s_4b\")\n            self.s_5 = kwargs.get(\"s_5\")\n            self.s_6 = kwargs.get(\"s_6\")\n\n            def f(s_0, s_1, s_v, s_plus, s_minus, s_3, s_3b, s_4, s_4b, s_5, s_6):\n                S = np.diag([\n                    s_0,\n                    s_1,\n                    s_1,\n                    s_1,\n                    s_v,\n                    s_v,\n                    s_v,\n                    s_plus,\n                    s_plus,\n                    s_plus,\n                    s_3,\n                    s_3,\n                    s_3,\n                    s_3,\n                    s_3,\n                    s_3,\n                    s_3b,\n                    s_4,\n                    s_4,\n                    s_4,\n                    s_4b,\n                    s_4b,\n                    s_4b,\n                    s_5,\n                    s_5,\n                    s_5,\n                    s_6,\n                ])\n                S[7, 8] = s_minus\n                S[7, 9] = s_minus\n                S[8, 7] = s_minus\n                S[8, 9] = s_minus\n                S[9, 7] = s_minus\n                S[9, 8] = s_minus\n                return jnp.array(S, dtype=self.precisionPolicy.compute_dtype)\n\n            self.S = map(\n                lambda s_0, s_1, s_v, s_plus, s_minus, s_3, s_3b, s_4, s_4b, s_5, s_6: f(\n                    s_0, s_1, s_v, s_plus, s_minus, s_3, s_3b, s_4, s_4b, s_5, s_6\n                ),\n                self.s_0,\n                self.s_1,\n                self.s_2,\n                self.s_plus,\n                self.s_minus,\n                self.s_3,\n                self.s_3b,\n                self.s_4,\n                self.s_4b,\n                self.s_5,\n                self.s_6,\n            )\n\n    @property\n    def omega(self):\n        return self._omega\n\n    @omega.setter\n    def omega(self, value=None):\n        self._omega = value\n\n    @property\n    def M(self):\n        return self._M\n\n    @M.setter\n    def M(self, value):\n        if not isinstance(value, list):\n            raise ValueError(\"Matrix M must be a list\")\n        if len(value) != self.n_components:\n            raise ValueError(\"Number of components does not match number of matrix M passed\")\n        self._M = value\n\n    @partial(jit, static_argnums=(0,))\n    def compute_central_moment(self, m_tree, u_tree):\n        if isinstance(self.lattice, LatticeD2Q9):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                usq = ux**2 + uy**2\n                udiff = ux**2 - uy**2\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(-ux * m[..., 0] + m[..., 1])\n                T = T.at[..., 2].set(-uy * m[..., 0] + m[..., 2])\n                T = T.at[..., 3].set(usq * m[..., 0] - 2 * ux * m[..., 1] - 2 * uy * m[..., 2] + m[..., 3])\n                T = T.at[..., 4].set(udiff * m[..., 0] - 2 * ux * m[..., 1] + 2 * uy * m[..., 2] + m[..., 4])\n                T = T.at[..., 5].set(ux * uy * m[..., 0] - uy * m[..., 1] - ux * m[..., 2] + m[..., 5])\n                T = T.at[..., 6].set(\n                    -(ux**2) * uy * m[..., 0]\n                    + 2 * ux * uy * m[..., 1]\n                    + ux**2 * m[..., 2]\n                    - 0.5 * uy * m[..., 3]\n                    - 0.5 * uy * m[..., 4]\n                    - 2 * ux * m[..., 5]\n                    + m[..., 6]\n                )\n                T = T.at[..., 7].set(\n                    -(uy**2) * ux * m[..., 0]\n                    + uy**2 * m[..., 1]\n                    + 2 * ux * uy * m[..., 2]\n                    - 0.5 * ux * m[..., 3]\n                    + 0.5 * ux * m[..., 4]\n                    - 2 * uy * m[..., 5]\n                    + m[..., 7]\n                )\n                T = T.at[..., 8].set(\n                    (uy**2 * ux**2) * m[..., 0]\n                    - 2 * ux * uy**2 * m[..., 1]\n                    - 2 * uy * ux**2 * m[..., 2]\n                    + 0.5 * usq * m[..., 3]\n                    - 0.5 * udiff * m[..., 4]\n                    + 4 * ux * uy * m[..., 5]\n                    - 2 * uy * m[..., 6]\n                    - 2 * ux * m[..., 7]\n                    + m[..., 8]\n                )\n                return T\n\n            return map(lambda m, u: shift(m, u), m_tree, u_tree)\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(-ux * m[..., 0] + m[..., 1])\n                T = T.at[..., 2].set(-uy * m[..., 0] + m[..., 2])\n                T = T.at[..., 3].set(-uz * m[..., 0] + m[..., 3])\n                T = T.at[..., 4].set(ux * uy * m[..., 0] - uy * m[..., 1] - ux * m[..., 2] + m[..., 4])\n                T = T.at[..., 5].set(ux * uz * m[..., 0] - uz * m[..., 1] - ux * m[..., 3] + m[..., 5])\n                T = T.at[..., 6].set(uy * uz * m[..., 0] - uz * m[..., 2] - uy * m[..., 3] + m[..., 6])\n                T = T.at[..., 7].set((ux**2) * m[..., 0] - 2 * ux * m[..., 1] + m[..., 7])\n                T = T.at[..., 8].set((uy**2) * m[..., 0] - 2 * uy * m[..., 2] + m[..., 8])\n                T = T.at[..., 9].set((uz**2) * m[..., 0] - 2 * uz * m[..., 3] + m[..., 9])\n                T = T.at[..., 10].set(\n                    -ux * (uy**2) * m[..., 0] + (uy**2) * m[..., 1] + 2 * ux * uy * m[..., 2] - 2 * uy * m[..., 4] - ux * m[..., 8] + m[..., 10]\n                )\n                T = T.at[..., 11].set(\n                    -ux * (uz**2) * m[..., 0] + (uz**2) * m[..., 1] + 2 * ux * uz * m[..., 3] - 2 * uz * m[..., 5] - ux * m[..., 9] + m[..., 11]\n                )\n                T = T.at[..., 12].set(\n                    -(ux**2) * uy * m[..., 0] + 2 * ux * uy * m[..., 1] + (ux**2) * m[..., 2] - 2 * ux * m[..., 4] - uy * m[..., 7] + m[..., 12]\n                )\n                T = T.at[..., 13].set(\n                    -(ux**2) * uz * m[..., 0] + 2 * ux * uz * m[..., 1] + (ux**2) * m[..., 3] - 2 * ux * m[..., 5] - uz * m[..., 7] + m[..., 13]\n                )\n                T = T.at[..., 14].set(\n                    -uy * (uz**2) * m[..., 0] + (uz**2) * m[..., 2] + 2 * uy * uz * m[..., 3] - 2 * uz * m[..., 6] - uy * m[..., 9] + m[..., 14]\n                )\n                T = T.at[..., 15].set(\n                    -(uy**2) * uz * m[..., 0] + 2 * uy * uz * m[..., 2] + (uy**2) * m[..., 3] - 2 * uy * m[..., 6] - uz * m[..., 8] + m[..., 15]\n                )\n                T = T.at[..., 16].set(\n                    (ux**2) * (uy**2) * m[..., 0]\n                    - 2 * ux * (uy**2) * m[..., 1]\n                    - 2 * uy * (ux**2) * m[..., 2]\n                    + 4 * ux * uy * m[..., 4]\n                    + (uy**2) * m[..., 7]\n                    + (ux**2) * m[..., 8]\n                    - 2 * ux * m[..., 10]\n                    - 2 * uy * m[..., 12]\n                    + m[..., 16]\n                )\n                T = T.at[..., 17].set(\n                    (ux**2) * (uz**2) * m[..., 0]\n                    - 2 * ux * (uz**2) * m[..., 1]\n                    - 2 * uz * (ux**2) * m[..., 3]\n                    + 4 * ux * uz * m[..., 5]\n                    + (uz**2) * m[..., 7]\n                    + (ux**2) * m[..., 9]\n                    - 2 * ux * m[..., 11]\n                    - 2 * uz * m[..., 13]\n                    + m[..., 17]\n                )\n                T = T.at[..., 18].set(\n                    (uy**2) * (uz**2) * m[..., 0]\n                    - 2 * uy * (uz**2) * m[..., 2]\n                    - 2 * uz * (uy**2) * m[..., 3]\n                    + 4 * uy * uz * m[..., 6]\n                    + (uz**2) * m[..., 8]\n                    + (uy**2) * m[..., 9]\n                    - 2 * uy * m[..., 14]\n                    - 2 * uz * m[..., 15]\n                    + m[..., 18]\n                )\n                return T\n\n            return map(lambda m, u: shift(m, u), m_tree, u_tree)\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n\n            def shift(m, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                T = jnp.zeros_like(m)\n                T = T.at[..., 0].set(m[..., 0])\n                T = T.at[..., 1].set(m[..., 1] - m[..., 0] * ux)\n                T = T.at[..., 2].set(m[..., 2] - m[..., 0] * uy)\n                T = T.at[..., 3].set(m[..., 3] - m[..., 0] * uz)\n                T = T.at[..., 4].set(m[..., 4] - m[..., 2] * ux - m[..., 1] * uy + m[..., 0] * ux * uy)\n                T = T.at[..., 5].set(m[..., 5] - m[..., 3] * ux - m[..., 1] * uz + m[..., 0] * ux * uz)\n                T = T.at[..., 6].set(m[..., 6] - m[..., 3] * uy - m[..., 2] * uz + m[..., 0] * uy * uz)\n                T = T.at[..., 7].set(m[..., 0] * ux**2 - 2 * m[..., 1] * ux + m[..., 7])\n                T = T.at[..., 8].set(m[..., 0] * uy**2 - 2 * m[..., 2] * uy + m[..., 8])\n                T = T.at[..., 9].set(m[..., 0] * uz**2 - 2 * m[..., 3] * uz + m[..., 9])\n                T = T.at[..., 10].set(\n                    m[..., 10] - m[..., 8] * ux - 2 * m[..., 4] * uy + m[..., 1] * uy**2 - m[..., 0] * ux * uy**2 + 2 * m[..., 2] * ux * uy\n                )\n                T = T.at[..., 11].set(\n                    m[..., 11] - m[..., 9] * ux - 2 * m[..., 5] * uz + m[..., 1] * uz**2 - m[..., 0] * ux * uz**2 + 2 * m[..., 3] * ux * uz\n                )\n                T = T.at[..., 12].set(\n                    m[..., 12] - 2 * m[..., 4] * ux - m[..., 7] * uy + m[..., 2] * ux**2 - m[..., 0] * ux**2 * uy + 2 * m[..., 1] * ux * uy\n                )\n                T = T.at[..., 13].set(\n                    m[..., 13] - 2 * m[..., 5] * ux - m[..., 7] * uz + m[..., 3] * ux**2 - m[..., 0] * ux**2 * uz + 2 * m[..., 1] * ux * uz\n                )\n                T = T.at[..., 14].set(\n                    m[..., 14] - m[..., 9] * uy - 2 * m[..., 6] * uz + m[..., 2] * uz**2 - m[..., 0] * uy * uz**2 + 2 * m[..., 3] * uy * uz\n                )\n                T = T.at[..., 15].set(\n                    m[..., 15] - 2 * m[..., 6] * uy - m[..., 8] * uz + m[..., 3] * uy**2 - m[..., 0] * uy**2 * uz + 2 * m[..., 2] * uy * uz\n                )\n                T = T.at[..., 16].set(\n                    m[..., 16]\n                    - m[..., 6] * ux\n                    - m[..., 5] * uy\n                    - m[..., 4] * uz\n                    + m[..., 3] * ux * uy\n                    + m[..., 2] * ux * uz\n                    + m[..., 1] * uy * uz\n                    - m[..., 0] * ux * uy * uz\n                )\n                T = T.at[..., 17].set(\n                    m[..., 0] * ux**2 * uy**2\n                    - 2 * m[..., 2] * ux**2 * uy\n                    + m[..., 8] * ux**2\n                    - 2 * m[..., 1] * ux * uy**2\n                    + 4 * m[..., 4] * ux * uy\n                    - 2 * m[..., 10] * ux\n                    + m[..., 7] * uy**2\n                    - 2 * m[..., 12] * uy\n                    + m[..., 17]\n                )\n                T = T.at[..., 18].set(\n                    m[..., 0] * ux**2 * uz**2\n                    - 2 * m[..., 3] * ux**2 * uz\n                    + m[..., 9] * ux**2\n                    - 2 * m[..., 1] * ux * uz**2\n                    + 4 * m[..., 5] * ux * uz\n                    - 2 * m[..., 11] * ux\n                    + m[..., 7] * uz**2\n                    - 2 * m[..., 13] * uz\n                    + m[..., 18]\n                )\n                T = T.at[..., 19].set(\n                    m[..., 0] * uy**2 * uz**2\n                    - 2 * m[..., 3] * uy**2 * uz\n                    + m[..., 9] * uy**2\n                    - 2 * m[..., 2] * uy * uz**2\n                    + 4 * m[..., 6] * uy * uz\n                    - 2 * m[..., 14] * uy\n                    + m[..., 8] * uz**2\n                    - 2 * m[..., 15] * uz\n                    + m[..., 19]\n                )\n                T = T.at[..., 20].set(\n                    m[..., 20]\n                    - 2 * m[..., 16] * ux\n                    - m[..., 13] * uy\n                    - m[..., 12] * uz\n                    + m[..., 6] * ux**2\n                    - m[..., 3] * ux**2 * uy\n                    - m[..., 2] * ux**2 * uz\n                    + 2 * m[..., 5] * ux * uy\n                    + 2 * m[..., 4] * ux * uz\n                    + m[..., 7] * uy * uz\n                    - 2 * m[..., 1] * ux * uy * uz\n                    + m[..., 0] * ux**2 * uy * uz\n                )\n                T = T.at[..., 21].set(\n                    m[..., 21]\n                    - m[..., 15] * ux\n                    - 2 * m[..., 16] * uy\n                    - m[..., 10] * uz\n                    + m[..., 5] * uy**2\n                    - m[..., 3] * ux * uy**2\n                    - m[..., 1] * uy**2 * uz\n                    + 2 * m[..., 6] * ux * uy\n                    + m[..., 8] * ux * uz\n                    + 2 * m[..., 4] * uy * uz\n                    - 2 * m[..., 2] * ux * uy * uz\n                    + m[..., 0] * ux * uy**2 * uz\n                )\n                T = T.at[..., 22].set(\n                    m[..., 22]\n                    - m[..., 14] * ux\n                    - m[..., 11] * uy\n                    - 2 * m[..., 16] * uz\n                    + m[..., 4] * uz**2\n                    - m[..., 2] * ux * uz**2\n                    - m[..., 1] * uy * uz**2\n                    + m[..., 9] * ux * uy\n                    + 2 * m[..., 6] * ux * uz\n                    + 2 * m[..., 5] * uy * uz\n                    - 2 * m[..., 3] * ux * uy * uz\n                    + m[..., 0] * ux * uy * uz**2\n                )\n                T = T.at[..., 23].set(\n                    m[..., 23]\n                    - m[..., 19] * ux\n                    - 2 * m[..., 22] * uy\n                    - 2 * m[..., 21] * uz\n                    + m[..., 11] * uy**2\n                    + m[..., 10] * uz**2\n                    - m[..., 9] * ux * uy**2\n                    - m[..., 8] * ux * uz**2\n                    - 2 * m[..., 4] * uy * uz**2\n                    - 2 * m[..., 5] * uy**2 * uz\n                    + m[..., 1] * uy**2 * uz**2\n                    + 2 * m[..., 14] * ux * uy\n                    + 2 * m[..., 15] * ux * uz\n                    + 4 * m[..., 16] * uy * uz\n                    - 4 * m[..., 6] * ux * uy * uz\n                    + 2 * m[..., 2] * ux * uy * uz**2\n                    + 2 * m[..., 3] * ux * uy**2 * uz\n                    - m[..., 0] * ux * uy**2 * uz**2\n                )\n                T = T.at[..., 24].set(\n                    m[..., 24]\n                    - 2 * m[..., 22] * ux\n                    - m[..., 18] * uy\n                    - 2 * m[..., 20] * uz\n                    + m[..., 14] * ux**2\n                    + m[..., 12] * uz**2\n                    - m[..., 9] * ux**2 * uy\n                    - 2 * m[..., 4] * ux * uz**2\n                    - 2 * m[..., 6] * ux**2 * uz\n                    - m[..., 7] * uy * uz**2\n                    + m[..., 2] * ux**2 * uz**2\n                    + 2 * m[..., 11] * ux * uy\n                    + 4 * m[..., 16] * ux * uz\n                    + 2 * m[..., 13] * uy * uz\n                    - 4 * m[..., 5] * ux * uy * uz\n                    + 2 * m[..., 1] * ux * uy * uz**2\n                    + 2 * m[..., 3] * ux**2 * uy * uz\n                    - m[..., 0] * ux**2 * uy * uz**2\n                )\n                T = T.at[..., 25].set(\n                    m[..., 25]\n                    - 2 * m[..., 21] * ux\n                    - 2 * m[..., 20] * uy\n                    - m[..., 17] * uz\n                    + m[..., 15] * ux**2\n                    + m[..., 13] * uy**2\n                    - 2 * m[..., 5] * ux * uy**2\n                    - 2 * m[..., 6] * ux**2 * uy\n                    - m[..., 8] * ux**2 * uz\n                    - m[..., 7] * uy**2 * uz\n                    + m[..., 3] * ux**2 * uy**2\n                    + 4 * m[..., 16] * ux * uy\n                    + 2 * m[..., 10] * ux * uz\n                    + 2 * m[..., 12] * uy * uz\n                    - 4 * m[..., 4] * ux * uy * uz\n                    + 2 * m[..., 1] * ux * uy**2 * uz\n                    + 2 * m[..., 2] * ux**2 * uy * uz\n                    - m[..., 0] * ux**2 * uy**2 * uz\n                )\n                T = T.at[..., 26].set(\n                    m[..., 0] * ux**2 * uy**2 * uz**2\n                    - 2 * m[..., 3] * ux**2 * uy**2 * uz\n                    + m[..., 9] * ux**2 * uy**2\n                    - 2 * m[..., 2] * ux**2 * uy * uz**2\n                    + 4 * m[..., 6] * ux**2 * uy * uz\n                    - 2 * m[..., 14] * ux**2 * uy\n                    + m[..., 8] * ux**2 * uz**2\n                    - 2 * m[..., 15] * ux**2 * uz\n                    + m[..., 19] * ux**2\n                    - 2 * m[..., 1] * ux * uy**2 * uz**2\n                    + 4 * m[..., 5] * ux * uy**2 * uz\n                    - 2 * m[..., 11] * ux * uy**2\n                    + 4 * m[..., 4] * ux * uy * uz**2\n                    - 8 * m[..., 16] * ux * uy * uz\n                    + 4 * m[..., 22] * ux * uy\n                    - 2 * m[..., 10] * ux * uz**2\n                    + 4 * m[..., 21] * ux * uz\n                    - 2 * m[..., 23] * ux\n                    + m[..., 7] * uy**2 * uz**2\n                    - 2 * m[..., 13] * uy**2 * uz\n                    + m[..., 18] * uy**2\n                    - 2 * m[..., 12] * uy * uz**2\n                    + 4 * m[..., 20] * uy * uz\n                    - 2 * m[..., 24] * uy\n                    + m[..., 17] * uz**2\n                    - 2 * m[..., 25] * uz\n                    + m[..., 26]\n                )\n\n                return T\n\n            return map(lambda m, u: shift(m, u), m_tree, u_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_central_moment_inverse(self, T_tree, u_tree):\n        if isinstance(self.lattice, LatticeD2Q9):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                usq = ux**2 + uy**2\n                udiff = ux**2 - uy**2\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(ux * T[..., 0] + T[..., 1])\n                m = m.at[..., 2].set(uy * T[..., 0] + T[..., 2])\n                m = m.at[..., 3].set(usq * T[..., 0] + 2 * ux * T[..., 1] + 2 * uy * T[..., 2] + T[..., 3])\n                m = m.at[..., 4].set(udiff * T[..., 0] + 2 * ux * T[..., 1] - 2 * uy * T[..., 2] + T[..., 4])\n                m = m.at[..., 5].set(ux * uy * T[..., 0] + uy * T[..., 1] + ux * T[..., 2] + T[..., 5])\n                m = m.at[..., 6].set(\n                    (ux**2) * uy * T[..., 0]\n                    + 2 * ux * uy * T[..., 1]\n                    + ux**2 * T[..., 2]\n                    + 0.5 * uy * T[..., 3]\n                    + 0.5 * uy * T[..., 4]\n                    + 2 * ux * T[..., 5]\n                    + T[..., 6]\n                )\n                m = m.at[..., 7].set(\n                    (uy**2) * ux * T[..., 0]\n                    + uy**2 * T[..., 1]\n                    + 2 * ux * uy * T[..., 2]\n                    + 0.5 * ux * T[..., 3]\n                    - 0.5 * ux * T[..., 4]\n                    + 2 * uy * T[..., 5]\n                    + T[..., 7]\n                )\n                m = m.at[..., 8].set(\n                    (uy**2 * ux**2) * T[..., 0]\n                    + 2 * ux * uy**2 * T[..., 1]\n                    + 2 * uy * ux**2 * T[..., 2]\n                    + 0.5 * usq * T[..., 3]\n                    - 0.5 * udiff * T[..., 4]\n                    + 4 * ux * uy * T[..., 5]\n                    + 2 * uy * T[..., 6]\n                    + 2 * ux * T[..., 7]\n                    + T[..., 8]\n                )\n                return m\n\n            return map(lambda T, u: shift_inverse(T, u), T_tree, u_tree)\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(ux * T[..., 0] + T[..., 1])\n                m = m.at[..., 2].set(uy * T[..., 0] + T[..., 2])\n                m = m.at[..., 3].set(uz * T[..., 0] + T[..., 3])\n                m = m.at[..., 4].set(ux * uy * T[..., 0] + uy * T[..., 1] + ux * T[..., 2] + T[..., 4])\n                m = m.at[..., 5].set(ux * uz * T[..., 0] + uz * T[..., 1] + ux * T[..., 3] + T[..., 5])\n                m = m.at[..., 6].set(uy * uz * T[..., 0] + uz * T[..., 2] + uy * T[..., 3] + T[..., 6])\n                m = m.at[..., 7].set((ux**2) * T[..., 0] + 2 * ux * T[..., 1] + T[..., 7])\n                m = m.at[..., 8].set((uy**2) * T[..., 0] + 2 * uy * T[..., 2] + T[..., 8])\n                m = m.at[..., 9].set((uz**2) * T[..., 0] + 2 * uz * T[..., 3] + T[..., 9])\n                m = m.at[..., 10].set(\n                    ux * (uy**2) * T[..., 0] + (uy**2) * T[..., 1] + 2 * ux * uy * T[..., 2] + 2 * uy * T[..., 4] + ux * T[..., 8] + T[..., 10]\n                )\n                m = m.at[..., 11].set(\n                    ux * (uz**2) * T[..., 0] + (uz**2) * T[..., 1] + 2 * ux * uz * T[..., 3] + 2 * uz * T[..., 5] + ux * T[..., 9] + T[..., 11]\n                )\n                m = m.at[..., 12].set(\n                    (ux**2) * uy * T[..., 0] + 2 * ux * uy * T[..., 1] + (ux**2) * T[..., 2] + 2 * ux * T[..., 4] + uy * T[..., 7] + T[..., 12]\n                )\n                m = m.at[..., 13].set(\n                    (ux**2) * uz * T[..., 0] + 2 * ux * uz * T[..., 1] + (ux**2) * T[..., 3] + 2 * ux * T[..., 5] + uz * T[..., 7] + T[..., 13]\n                )\n                m = m.at[..., 14].set(\n                    uy * (uz**2) * T[..., 0] + (uz**2) * T[..., 2] + 2 * uy * uz * T[..., 3] + 2 * uz * T[..., 6] + uy * T[..., 9] + T[..., 14]\n                )\n                m = m.at[..., 15].set(\n                    (uy**2) * uz * T[..., 0] + 2 * uy * uz * T[..., 2] + (uy**2) * T[..., 3] + 2 * uy * T[..., 6] + uz * T[..., 8] + T[..., 15]\n                )\n                m = m.at[..., 16].set(\n                    (ux**2) * (uy**2) * T[..., 0]\n                    + 2 * ux * (uy**2) * T[..., 1]\n                    + 2 * uy * (ux**2) * T[..., 2]\n                    + 4 * ux * uy * T[..., 4]\n                    + (uy**2) * T[..., 7]\n                    + (ux**2) * T[..., 8]\n                    + 2 * ux * T[..., 10]\n                    + 2 * uy * T[..., 12]\n                    + T[..., 16]\n                )\n                m = m.at[..., 17].set(\n                    (ux**2) * (uz**2) * T[..., 0]\n                    + 2 * ux * (uz**2) * T[..., 1]\n                    + 2 * uz * (ux**2) * T[..., 3]\n                    + 4 * ux * uz * T[..., 5]\n                    + (uz**2) * T[..., 7]\n                    + (ux**2) * T[..., 9]\n                    + 2 * ux * T[..., 11]\n                    + 2 * uz * T[..., 13]\n                    + T[..., 17]\n                )\n                m = m.at[..., 18].set(\n                    (uy**2) * (uz**2) * T[..., 0]\n                    + 2 * uy * (uz**2) * T[..., 2]\n                    + 2 * uz * (uy**2) * T[..., 3]\n                    + 4 * uy * uz * T[..., 6]\n                    + (uz**2) * T[..., 8]\n                    + (uy**2) * T[..., 9]\n                    + 2 * uy * T[..., 14]\n                    + 2 * uz * T[..., 15]\n                    + T[..., 18]\n                )\n                return m\n\n            return map(lambda T, u: shift_inverse(T, u), T_tree, u_tree)\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n\n            def shift_inverse(T, u):\n                ux = u[..., 0]\n                uy = u[..., 1]\n                uz = u[..., 2]\n                m = jnp.zeros_like(T)\n                m = m.at[..., 0].set(T[..., 0])\n                m = m.at[..., 1].set(T[..., 1] + T[..., 0] * ux)\n                m = m.at[..., 2].set(T[..., 2] + T[..., 0] * uy)\n                m = m.at[..., 3].set(T[..., 3] + T[..., 0] * uz)\n                m = m.at[..., 4].set(T[..., 4] + T[..., 2] * ux + T[..., 1] * uy + T[..., 0] * ux * uy)\n                m = m.at[..., 5].set(T[..., 5] + T[..., 3] * ux + T[..., 1] * uz + T[..., 0] * ux * uz)\n                m = m.at[..., 6].set(T[..., 6] + T[..., 3] * uy + T[..., 2] * uz + T[..., 0] * uy * uz)\n                m = m.at[..., 7].set(T[..., 0] * ux**2 + 2 * T[..., 1] * ux + T[..., 7])\n                m = m.at[..., 8].set(T[..., 0] * uy**2 + 2 * T[..., 2] * uy + T[..., 8])\n                m = m.at[..., 9].set(T[..., 0] * uz**2 + 2 * T[..., 3] * uz + T[..., 9])\n                m = m.at[..., 10].set(\n                    T[..., 10] + T[..., 8] * ux + 2 * T[..., 4] * uy + T[..., 1] * uy**2 + T[..., 0] * ux * uy**2 + 2 * T[..., 2] * ux * uy\n                )\n                m = m.at[..., 11].set(\n                    T[..., 11] + T[..., 9] * ux + 2 * T[..., 5] * uz + T[..., 1] * uz**2 + T[..., 0] * ux * uz**2 + 2 * T[..., 3] * ux * uz\n                )\n                m = m.at[..., 12].set(\n                    T[..., 12] + 2 * T[..., 4] * ux + T[..., 7] * uy + T[..., 2] * ux**2 + T[..., 0] * ux**2 * uy + 2 * T[..., 1] * ux * uy\n                )\n                m = m.at[..., 13].set(\n                    T[..., 13] + 2 * T[..., 5] * ux + T[..., 7] * uz + T[..., 3] * ux**2 + T[..., 0] * ux**2 * uz + 2 * T[..., 1] * ux * uz\n                )\n                m = m.at[..., 14].set(\n                    T[..., 14] + T[..., 9] * uy + 2 * T[..., 6] * uz + T[..., 2] * uz**2 + T[..., 0] * uy * uz**2 + 2 * T[..., 3] * uy * uz\n                )\n                m = m.at[..., 15].set(\n                    T[..., 15] + 2 * T[..., 6] * uy + T[..., 8] * uz + T[..., 3] * uy**2 + T[..., 0] * uy**2 * uz + 2 * T[..., 2] * uy * uz\n                )\n                m = m.at[..., 16].set(\n                    T[..., 16]\n                    + T[..., 6] * ux\n                    + T[..., 5] * uy\n                    + T[..., 4] * uz\n                    + T[..., 3] * ux * uy\n                    + T[..., 2] * ux * uz\n                    + T[..., 1] * uy * uz\n                    + T[..., 0] * ux * uy * uz\n                )\n                m = m.at[..., 17].set(\n                    T[..., 0] * ux**2 * uy**2\n                    + 2 * T[..., 2] * ux**2 * uy\n                    + T[..., 8] * ux**2\n                    + 2 * T[..., 1] * ux * uy**2\n                    + 4 * T[..., 4] * ux * uy\n                    + 2 * T[..., 10] * ux\n                    + T[..., 7] * uy**2\n                    + 2 * T[..., 12] * uy\n                    + T[..., 17]\n                )\n                m = m.at[..., 18].set(\n                    T[..., 0] * ux**2 * uz**2\n                    + 2 * T[..., 3] * ux**2 * uz\n                    + T[..., 9] * ux**2\n                    + 2 * T[..., 1] * ux * uz**2\n                    + 4 * T[..., 5] * ux * uz\n                    + 2 * T[..., 11] * ux\n                    + T[..., 7] * uz**2\n                    + 2 * T[..., 13] * uz\n                    + T[..., 18]\n                )\n                m = m.at[..., 19].set(\n                    T[..., 0] * uy**2 * uz**2\n                    + 2 * T[..., 3] * uy**2 * uz\n                    + T[..., 9] * uy**2\n                    + 2 * T[..., 2] * uy * uz**2\n                    + 4 * T[..., 6] * uy * uz\n                    + 2 * T[..., 14] * uy\n                    + T[..., 8] * uz**2\n                    + 2 * T[..., 15] * uz\n                    + T[..., 19]\n                )\n                m = m.at[..., 20].set(\n                    T[..., 20]\n                    + 2 * T[..., 16] * ux\n                    + T[..., 13] * uy\n                    + T[..., 12] * uz\n                    + T[..., 6] * ux**2\n                    + T[..., 3] * ux**2 * uy\n                    + T[..., 2] * ux**2 * uz\n                    + 2 * T[..., 5] * ux * uy\n                    + 2 * T[..., 4] * ux * uz\n                    + T[..., 7] * uy * uz\n                    + 2 * T[..., 1] * ux * uy * uz\n                    + T[..., 0] * ux**2 * uy * uz\n                )\n                m = m.at[..., 21].set(\n                    T[..., 21]\n                    + T[..., 15] * ux\n                    + 2 * T[..., 16] * uy\n                    + T[..., 10] * uz\n                    + T[..., 5] * uy**2\n                    + T[..., 3] * ux * uy**2\n                    + T[..., 1] * uy**2 * uz\n                    + 2 * T[..., 6] * ux * uy\n                    + T[..., 8] * ux * uz\n                    + 2 * T[..., 4] * uy * uz\n                    + 2 * T[..., 2] * ux * uy * uz\n                    + T[..., 0] * ux * uy**2 * uz\n                )\n                m = m.at[..., 22].set(\n                    T[..., 22]\n                    + T[..., 14] * ux\n                    + T[..., 11] * uy\n                    + 2 * T[..., 16] * uz\n                    + T[..., 4] * uz**2\n                    + T[..., 2] * ux * uz**2\n                    + T[..., 1] * uy * uz**2\n                    + T[..., 9] * ux * uy\n                    + 2 * T[..., 6] * ux * uz\n                    + 2 * T[..., 5] * uy * uz\n                    + 2 * T[..., 3] * ux * uy * uz\n                    + T[..., 0] * ux * uy * uz**2\n                )\n                m = m.at[..., 23].set(\n                    T[..., 23]\n                    + T[..., 19] * ux\n                    + 2 * T[..., 22] * uy\n                    + 2 * T[..., 21] * uz\n                    + T[..., 11] * uy**2\n                    + T[..., 10] * uz**2\n                    + T[..., 9] * ux * uy**2\n                    + T[..., 8] * ux * uz**2\n                    + 2 * T[..., 4] * uy * uz**2\n                    + 2 * T[..., 5] * uy**2 * uz\n                    + T[..., 1] * uy**2 * uz**2\n                    + 2 * T[..., 14] * ux * uy\n                    + 2 * T[..., 15] * ux * uz\n                    + 4 * T[..., 16] * uy * uz\n                    + 4 * T[..., 6] * ux * uy * uz\n                    + 2 * T[..., 2] * ux * uy * uz**2\n                    + 2 * T[..., 3] * ux * uy**2 * uz\n                    + T[..., 0] * ux * uy**2 * uz**2\n                )\n                m = m.at[..., 24].set(\n                    T[..., 24]\n                    + 2 * T[..., 22] * ux\n                    + T[..., 18] * uy\n                    + 2 * T[..., 20] * uz\n                    + T[..., 14] * ux**2\n                    + T[..., 12] * uz**2\n                    + T[..., 9] * ux**2 * uy\n                    + 2 * T[..., 4] * ux * uz**2\n                    + 2 * T[..., 6] * ux**2 * uz\n                    + T[..., 7] * uy * uz**2\n                    + T[..., 2] * ux**2 * uz**2\n                    + 2 * T[..., 11] * ux * uy\n                    + 4 * T[..., 16] * ux * uz\n                    + 2 * T[..., 13] * uy * uz\n                    + 4 * T[..., 5] * ux * uy * uz\n                    + 2 * T[..., 1] * ux * uy * uz**2\n                    + 2 * T[..., 3] * ux**2 * uy * uz\n                    + T[..., 0] * ux**2 * uy * uz**2\n                )\n                m = m.at[..., 25].set(\n                    T[..., 25]\n                    + 2 * T[..., 21] * ux\n                    + 2 * T[..., 20] * uy\n                    + T[..., 17] * uz\n                    + T[..., 15] * ux**2\n                    + T[..., 13] * uy**2\n                    + 2 * T[..., 5] * ux * uy**2\n                    + 2 * T[..., 6] * ux**2 * uy\n                    + T[..., 8] * ux**2 * uz\n                    + T[..., 7] * uy**2 * uz\n                    + T[..., 3] * ux**2 * uy**2\n                    + 4 * T[..., 16] * ux * uy\n                    + 2 * T[..., 10] * ux * uz\n                    + 2 * T[..., 12] * uy * uz\n                    + 4 * T[..., 4] * ux * uy * uz\n                    + 2 * T[..., 1] * ux * uy**2 * uz\n                    + 2 * T[..., 2] * ux**2 * uy * uz\n                    + T[..., 0] * ux**2 * uy**2 * uz\n                )\n                m = m.at[..., 26].set(\n                    T[..., 0] * ux**2 * uy**2 * uz**2\n                    + 2 * T[..., 3] * ux**2 * uy**2 * uz\n                    + T[..., 9] * ux**2 * uy**2\n                    + 2 * T[..., 2] * ux**2 * uy * uz**2\n                    + 4 * T[..., 6] * ux**2 * uy * uz\n                    + 2 * T[..., 14] * ux**2 * uy\n                    + T[..., 8] * ux**2 * uz**2\n                    + 2 * T[..., 15] * ux**2 * uz\n                    + T[..., 19] * ux**2\n                    + 2 * T[..., 1] * ux * uy**2 * uz**2\n                    + 4 * T[..., 5] * ux * uy**2 * uz\n                    + 2 * T[..., 11] * ux * uy**2\n                    + 4 * T[..., 4] * ux * uy * uz**2\n                    + 8 * T[..., 16] * ux * uy * uz\n                    + 4 * T[..., 22] * ux * uy\n                    + 2 * T[..., 10] * ux * uz**2\n                    + 4 * T[..., 21] * ux * uz\n                    + 2 * T[..., 23] * ux\n                    + T[..., 7] * uy**2 * uz**2\n                    + 2 * T[..., 13] * uy**2 * uz\n                    + T[..., 18] * uy**2\n                    + 2 * T[..., 12] * uy * uz**2\n                    + 4 * T[..., 20] * uy * uz\n                    + 2 * T[..., 24] * uy\n                    + T[..., 17] * uz**2\n                    + 2 * T[..., 25] * uz\n                    + T[..., 26]\n                )\n                return m\n\n            return map(lambda T, u: shift_inverse(T, u), T_tree, u_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_eq_central_moments(self, rho_tree):\n        \"\"\"\n        Calculate the central moments of the equilibrium distribution.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field for all components.\n\n        Returns\n        -------\n        T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the equilibrium distribution.\n        \"\"\"\n\n        def f(rho):\n            if isinstance(self.lattice, LatticeD2Q9):\n                T_eq = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                T_eq = T_eq.at[..., 0].set(rho[..., 0])\n                T_eq = T_eq.at[..., 3].set(2 * rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs**4)\n\n                return T_eq\n\n            elif isinstance(self.lattice, LatticeD3Q19):\n                T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                T_eq = T_eq.at[..., 0].set(rho[..., 0])\n                T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 16].set(rho[..., 0] * self.lattice.cs**4)\n                T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n                T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n\n                return T_eq\n\n            elif isinstance(self.lattice, LatticeD3Q27):\n                T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                T_eq = T_eq.at[..., 0].set(rho[..., 0])\n                T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n                T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n                T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n                T_eq = T_eq.at[..., 19].set(rho[..., 0] * self.lattice.cs**4)\n                T_eq = T_eq.at[..., 26].set(rho[..., 0] * self.lattice.cs**6)\n\n                return T_eq\n\n        return map(lambda rho: f(rho), rho_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_force_central_moments(self, F_tree, psi_tree):\n        \"\"\"\n        Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.\n\n        Parameters\n        ----------\n        F_tree (pytree of jax.numpy.ndarray): Force field.\n\n        psi_tree (pytree of jax.numpy.ndarray): Potential field.\n\n        Returns\n        -------\n        T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the force distribution.\n        \"\"\"\n\n        def f(F, sigma, psi, s_b):\n            if isinstance(self.lattice, LatticeD2Q9):\n                C = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                Fx = F[..., 0]\n                Fy = F[..., 1]\n                eta = 4 * sigma * (Fx**2 + Fy**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))  # For mechanical stability\n                C = C.at[..., 1].set(Fx)\n                C = C.at[..., 2].set(Fy)\n                C = C.at[..., 3].set(eta)\n                C = C.at[..., 6].set(Fy * self.lattice.cs2)\n                C = C.at[..., 7].set(Fx * self.lattice.cs2)\n                C = C.at[..., 8].set(eta * self.lattice.cs2)\n\n                return C\n            elif isinstance(self.lattice, LatticeD3Q19):\n                C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                Fx = F[..., 0]\n                Fy = F[..., 1]\n                Fz = F[..., 2]\n                eta = 4 * sigma * (Fx**2 + Fy**2 + Fz**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))\n                C = C.at[..., 1].set(Fx)\n                C = C.at[..., 2].set(Fy)\n                C = C.at[..., 3].set(Fz)\n                C = C.at[..., 7].set(eta)\n                C = C.at[..., 8].set(eta)\n                C = C.at[..., 9].set(eta)\n                C = C.at[..., 10].set(Fx * self.lattice.cs2)\n                C = C.at[..., 11].set(Fx * self.lattice.cs2)\n                C = C.at[..., 12].set(Fy * self.lattice.cs2)\n                C = C.at[..., 13].set(Fz * self.lattice.cs2)\n                C = C.at[..., 14].set(Fy * self.lattice.cs2)\n                C = C.at[..., 15].set(Fz * self.lattice.cs2)\n\n                return C\n            elif isinstance(self.lattice, LatticeD3Q27):\n                C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n                Fx = F[..., 0]\n                Fy = F[..., 1]\n                Fz = F[..., 2]\n                C = C.at[..., 1].set(Fx)\n                C = C.at[..., 2].set(Fy)\n                C = C.at[..., 3].set(Fz)\n                eta = 4 * sigma * (Fx**2 + Fy**2 + Fz**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))\n                C = C.at[..., 7].set(eta)\n                C = C.at[..., 8].set(eta)\n                C = C.at[..., 9].set(eta)\n                C = C.at[..., 10].set(Fx * self.lattice.cs2)\n                C = C.at[..., 11].set(Fx * self.lattice.cs2)\n                C = C.at[..., 12].set(Fy * self.lattice.cs2)\n                C = C.at[..., 13].set(Fz * self.lattice.cs2)\n                C = C.at[..., 14].set(Fy * self.lattice.cs2)\n                C = C.at[..., 15].set(Fz * self.lattice.cs2)\n                C = C.at[..., 23].set(Fx * self.lattice.cs**4)\n                C = C.at[..., 24].set(Fy * self.lattice.cs**4)\n                C = C.at[..., 25].set(Fz * self.lattice.cs**4)\n\n                return C\n\n        return map(lambda F, sigma, psi, s_b: f(F, sigma, psi, s_b), F_tree, self.sigma, psi_tree, self.s_b)\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, Tdash_tree, rho_tree, u_tree):\n        \"\"\"\n        Modified version of the apply_force defined in LBMBase to account for modified force.\n\n        Parameters\n        ----------\n        Tdash_tree (pytree of jax.numpy.ndarray): Central moments of post-collision distribution functions.\n\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field.\n\n        Returns\n        -------\n        f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution functions with the force applied.\n        \"\"\"\n        F_tree = self.compute_force(rho_tree)\n        psi_tree, _ = self.compute_potential(rho_tree)\n        C_tree = self.compute_force_central_moments(F_tree, psi_tree)\n        Tf_tree = map(lambda S, C: jnp.dot(C, jnp.eye(self.lattice.q) - 0.5 * S), self.S, C_tree)\n        return map(lambda Tdash, Tf: Tdash + Tf, Tdash_tree, Tf_tree)\n\n    # @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    # def collision(self, fin_tree):\n    #     \"\"\"\n    #     Cascaded LBM collision step for lattice.\n    #     \"\"\"\n    #     fin_tree = map(lambda f: self.precisionPolicy.cast_to_compute(f), fin_tree)\n    #     rho_tree, u_tree = self.update_macroscopic(fin_tree)\n    #     T_tree = map(lambda f, M: jnp.dot(f, M), fin_tree, self.M)\n    #     N_tree = self.compute_shift_matrix(u_tree)\n    #     Tdash_tree = self.compute_central_moment(T_tree, N_tree)\n    #     Tdash_eq_tree = self.compute_eq_central_moments(rho_tree)\n    #     Tout_tree = map(\n    #         lambda Tdash, Tdash_eq, S: -jnp.dot(Tdash - Tdash_eq, S),\n    #         Tdash_tree,\n    #         Tdash_eq_tree,\n    #         self.S,\n    #     )\n    #     Tout_tree = self.apply_force(Tout_tree, Tdash_eq_tree, rho_tree, u_tree)\n    #     Ninv_tree = self.compute_shift_matrix_inverse(u_tree)\n    #     Tout_tree = self.compute_central_moment(Tout_tree, Ninv_tree)\n    #     fout_tree = map(\n    #         lambda fin, T, Minv: fin + jnp.dot(T, Minv), fin_tree, Tout_tree, self.M_inv\n    #     )\n    #     return map(\n    #         lambda fout: self.precisionPolicy.cast_to_output(fout),\n    #         fout_tree,\n    #     )\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin_tree):\n        \"\"\"\n        Cascaded LBM collision step for lattice.\n        \"\"\"\n        fin_tree = map(lambda f: self.precisionPolicy.cast_to_compute(f), fin_tree)\n        rho_tree, _ = self.update_macroscopic(fin_tree)\n        u_tree = self.macroscopic_velocity(fin_tree, rho_tree)\n        T_tree = map(lambda f, M: jnp.dot(f, M), fin_tree, self.M)\n        Tdash_tree = self.compute_central_moment(T_tree, u_tree)\n        Tdash_eq_tree = self.compute_eq_central_moments(rho_tree)\n        Tout_tree = map(\n            lambda Tdash, Tdash_eq, S: jnp.dot(Tdash, jnp.eye(self.lattice.q) - S) + jnp.dot(Tdash_eq, S), Tdash_tree, Tdash_eq_tree, self.S\n        )\n        Tout_tree = self.apply_force(Tout_tree, rho_tree, u_tree)\n        Tout_tree = self.compute_central_moment_inverse(Tout_tree, u_tree)\n        fout_tree = map(lambda T, Minv: jnp.dot(T, Minv), Tout_tree, self.M_inv)\n        return map(lambda fout: self.precisionPolicy.cast_to_output(fout), fout_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase--parameters","title":"Parameters","text":"<p>k (list): Modification coefficient, used to tune surface tension.</p> <p>A (numpy.ndarray): Weighting factor, used for linear combination of Shan-Chen and Zhang-Chen Forces</p> <p>g_kk (numpy.ndarray): Inter component interaction strength. Its a matrix of size n_components x n_components. It must be symmetric.</p>"},{"location":"multiphase/#src.multiphase.Multiphase--references","title":"References","text":"<ol> <li> <p>Shan, Xiaowen, and Hudong Chen. \u201cLattice Boltzmann Model for Simulating Flows with Multiple Phases and Components.\u201d     Physical Review E 47, no. 3 (March 1, 1993): 1815-19. https://doi.org/10.1103/PhysRevE.47.1815.</p> </li> <li> <p>Yuan, Peng, and Laura Schaefer. \u201cEquations of State in a Lattice Boltzmann Model.\u201d     Physics of Fluids 18, no. 4 (April 3, 2006): 042101. https://doi.org/10.1063/1.2187070.</p> </li> </ol>"},{"location":"multiphase/#src.multiphase.Multiphase--notes","title":"Notes","text":"<ol> <li>The boundary conditions for each component is handeled separately. For example a wall BC for two-component system must be defined twice, once for each component (see examples for details).</li> <li>Pytrees store component-specific values; order is as defined in initialize_macroscopic_fields by the user.</li> <li>Length of pytrees is equal to the no of components in the system.</li> <li>All component-specific values passed as a list or an array by the user must be set according to the sequence defined in the initialize_macroscopic_fields.</li> </ol> Source code in <code>src/multiphase.py</code> <pre><code>class Multiphase(LBMBase):\n    \"\"\"\n    Multiphase model, based on the Shan-Chen method. To model the fluid, an equation of state (EOS) is defined by the user.\n    Sequence of computation is pressure (EOS, dependent on the density and temperature) --&gt; effective mass (phi).\n    Can model both single component multiphase (SCMP) and multi-component multiphase (MCMP).\n\n    Parameters\n    ----------\n    k (list): Modification coefficient, used to tune surface tension.\n\n    A (numpy.ndarray): Weighting factor, used for linear combination of Shan-Chen and Zhang-Chen Forces\n\n    g_kk (numpy.ndarray): Inter component interaction strength. Its a matrix of size n_components x n_components. It must be symmetric.\n\n    References\n    ----------\n    1. Shan, Xiaowen, and Hudong Chen. \u201cLattice Boltzmann Model for Simulating Flows with Multiple Phases and Components.\u201d\n        Physical Review E 47, no. 3 (March 1, 1993): 1815-19. https://doi.org/10.1103/PhysRevE.47.1815.\n\n    2. Yuan, Peng, and Laura Schaefer. \u201cEquations of State in a Lattice Boltzmann Model.\u201d\n        Physics of Fluids 18, no. 4 (April 3, 2006): 042101. https://doi.org/10.1063/1.2187070.\n\n    Notes\n    -----\n    1. The boundary conditions for each component is handeled separately. For example a wall BC for two-component system must be\n    defined twice, once for each component (see examples for details).\n    2. Pytrees store component-specific values; order is as defined in initialize_macroscopic_fields by the user.\n    2. Length of pytrees is equal to the no of components in the system.\n    3. All component-specific values passed as a list or an array by the user must be set according to the sequence defined in the initialize_macroscopic_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.n_components = kwargs.get(\"n_components\")\n        super().__init__(**kwargs)\n        self.k = kwargs.get(\"k\")\n        self.A = kwargs.get(\"A\")\n        self.eos = kwargs.get(\"EOS\", None)\n        self.g_kkprime = kwargs.get(\"g_kkprime\")  # Fluid-fluid interaction strength\n        # self.g_ks = kwargs.get(\"g_ks\")  # Fluid-solid interaction strength\n        self.body_force = kwargs.get(\"body_force\", None)\n\n        self.G_ff = self.compute_ff_greens_function()\n        # self.G_fs = self.compute_fs_greens_function()\n\n        # self.omega = jnp.array(self.omega, dtype=self.precisionPolicy.compute_dtype)\n        self.g_kkprime = jnp.array(self.g_kkprime, dtype=self.precisionPolicy.compute_dtype)\n\n        self.solid_mask_streamed = self.get_solid_mask_streamed()\n\n    @property\n    def omega(self):\n        return self._omega\n\n    @omega.setter\n    def omega(self, value):\n        if not isinstance(value, list):\n            raise ValueError(\"omega must be a list\")\n        self._omega = value\n\n    @property\n    def n_components(self):\n        return self._n_components\n\n    @n_components.setter\n    def n_components(self, value):\n        if value is None:\n            raise ValueError(\"Number of components cannot be None\")\n        if value &lt;= 0:\n            raise ValueError(\"Number of components must be positive\")\n        if not isinstance(value, int):\n            raise ValueError(\"Number of components must be an integer\")\n        self._n_components = value\n\n    @property\n    def k(self):\n        return self._k\n\n    @k.setter\n    def k(self, value):\n        if value is None:\n            raise ValueError(\"Modification coefficient must be provided\")\n        if isinstance(value, float) or isinstance(value, int):\n            if self.n_components != 1:\n                raise ValueError(\"The number of modification coefficients provided does not match the number of components in the system\")\n            self._k = [value]\n        elif isinstance(value, list):\n            if len(value) != self.n_components:\n                raise ValueError(\"The number of modification coefficients provided does not match the number of components in the system\")\n        self._k = value\n\n    @property\n    def A(self):\n        return self._A\n\n    @A.setter\n    def A(self, value):\n        if value is None:\n            raise ValueError(\"Weight coefficient value must be provided\")\n        if isinstance(value, np.ndarray):\n            if value.shape != (self.n_components, self.n_components):\n                raise ValueError(\"The dimensions of A should match the number of components\")\n        self._A = jnp.array(value, dtype=self.precisionPolicy.compute_dtype)\n\n    @property\n    def body_force(self):\n        return self._body_force\n\n    @body_force.setter\n    def body_force(self, value):\n        if value is None:\n            self._body_force = None\n        if isinstance(value, list):\n            self._body_force = jnp.array(np.array(value), dtype=self.precisionPolicy.compute_dtype)\n        if isinstance(value, np.ndarray):\n            self._body_force = jnp.array(value, dtype=self.precisionPolicy.compute_dtype)\n\n    @property\n    def g_kkprime(self):\n        return self._g_kkprime\n\n    @g_kkprime.setter\n    def g_kkprime(self, value):\n        if not isinstance(value, np.ndarray) and not isinstance(value, jax.numpy.ndarray):\n            raise ValueError(\"g_kkprime must be a numpy array or jax.numpy.ndarray\")\n        if value.shape != (self.n_components, self.n_components):\n            raise ValueError(\"g_kkprime must be a matrix of size n_components x n_components\")\n        if not np.allclose(value, np.transpose(value), atol=1e-6):\n            raise ValueError(\"g_kkprime must be a symmetric matrix\")\n        self._g_kkprime = np.array(value)\n\n    # @property\n    # def g_ks(self):\n    #     return self._g_ks\n    #\n    # @g_ks.setter\n    # def g_ks(self, value):\n    #     if len(value) != self.n_components:\n    #         raise ValueError(\"g_ks must be a list size n_components\")\n    #     if isinstance(value, np.ndarray):\n    #         value = self.distributed_array_init(\n    #             value.shape, self.precisionPolicy.compute_dtype, value\n    #         )\n    #     self._g_ks = value\n\n    def get_solid_mask_streamed(self):\n        \"\"\"\n        Define the solid mask used for fluid-solid interaction force. The boundary conditions must be passed separately.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        solid_mask array: (numpy.ndarray) Dimension: (nx, ny, 1) for d == 2 and (nx, ny, nz, 1) for d == 3\n        \"\"\"\n        # solid_indices = []\n        # for i in range(self.n_components):\n        #     for bc in self.BCs[i]:\n        #         if (\n        #             isinstance(bc, BounceBack)\n        #             or isinstance(bc, BounceBackHalfway)\n        #             or isinstance(bc, BounceBackMoving)\n        #         ):\n        #             solid_indices.append(np.array(bc.indices).T)\n        # solid_index = None\n        # if not len(solid_indices) == 0:\n        #     solid_index = np.vstack(solid_indices)\n        # if self.dim == 2:\n        #     shape = (self.nx, self.ny, 1)\n        #     solid_mask = jnp.zeros(shape, dtype=jnp.int8)\n        #     if solid_index is not None:\n        #         solid_mask = solid_mask.at[solid_index[:, 0], solid_index[:, 1], 0].set(\n        #             1\n        #         )\n        # else:\n        #     shape = (self.nx, self.ny, self.nz, 1)\n        #     solid_mask = jnp.zeros(shape, dtype=jnp.int8)\n        #     if solid_index is not None:\n        #         solid_mask = solid_mask.at[\n        #             solid_index[:, 0], solid_index[:, 1], solid_index[:, 2], 0\n        #         ].set(1)\n        # return self.streaming(\n        #     jnp.repeat(\n        #         solid_mask,\n        #         axis=-1,\n        #         repeats=self.q,\n        #     )\n        # )\n        solid_mask = []\n        solid_indices = [[] for i in range(self.n_components)]\n        for i in range(self.n_components):\n            for bc in self.BCs[i]:\n                if isinstance(bc, BounceBack) or isinstance(bc, BounceBackHalfway) or isinstance(bc, BounceBackMoving):\n                    solid_indices[i].append(np.array(bc.indices).T)\n        for i in range(self.n_components):\n            index = None\n            if not len(solid_indices[i]) == 0:\n                index = np.vstack(solid_indices[i])\n            if self.dim == 2:\n                shape = (self.nx, self.ny, 1)\n                mask = jnp.zeros(shape, dtype=jnp.int8)\n                if index is not None:\n                    mask = mask.at[index[:, 0], index[:, 1], 0].set(1)\n                mask = self.streaming(jnp.repeat(mask, axis=-1, repeats=self.q))\n                solid_mask.append(mask)\n            else:\n                shape = (self.nx, self.ny, self.nz, 1)\n                mask = jnp.zeros(shape, dtype=jnp.int8)\n                if index is not None:\n                    mask = mask.at[index[:, 0], index[:, 1], index[:, 2], 0].set(1)\n                mask = self.streaming(jnp.repeat(mask, axis=-1, repeats=self.q))\n                solid_mask.append(mask)\n        return solid_mask\n\n    def _create_boundary_data(self):\n        \"\"\"\n        Create boundary data for the Lattice Boltzmann simulation by setting boundary conditions,\n        creating grid mask, and preparing local masks and normal arrays.\n        \"\"\"\n        self.BCs = [[] for _ in range(self.n_components)]\n        self.set_boundary_conditions()\n        # Accumulate the indices of all BCs to create the grid mask with FALSE along directions that\n        # stream into a boundary voxel.\n        for i in range(self.n_components):\n            print(f\"Component: {i + 1}\")\n            solid_halo_list = [np.array(bc.indices).T for bc in self.BCs[i] if bc.isSolid]\n            solid_halo_voxels = np.unique(np.vstack(solid_halo_list), axis=0) if solid_halo_list else None\n\n            # Create the grid mask on each process\n            start = time.time()\n            grid_mask = self.create_grid_mask(solid_halo_voxels)\n            print(\"Time to create the grid mask:\", time.time() - start)\n\n            start = time.time()\n            for bc in self.BCs[i]:\n                assert bc.implementationStep in [\"PostStreaming\", \"PostCollision\"]\n                bc.create_local_mask_and_normal_arrays(grid_mask)\n            print(\"Time to create the local masks and normal arrays:\", time.time() - start)\n\n    @partial(jit, static_argnums=(0, 3), inline=True)\n    def equilibrium(self, rho_tree, u_tree, cast_output=True):\n        \"\"\"\n        Compute the equillibrium distribution function using the given density and velocity pytrees.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field\n\n        cast_output (bool, optional): A flag to cast the density and velocity values to the compute and output precision. Default: True\n\n        Returns\n        -------\n        feq_tree (pytree of jax.numpy.ndarray): Equillibrium distribution\n        \"\"\"\n        if cast_output:\n            cast = lambda x: self.precisionPolicy.cast_to_compute(x)\n            rho_tree = map(cast, rho_tree)\n            u_tree = map(cast, u_tree)\n\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n        cu_tree = map(lambda u: 3.0 * jnp.dot(u, c), u_tree)\n        usqr_tree = map(lambda u: 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True), u_tree)\n        feq_tree = map(lambda rho, udote, udotu: rho * self.w * (1.0 + udote * (1.0 + 0.5 * udote) - udotu), rho_tree, cu_tree, usqr_tree)\n\n        if cast_output:\n            return map(lambda f_eq: self.precisionPolicy.cast_to_output(f_eq), feq_tree)\n        else:\n            return feq_tree\n\n    @partial(jit, static_argnums=(0,))\n    def compute_average_density(self, rho_tree):\n        rho_s_tree = map(lambda rho: self.streaming(jnp.repeat(rho, axis=-1, repeats=self.lattice.q)), rho_tree)\n        rho_ave_tree = map(\n            lambda rho_s, solid_mask: (\n                jnp.sum(self.G_ff * rho_s * (1 - solid_mask), axis=-1, keepdims=True) / jnp.sum(self.G_ff * (1 - solid_mask), axis=-1, keepdims=True)\n            ),\n            rho_s_tree,\n            self.solid_mask_streamed,\n        )\n        return rho_ave_tree\n\n    @partial(jit, static_argnums=(0,))\n    def apply_contact_angle(self, rho_tree):\n        \"\"\"\n        Apply the prescribed contact angle to density. The control parameters for this scheme are\n        self.theta_tree, self.phi_tree and self.delta_rho_tree. The max and min density fields are identified from initial configuration.\n        By default, any wall boundary condition can accept optional wettability parameters. By default, these parameters are None.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        Returns\n        -------\n        (pytree of jax.numpy.ndarray) Density field with adjusted contact angle values at the boundary nodes.\n\n        Reference:\n        ---------\n        1. Li, Q., Yu, Y. &amp; Luo, K. H. \"Implementation of contact angles in pseudopotential lattice Boltzmann simulations with\n        curved boundaries.\" Phys. Rev. E 100, 053313 (2019).\n        \"\"\"\n        rho_ave_tree = self.compute_average_density(rho_tree)\n\n        def set_contact_angle(rho, rho_ave, BC):\n            rho_min = jnp.min(rho)\n            rho_max = jnp.max(rho)\n            for bc in BC:\n                if isinstance(\n                    bc,\n                    (\n                        BounceBackHalfway,\n                        BounceBack,\n                        BounceBackMoving,\n                        InterpolatedBounceBackBouzidi,\n                        InterpolatedBounceBackDifferentiable,\n                    ),\n                ):\n                    if bc.theta is not None:\n                        rho = rho.at[bc.indices].set(\n                            (bc.theta &lt;= jnp.pi / 2) * (bc.phi * rho_ave[bc.indices]) + (bc.theta &gt; jnp.pi / 2) * (rho_ave[bc.indices] - bc.delta_rho)\n                        )\n                    rho = jnp.clip(rho, min=rho_min, max=rho_max)\n            return rho\n\n        return map(lambda rho, rho_ave, BC: set_contact_angle(rho, rho_ave, BC), rho_tree, rho_ave_tree, self.BCs)\n\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def collision(self, fin_tree):\n        \"\"\"\n        Apply collision step of LBM\n        \"\"\"\n        pass\n\n    def compute_ff_greens_function(self):\n        \"\"\"\n        Define the fluid-fluid interaction force Green's function used to compute interaction phase-phase interaction forces.\n\n        The interaction coefficient between k^th and kprime^th component: self.gkkprime[k, kprime]\n        During computation, this value is multiplied with corresponding g_kkprime value to get the Green's function:\n        G_kkprime = self.g_kk[k, k_prime] * self.G_ff\n\n        G_kkprime(x, x') = g1 * g_kkprime,  if |x - x'| = 1\n                         = g2 * g_kkprime,  if |x - x'| = sqrt(2)\n                         = 0,               otherwise\n\n        Here d is the dimension of problem and x' are the neighboring points.\n\n        Some examples values could be:\n        For D2Q9:\n            g1 = 1/3 and g2 = 1/12\n        For D3Q19\n            g1 = 1/6 and g2 = 1/12\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        G_ff (jax.numpy.ndarray): Dimension: (q, )\n        \"\"\"\n        c = np.array(self.lattice.c).T\n        G_ff = np.zeros((self.q,), dtype=np.float64)\n        cl = np.linalg.norm(c, axis=-1)\n        if isinstance(self.lattice, LatticeD2Q9):\n            g1 = 1 / 3\n            g2 = 1 / 12\n            G_ff[np.isclose(cl, 1.0, atol=1e-6)] = g1\n            G_ff[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n        elif isinstance(self.lattice, LatticeD3Q19):\n            g1 = 1 / 6\n            g2 = 1 / 12\n            G_ff[np.isclose(cl, 1.0, atol=1e-6)] = g1\n            G_ff[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n        else:\n            raise NotImplementedError(\"Please define Green's function for D3Q27 lattice by modifying compute_ff_greens_function.\")\n        return jnp.array(G_ff, dtype=self.precisionPolicy.compute_dtype)\n\n    # def compute_fs_greens_function(self):\n    #     \"\"\"\n    #     Define the Green's function used to model interaction between kth fluid and solid.\n    #\n    #     During computation, this G_fs is multiplied with corresponding g_ks value to get the Green's function:\n    #     G_ks = self.g_ks[k] * self.G_fs\n    #\n    #     Green's function used in this case:\n    #     G_ks(x, x') = g1 * g_ks,       if |x - x'| = 1\n    #                 = g2 * g_ks,       if |x - x'| = sqrt(2)\n    #                 = 0,               otherwise\n    #\n    #     Here d is the dimension of problem and x' are the neighboring points.\n    #     For D2Q9:\n    #         g1 = 2 and g2 = 1/2\n    #     For D3Q19\n    #         g1 = 1 and g2 = 1/2\n    #\n    #     Parameters\n    #     ----------\n    #     None\n    #\n    #     Returns\n    #     -------\n    #     G_fs: jax.numpy.ndarray\n    #         Dimension: (q, )\n    #     \"\"\"\n    #     c = np.array(self.lattice.c).T\n    #     cl = np.linalg.norm(c, axis=-1)\n    #     G_fs = np.zeros((self.q,), dtype=np.float64)\n    #     if isinstance(self.lattice, LatticeD2Q9):\n    #         g1 = 1 / 3\n    #         g2 = 1 / 12\n    #         G_fs[np.isclose(cl, 1.0, atol=1e-6)] = g1\n    #         G_fs[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n    #     elif isinstance(self.lattice, LatticeD3Q19):\n    #         g1 = 1 / 6\n    #         g2 = 1 / 12\n    #         G_fs[np.isclose(cl, 1.0, atol=1e-6)] = g1\n    #         G_fs[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n    #     return jnp.array(G_fs, dtype=self.precisionPolicy.compute_dtype)\n\n    def assign_fields_sharded(self):\n        \"\"\"\n        This function is used to initialize pytree of the distribution arrays using the initial velocities and velocity defined in self.initialize_macroscopic_fields function.\n        To do this, function first uses the initialize_macroscopic_fields function to get the initial values of rho (rho0) and velocity (u0).\n\n        If this function is not modified then, the distribution pytree is initialized with density value of 1.0 everywhere and velocity of 0.0 everywhere\n\n        The distribution is initialized with rho0 and u0 values, using the self.equilibrium function.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        f: pytree of distributed JAX array of shape: (self.nx, self.ny, self.q) for 2D and (self.nx, self.ny, self.nz, self.q) for 3D.\n        \"\"\"\n        rho0_tree, u0_tree = self.initialize_macroscopic_fields()\n        if self.dim == 2:\n            shape = (self.nx, self.ny, self.q)\n        if self.dim == 3:\n            shape = (self.nx, self.ny, self.nz, self.q)\n        f_tree = []\n        if rho0_tree is not None and u0_tree is not None:\n            assert len(rho0_tree) == self.n_components, \"The initial density values for all components must be provided\"\n\n            assert len(u0_tree) == self.n_components, \"The initial velocity values for all components must be provided.\"\n\n            for i in range(self.n_components):\n                rho0, u0 = rho0_tree[i], u0_tree[i]\n                rho0 = self.precisionPolicy.cast_to_compute(rho0)\n                u0 = self.precisionPolicy.cast_to_compute(u0)\n                f_tree.append(self.initialize_populations(rho0, u0))\n        else:\n            for i in range(self.n_components):\n                f_tree.append(self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w))\n        return f_tree\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def update_macroscopic(self, f_tree):\n        \"\"\"\n        update_macroscopic from base.py extended to pytrees.\n\n        Parameters\n        ----------\n        f_tree (pytree of jax.numpy.ndarray): Distribution field.\n\n        Returns\n        -------\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n        u_tree (pytree of jax.numpy.ndarray): Velocity field.\n        \"\"\"\n        rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        u_tree = map(lambda f, rho: jnp.dot(f, c) / rho, f_tree, rho_tree)  # Component velocity\n        return rho_tree, u_tree\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def macroscopic_velocity(self, f_tree, rho_tree):\n        \"\"\"\n        macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models\n        and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.\n\n        Parameters\n        ----------\n        f_tree (pytree of jax.numpy.ndarray): Distribution field.\n\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        Returns\n        -------\n        u_tree (pytree of jax.numpy.ndarray): Velocity field.\n        \"\"\"\n        # rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        u_tree = map(lambda f, rho: jnp.dot(f, c) / rho, f_tree, rho_tree)\n        F_tree = self.compute_force(rho_tree)\n        return map(lambda rho, u, F: u + 0.5 * F / rho, rho_tree, u_tree, F_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_total_density(self, rho_tree):\n        \"\"\"\n        Compute the total density using component velocity and density values.\n\n        Parmeters\n        ---------\n        rho_tree (Pytree of jax.numpy.ndarray): Density field.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): Total density field.\n        \"\"\"\n        return reduce(operator.add, rho_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_total_velocity(self, rho_tree, u_tree):\n        \"\"\"\n        Compute the total velocity using component velocity and density values.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field\n\n        Returns\n        -------\n        (jax.numpy.ndarray): Total velocity field.\n        \"\"\"\n        n = reduce(operator.add, map(lambda rho, u: rho * u, rho_tree, u_tree))\n        d = reduce(operator.add, rho_tree)\n        return n / d\n\n    @partial(jit, static_argnums=(0,))\n    def compute_pressure(self, rho_tree, psi_tree=None):\n        \"\"\"\n        Generalized function for computing pressure. By default it uses equation\n        of state but it can be modified if the pseudopotential is computed using\n        a different method.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.\n\n        Returns\n        -------\n        (pytree of jax.numpy.ndarray): Pressure field.\n        \"\"\"\n        return self.eos.EOS(rho_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_total_pressure(self, p_tree, rho_tree=None):\n        \"\"\"\n        Compute the total combined pressure from all components.\n\n        Parameters\n        ----------\n        p_tree (pytree of jax.numpy.ndarray): Pressure field.\n\n        rho_tree (pytree of jax.numpy.ndarray, default=None): Density field.\n\n        Returns\n        -------\n        (jax.numpy.ndarray): Total pressure field.\n        \"\"\"\n        return reduce(operator.add, p_tree)\n\n    @partial(jit, static_argnums=(0,))\n    def compute_potential(self, rho_tree):\n        \"\"\"\n        Compute the potential (psi and U) which is required for computing interaction forces.\n        The psi values are obtained using the corresponding EOS. This function can be overloaded to handle cases where one or more component does not\n        have EOS.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        Returns\n        -------\n        psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.\n        \"\"\"\n        rho_tree = map(lambda rho: self.precisionPolicy.cast_to_compute(rho), rho_tree)\n        p_tree = self.compute_pressure(rho_tree)\n        # Shan-Chen potential using modified pressure\n        psi_tree = map(\n            lambda k, p, rho, G: jnp.sqrt(2 * (k * p - self.lattice.cs2 * rho) / G), self.k, p_tree, rho_tree, self.g_kkprime.diagonal().tolist()\n        )\n        # Zhang-Chen potential\n        U_tree = map(lambda k, p, rho: k * p - self.lattice.cs2 * rho, self.k, p_tree, rho_tree)\n        return psi_tree, U_tree\n\n    # Compute the force using the effective mass (psi) and the interaction potential (phi)\n    @partial(jit, static_argnums=(0,), donate_argnums=(1,))\n    def compute_force(self, rho_tree):\n        \"\"\"\n        Compute the force acting on each component(fluid). This includes fluid-fluid, fluid-solid, and body forces.\n\n        Parameters\n        ----------\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        Returns\n        -------\n        fluid_fluid_force (pytree of jax.numpy.ndarray): Total force field.\n        \"\"\"\n        rho_tree = self.apply_contact_angle(rho_tree)\n        psi_tree, U_tree = self.compute_potential(rho_tree)\n        fluid_fluid_force = self.compute_fluid_fluid_force(psi_tree, U_tree)\n        # fluid_solid_force = self.compute_fluid_solid_force(rho_tree)\n        if self.body_force is not None:\n            return map(lambda ff, rho: ff + self.body_force * rho, fluid_fluid_force, rho_tree)\n        else:\n            return fluid_fluid_force\n\n    @partial(jit, static_argnums=(0,))\n    def compute_fluid_fluid_force(self, psi_tree, U_tree):\n        \"\"\"\n        Compute the fluid-fluid interaction force using the effective mass (psi).\n        The force calculation is based on the Shan-Chen method using the weighted sum\n        of Shan-Chen and Zhang-Chen potential where modified pressure is used:\n\n        modified pressure = k * pressure;\n        k is defined by user. Set k=1 for default pseudopotential formulation.\n\n        Parameters\n        ----------\n        psi_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Yuan-Schaefer, with modification)\n\n        U_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Zhang-Chen, with modification)\n\n        Returns\n        -------\n        (pytree of jax.numpy.ndarray): Fluid-fluid interaction forces.\n        \"\"\"\n        c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n        psi_s_tree = map(lambda psi: self.streaming(jnp.repeat(psi, axis=-1, repeats=self.q)), psi_tree)\n        U_s_tree = map(lambda U: self.streaming(jnp.repeat(U, axis=-1, repeats=self.q)), U_tree)\n\n        def ffk_1(Ai, g_kkprime):\n            \"\"\"\n            Shan-Chen interaction force\n            g_kkprime is a row of self.gkkprime, as it represents the interaction between kth component with all components\n            \"\"\"\n            return reduce(operator.add, map(lambda A, G, psi_s: jnp.dot((1 - A) * G * self.G_ff * psi_s, c), list(Ai), list(g_kkprime), psi_s_tree))\n\n        def ffk_2(Ai):\n            \"\"\"\n            Zhang-Chen interaction force.\n            \"\"\"\n            return reduce(operator.add, map(lambda A, U_s: A * jnp.dot(self.G_ff * U_s, c), list(Ai), U_s_tree))\n\n        return map(\n            lambda psi, nt_1, nt_2: psi * nt_1 + nt_2,\n            psi_tree,\n            list(vmap(ffk_1, in_axes=(0, 0))(self.A, self.g_kkprime)),\n            list(vmap(ffk_2, in_axes=(0))(self.A)),\n        )\n\n    # @partial(jit, static_argnums=(0,))\n    # def compute_fluid_solid_force(self, rho_tree):\n    #     \"\"\"\n    #     Compute the fluid-fluid interaction force using the effective mass (psi).\n\n    #     Parameters\n    #     ----------\n    #     psi_tree: Pytree of jax.numpy.ndarray\n    #         Pytree of pseudopotential of all components.\n\n    #     Returns\n    #     -------\n    #     Pytree of jax.numpy.ndarray\n    #         Pytree of fluid-solid interaction force.\n    #     \"\"\"\n    #     return map(\n    #         lambda g_ks, rho, solid_mask: -g_ks\n    #         * rho\n    #         * jnp.dot(self.G_fs * solid_mask, self.c.T),\n    #         self.g_ks,\n    #         rho_tree,\n    #         self.solid_mask_streamed\n    #     )\n    # psi_tree, _ = self.compute_potential(rho_tree)\n    # psi_s_tree = map(lambda psi: self.streaming(jnp.repeat(psi, axis=-1, repeats=self.lattice.q)), psi_tree)\n    # return map(\n    #     lambda g_ks, psi, psi_s, solid_mask: -g_ks\n    #     * psi\n    #     * jnp.dot(self.G_fs * solid_mask * psi_s, self.c.T),\n    #     self.g_ks,\n    #     psi_tree,\n    #     psi_s_tree,\n    #     self.solid_mask_streamed\n    # )\n\n    @partial(jit, static_argnums=(0,), inline=True)\n    def apply_force(self, f_postcollision_tree, feq_tree, rho_tree, u_tree):\n        \"\"\"\n        Modified version of the apply_force defined in LBMBase to account for modified force.\n\n        Parameters\n        ----------\n        f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution field.\n\n        feq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution functions.\n\n        rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field.\n\n        Returns\n        -------\n        f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution field with the force applied.\n        \"\"\"\n        F_tree = self.compute_force(rho_tree)\n\n        u_temp_tree = map(lambda u, F, rho: u + F / rho, u_tree, F_tree, rho_tree)\n        feq_force_tree = self.equilibrium(rho_tree, u_temp_tree)\n        return map(lambda f_postcollision, feq_force, feq: f_postcollision + feq_force - feq, f_postcollision_tree, feq_force_tree, feq_tree)\n\n    @partial(jit, static_argnums=(0, 4), inline=True)\n    def apply_bc(self, fout_tree, fin_tree, timestep, implementation_step):\n        \"\"\"\n        This function extends apply_bc to pytrees.\n\n        Parameters\n        ----------\n        fout_tree (pytree of jax.numpy.ndarray): The post-collision or post-streaming distribution functions where bc needs to be applied.\n\n        fin_tree (pytree of jax.numpy.ndarray): The pre-collision or post-collision distribution functions.\n\n        implementation_step (str): The implementation step at which the boundary conditions should be applied.\n\n        Returns\n        -------\n        (pytree of jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.\n        \"\"\"\n\n        def _apply_bc_(fin, fout, bc):\n            fout = bc.prepare_populations(fout, fin, implementation_step)\n            if bc.implementationStep == implementation_step:\n                if bc.isDynamic:\n                    fout = bc.apply(fout, fin, timestep)\n                else:\n                    fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n            return fout\n\n        # for i in range(self.n_components):\n        #     for bc in self.BCs[i]:\n        #         fout_tree[i] = _apply_bc_(fin_tree[i], fout_tree[i], bc)\n        #\n        # return fout_tree\n\n        def __apply_bc__(fout, fin, BCs):\n            for bc in BCs:\n                fout = _apply_bc_(fin, fout, bc)\n            return fout\n\n        return map(lambda fout, fin, BCs: __apply_bc__(fout, fin, BCs), fout_tree, fin_tree, self.BCs)\n\n    @partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\n    def step(self, f_poststreaming_tree, timestep, return_fpost=False):\n        \"\"\"\n        This function performs a single step of the LBM simulation.\n\n        It first performs the collision step, which is the relaxation of the distribution functions\n        towards their equilibrium values. It then applies the respective boundary conditions to the\n        post-collision distribution functions.\n\n        The function then performs the streaming step, which is the propagation of the distribution\n        functions in the lattice. It then applies the respective boundary conditions to the post-streaming\n        distribution functions.\n\n        Parameters\n        ----------\n        fin_tree (pytree of jax.numpy.ndarray): Post-streaming distribution function.\n\n        timestep (int): Current timestep\n\n        return_fpost (bool): Return post-collision distribution function (pytree).\n\n        Returns\n        -------\n        f_poststreaming_tree (pytree of jax.numpy.ndarray): Post-streamed distribution function.\n\n        f_collision_tree (pytree of jax.numpy.ndarray {Optional}): Post-collision distribution function.\n        \"\"\"\n        f_postcollision_tree = self.collision(f_poststreaming_tree)\n        f_postcollision_tree = self.apply_bc(f_postcollision_tree, f_poststreaming_tree, timestep, \"PostCollision\")\n        f_poststreaming_tree = map(lambda f_postcollision: self.streaming(f_postcollision), f_postcollision_tree)\n        f_poststreaming_tree = self.apply_bc(f_poststreaming_tree, f_postcollision_tree, timestep, \"PostStreaming\")\n\n        if return_fpost:\n            return f_poststreaming_tree, f_postcollision_tree\n        else:\n            return f_poststreaming_tree, None\n\n    def run(self, t_max):\n        \"\"\"\n        This function runs the LBM simulation for a specified number of time steps.\n\n        It first initializes the distribution functions and then enters a loop where it performs the\n        simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n        The function can also print the progress of the simulation, save the simulation data, and\n        compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n        Parameters\n        ----------\n        t_max (int): The total number of time steps to run the simulation.\n\n        Returns\n        -------\n        f_tree (pytree of jax.numpy.ndarray): Distribution function after t_max timesteps.\n        \"\"\"\n        f_tree = self.assign_fields_sharded()\n        start_step = 0\n        if self.restore_checkpoint:\n            latest_step = self.mngr.latest_step()\n            if latest_step is not None:  # existing checkpoint present\n                # Assert that the checkpoint manager is not None\n                assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n                state = {}\n                c_name = lambda i: f\"component_{i}\"\n                for i in range(self.n_components):\n                    state[c_name(i)] = f_tree[i]\n                # shardings = jax.map(lambda x: x.sharding, f_tree)\n                # restore_args = orb.checkpoint_utils.construct_restore_args(\n                #     f_tree, shardings\n                # )\n                try:\n                    f_tree = self.mngr.restore(latest_step, args=orb.args.StandardRestore(state))\n                    print(f\"Restored checkpoint at step {latest_step}.\")\n                except ValueError:\n                    raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n                start_step = latest_step + 1\n                if not (t_max &gt; start_step):\n                    raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max  = {t_max}). Consider increasing t_max.\")\n\n        if self.computeMLUPS:\n            start = time.time()\n\n        # Loop over all time steps\n        for timestep in range(start_step, t_max + 1):\n            io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n            print_iter_flag = self.printInfoRate &gt; 0 and timestep % self.printInfoRate == 0\n            checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n            if io_flag:\n                # Update the macroscopic variables and save the previous values (for error computation)\n                rho_prev_tree, _ = self.update_macroscopic(f_tree)\n                u_prev_tree = self.macroscopic_velocity(f_tree, rho_prev_tree)\n                rho_prev_tree = map(\n                    lambda rho_prev: downsample_field(rho_prev, self.downsamplingFactor),\n                    rho_prev_tree,\n                )\n                psi_prev_tree, _ = self.compute_potential(rho_prev_tree)\n                p_prev_tree = self.compute_pressure(rho_prev_tree, psi_prev_tree)\n                p_prev_total = self.compute_total_pressure(p_prev_tree, rho_prev_tree)\n                p_prev_total = downsample_field(p_prev_total, self.downsamplingFactor)\n                u_prev_tree = map(\n                    lambda u_prev: downsample_field(u_prev, self.downsamplingFactor),\n                    u_prev_tree,\n                )\n                rho_total_prev = self.compute_total_density(rho_prev_tree)\n                u_total_prev = self.compute_total_velocity(rho_prev_tree, u_prev_tree)\n\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                p_prev_total = process_allgather(p_prev_total)\n                rho_prev_tree = map(lambda rho_prev: process_allgather(rho_prev), rho_prev_tree)\n                u_prev_tree = map(lambda u_prev: process_allgather(u_prev), u_prev_tree)\n                rho_total_prev = process_allgather(rho_total_prev)\n                u_total_prev = process_allgather(u_total_prev)\n\n            # Perform one time-step (collision, streaming, and boundary conditions)\n            f_tree, fstar_tree = self.step(f_tree, timestep)\n\n            # Print the progress of the simulation\n            if print_iter_flag:\n                print(\n                    colored(\"Timestep \", \"blue\")\n                    + colored(f\"{timestep}\", \"green\")\n                    + colored(\" of \", \"blue\")\n                    + colored(f\"{t_max}\", \"green\")\n                    + colored(\" completed\", \"blue\")\n                )\n\n            if io_flag:\n                # Save the simulation data\n                print(f\"Saving data at timestep {timestep}/{t_max}\")\n                rho_tree, _ = self.update_macroscopic(f_tree)\n                u_tree = self.macroscopic_velocity(f_tree, rho_tree)\n                psi_tree, _ = self.compute_potential(rho_tree)\n                p_tree = self.compute_pressure(rho_tree, psi_tree)\n                p_total = self.compute_total_pressure(p_tree, rho_tree)\n                p_total = downsample_field(p_total, self.downsamplingFactor)\n                rho_tree = map(\n                    lambda rho: downsample_field(rho, self.downsamplingFactor),\n                    rho_tree,\n                )\n                u_tree = map(lambda u: downsample_field(u, self.downsamplingFactor), u_tree)\n\n                rho_total = self.compute_total_density(rho_tree)\n                u_total = self.compute_total_velocity(rho_tree, u_tree)\n\n                # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n                p_total = process_allgather(p_total)\n                rho_tree = map(lambda rho: process_allgather(rho), rho_tree)\n                u_tree = map(lambda u: process_allgather(u), u_tree)\n                rho_total = process_allgather(rho_total)\n                u_total = process_allgather(u_total)\n\n                # Save the data\n                self.handle_io_timestep(\n                    timestep,\n                    f_tree,\n                    fstar_tree,\n                    p_tree,\n                    p_total,\n                    u_tree,\n                    u_total,\n                    rho_total,\n                    rho_tree,\n                    p_prev_tree,\n                    p_prev_total,\n                    u_total_prev,\n                    u_prev_tree,\n                    rho_total_prev,\n                    rho_prev_tree,\n                )\n\n            if checkpoint_flag:\n                # Save the checkpoint\n                print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n                state = {}\n                c_name = lambda i: f\"component_{i}\"\n                for i in range(self.n_components):\n                    state[c_name(i)] = f_tree[i]\n\n                self.mngr.save(timestep, args=orb.args.StandardSave(state))\n\n            # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n            if self.computeMLUPS and timestep == 1:\n                jax.block_until_ready(f_tree)\n                start = time.time()\n\n        if self.computeMLUPS:\n            # Compute and print the performance of the simulation in MLUPS\n            jax.block_until_ready(f_tree)\n            end = time.time()\n            if self.dim == 2:\n                print(\n                    colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny}\", \"green\")\n                    if self.dim == 2\n                    else colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\")\n                )\n                print(\n                    colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny}\", \"green\")\n                    if self.dim == 2\n                    else colored(f\"{self.nx * self.ny * self.nz}\", \"green\")\n                )\n                print(\n                    colored(\"MLUPS: \", \"blue\")\n                    + colored(\n                        f\"{self.n_components * self.nx * self.ny * t_max / (end - start) / 1e6}\",\n                        \"red\",\n                    )\n                )\n\n            elif self.dim == 3:\n                print(colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\"))\n                print(colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny * self.nz}\", \"green\"))\n                print(\n                    colored(\"MLUPS: \", \"blue\")\n                    + colored(\n                        f\"{self.n_components * self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\",\n                        \"red\",\n                    )\n                )\n        if self.mngr is not None:\n            self.mngr.wait_until_finished()\n        return f_tree\n\n    def handle_io_timestep(\n        self,\n        timestep,\n        f_tree,\n        fstar_tree,\n        p_tree,\n        p_total,\n        u_tree,\n        u_total,\n        rho_total,\n        rho_tree,\n        p_prev_tree,\n        p_prev_total,\n        u_total_prev,\n        u_prev_tree,\n        rho_total_prev,\n        rho_prev_tree,\n    ):\n        \"\"\"\n        This function handles the input/output (I/O) operations at each time step of the simulation.\n\n        It prepares the data to be saved and calls the output_data function, which can be overwritten\n        by the user to customize the I/O operations.\n\n        Parameters\n        ----------\n        timestep (int): The current time step of the simulation.\n\n        f_tree (pytree of jax.numpy.ndarray): Post-streaming distribution functions at the current time step.\n\n        fstar_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions at the current time step.\n\n        p_tree (pytree of jax.numpy.ndarray): Pressure field at the current time step.\n\n        p (jax.numpy.ndarray): Total pressure field at the current time step.\n\n        u_total (jax.numpy.ndarray): Total velocity field at the current time step.\n\n        u_tree (pytree of jax.numpy.ndarray): Velocity field at the current time step.\n\n        rho_total (jax.numpy.ndarray): Total density field at the current time step.\n\n        rho_tree (pytree of jax.numpy.ndarray): Density field at the current time step.\n\n        p_prev_tree (pytree of jax.numpy.ndarray): Pressure field at the previous time step.\n\n        p_prev (jax.numpy.ndarray): Total pressure field at the previous time step.\n\n        u_total_prev (jax.numpy.ndarray): Total velocity field at the previous time step.\n\n        u_prev_tree (pytree of jax.numpy.ndarray): Velocity field at the previous time step.\n\n        rho_total_prev (jax.numpy.ndarray): Total density field at the previous time step.\n\n        rho_prev_tree: (ytree of jax.numpy.ndarray): Density field at the previous time step.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        kwargs = {\n            \"n_components\": self.n_components,\n            \"timestep\": timestep,\n            \"rho_total\": rho_total,\n            \"rho_tree\": rho_tree,\n            \"p_tree\": p_tree,\n            \"p\": p_total,\n            \"u_total\": u_total,\n            \"u_tree\": u_tree,\n            \"rho_total_prev\": rho_total_prev,\n            \"rho_prev_tree\": rho_prev_tree,\n            \"p_prev_tree\": p_prev_tree,\n            \"p_prev\": p_prev_total,\n            \"u_total_prev\": u_total_prev,\n            \"u_prev_tree\": u_prev_tree,\n            \"f_poststreaming_tree\": f_tree,\n            \"f_postcollision_tree\": fstar_tree,\n        }\n        self.output_data(**kwargs)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_bc","title":"apply_bc","text":"<pre><code>apply_bc(fout_tree, fin_tree, timestep, implementation_step)\n</code></pre> <p>This function extends apply_bc to pytrees.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_bc--parameters","title":"Parameters","text":"<p>fout_tree (pytree of jax.numpy.ndarray): The post-collision or post-streaming distribution functions where bc needs to be applied.</p> <p>fin_tree (pytree of jax.numpy.ndarray): The pre-collision or post-collision distribution functions.</p> <p>implementation_step (str): The implementation step at which the boundary conditions should be applied.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_bc--returns","title":"Returns","text":"<p>(pytree of jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0, 4), inline=True)\ndef apply_bc(self, fout_tree, fin_tree, timestep, implementation_step):\n    \"\"\"\n    This function extends apply_bc to pytrees.\n\n    Parameters\n    ----------\n    fout_tree (pytree of jax.numpy.ndarray): The post-collision or post-streaming distribution functions where bc needs to be applied.\n\n    fin_tree (pytree of jax.numpy.ndarray): The pre-collision or post-collision distribution functions.\n\n    implementation_step (str): The implementation step at which the boundary conditions should be applied.\n\n    Returns\n    -------\n    (pytree of jax.numpy.ndarray): The output distribution functions after applying the boundary conditions.\n    \"\"\"\n\n    def _apply_bc_(fin, fout, bc):\n        fout = bc.prepare_populations(fout, fin, implementation_step)\n        if bc.implementationStep == implementation_step:\n            if bc.isDynamic:\n                fout = bc.apply(fout, fin, timestep)\n            else:\n                fout = fout.at[bc.indices].set(bc.apply(fout, fin))\n        return fout\n\n    # for i in range(self.n_components):\n    #     for bc in self.BCs[i]:\n    #         fout_tree[i] = _apply_bc_(fin_tree[i], fout_tree[i], bc)\n    #\n    # return fout_tree\n\n    def __apply_bc__(fout, fin, BCs):\n        for bc in BCs:\n            fout = _apply_bc_(fin, fout, bc)\n        return fout\n\n    return map(lambda fout, fin, BCs: __apply_bc__(fout, fin, BCs), fout_tree, fin_tree, self.BCs)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_contact_angle","title":"apply_contact_angle","text":"<pre><code>apply_contact_angle(rho_tree)\n</code></pre> <p>Apply the prescribed contact angle to density. The control parameters for this scheme are self.theta_tree, self.phi_tree and self.delta_rho_tree. The max and min density fields are identified from initial configuration. By default, any wall boundary condition can accept optional wettability parameters. By default, these parameters are None.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_contact_angle--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_contact_angle--returns","title":"Returns","text":"<p>(pytree of jax.numpy.ndarray) Density field with adjusted contact angle values at the boundary nodes.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_contact_angle--reference","title":"Reference:","text":"<ol> <li>Li, Q., Yu, Y. &amp; Luo, K. H. \u201cImplementation of contact angles in pseudopotential lattice Boltzmann simulations with curved boundaries.\u201d Phys. Rev. E 100, 053313 (2019).</li> </ol> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef apply_contact_angle(self, rho_tree):\n    \"\"\"\n    Apply the prescribed contact angle to density. The control parameters for this scheme are\n    self.theta_tree, self.phi_tree and self.delta_rho_tree. The max and min density fields are identified from initial configuration.\n    By default, any wall boundary condition can accept optional wettability parameters. By default, these parameters are None.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    Returns\n    -------\n    (pytree of jax.numpy.ndarray) Density field with adjusted contact angle values at the boundary nodes.\n\n    Reference:\n    ---------\n    1. Li, Q., Yu, Y. &amp; Luo, K. H. \"Implementation of contact angles in pseudopotential lattice Boltzmann simulations with\n    curved boundaries.\" Phys. Rev. E 100, 053313 (2019).\n    \"\"\"\n    rho_ave_tree = self.compute_average_density(rho_tree)\n\n    def set_contact_angle(rho, rho_ave, BC):\n        rho_min = jnp.min(rho)\n        rho_max = jnp.max(rho)\n        for bc in BC:\n            if isinstance(\n                bc,\n                (\n                    BounceBackHalfway,\n                    BounceBack,\n                    BounceBackMoving,\n                    InterpolatedBounceBackBouzidi,\n                    InterpolatedBounceBackDifferentiable,\n                ),\n            ):\n                if bc.theta is not None:\n                    rho = rho.at[bc.indices].set(\n                        (bc.theta &lt;= jnp.pi / 2) * (bc.phi * rho_ave[bc.indices]) + (bc.theta &gt; jnp.pi / 2) * (rho_ave[bc.indices] - bc.delta_rho)\n                    )\n                rho = jnp.clip(rho, min=rho_min, max=rho_max)\n        return rho\n\n    return map(lambda rho, rho_ave, BC: set_contact_angle(rho, rho_ave, BC), rho_tree, rho_ave_tree, self.BCs)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_force","title":"apply_force","text":"<pre><code>apply_force(f_postcollision_tree, feq_tree, rho_tree, u_tree)\n</code></pre> <p>Modified version of the apply_force defined in LBMBase to account for modified force.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_force--parameters","title":"Parameters","text":"<p>f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution field.</p> <p>feq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution functions.</p> <p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.apply_force--returns","title":"Returns","text":"<p>f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution field with the force applied.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, f_postcollision_tree, feq_tree, rho_tree, u_tree):\n    \"\"\"\n    Modified version of the apply_force defined in LBMBase to account for modified force.\n\n    Parameters\n    ----------\n    f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution field.\n\n    feq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution functions.\n\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field.\n\n    Returns\n    -------\n    f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution field with the force applied.\n    \"\"\"\n    F_tree = self.compute_force(rho_tree)\n\n    u_temp_tree = map(lambda u, F, rho: u + F / rho, u_tree, F_tree, rho_tree)\n    feq_force_tree = self.equilibrium(rho_tree, u_temp_tree)\n    return map(lambda f_postcollision, feq_force, feq: f_postcollision + feq_force - feq, f_postcollision_tree, feq_force_tree, feq_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.assign_fields_sharded","title":"assign_fields_sharded","text":"<pre><code>assign_fields_sharded()\n</code></pre> <p>This function is used to initialize pytree of the distribution arrays using the initial velocities and velocity defined in self.initialize_macroscopic_fields function. To do this, function first uses the initialize_macroscopic_fields function to get the initial values of rho (rho0) and velocity (u0).</p> <p>If this function is not modified then, the distribution pytree is initialized with density value of 1.0 everywhere and velocity of 0.0 everywhere</p> <p>The distribution is initialized with rho0 and u0 values, using the self.equilibrium function.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.assign_fields_sharded--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"multiphase/#src.multiphase.Multiphase.assign_fields_sharded--returns","title":"Returns","text":"<p>f: pytree of distributed JAX array of shape: (self.nx, self.ny, self.q) for 2D and (self.nx, self.ny, self.nz, self.q) for 3D.</p> Source code in <code>src/multiphase.py</code> <pre><code>def assign_fields_sharded(self):\n    \"\"\"\n    This function is used to initialize pytree of the distribution arrays using the initial velocities and velocity defined in self.initialize_macroscopic_fields function.\n    To do this, function first uses the initialize_macroscopic_fields function to get the initial values of rho (rho0) and velocity (u0).\n\n    If this function is not modified then, the distribution pytree is initialized with density value of 1.0 everywhere and velocity of 0.0 everywhere\n\n    The distribution is initialized with rho0 and u0 values, using the self.equilibrium function.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    f: pytree of distributed JAX array of shape: (self.nx, self.ny, self.q) for 2D and (self.nx, self.ny, self.nz, self.q) for 3D.\n    \"\"\"\n    rho0_tree, u0_tree = self.initialize_macroscopic_fields()\n    if self.dim == 2:\n        shape = (self.nx, self.ny, self.q)\n    if self.dim == 3:\n        shape = (self.nx, self.ny, self.nz, self.q)\n    f_tree = []\n    if rho0_tree is not None and u0_tree is not None:\n        assert len(rho0_tree) == self.n_components, \"The initial density values for all components must be provided\"\n\n        assert len(u0_tree) == self.n_components, \"The initial velocity values for all components must be provided.\"\n\n        for i in range(self.n_components):\n            rho0, u0 = rho0_tree[i], u0_tree[i]\n            rho0 = self.precisionPolicy.cast_to_compute(rho0)\n            u0 = self.precisionPolicy.cast_to_compute(u0)\n            f_tree.append(self.initialize_populations(rho0, u0))\n    else:\n        for i in range(self.n_components):\n            f_tree.append(self.distributed_array_init(shape, self.precisionPolicy.output_dtype, init_val=self.w))\n    return f_tree\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.collision","title":"collision","text":"<pre><code>collision(fin_tree)\n</code></pre> <p>Apply collision step of LBM</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin_tree):\n    \"\"\"\n    Apply collision step of LBM\n    \"\"\"\n    pass\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_ff_greens_function","title":"compute_ff_greens_function","text":"<pre><code>compute_ff_greens_function()\n</code></pre> <p>Define the fluid-fluid interaction force Green\u2019s function used to compute interaction phase-phase interaction forces.</p> <p>The interaction coefficient between k^th and kprime^th component: self.gkkprime[k, kprime] During computation, this value is multiplied with corresponding g_kkprime value to get the Green\u2019s function: G_kkprime = self.g_kk[k, k_prime] * self.G_ff</p> <p>G_kkprime(x, x\u2019) = g1 * g_kkprime,  if |x - x\u2019| = 1                  = g2 * g_kkprime,  if |x - x\u2019| = sqrt(2)                  = 0,               otherwise</p> <p>Here d is the dimension of problem and x\u2019 are the neighboring points.</p> <p>Some examples values could be: For D2Q9:     g1 = 1/3 and g2 = 1/12 For D3Q19     g1 = 1/6 and g2 = 1/12</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_ff_greens_function--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_ff_greens_function--returns","title":"Returns","text":"<p>G_ff (jax.numpy.ndarray): Dimension: (q, )</p> Source code in <code>src/multiphase.py</code> <pre><code>def compute_ff_greens_function(self):\n    \"\"\"\n    Define the fluid-fluid interaction force Green's function used to compute interaction phase-phase interaction forces.\n\n    The interaction coefficient between k^th and kprime^th component: self.gkkprime[k, kprime]\n    During computation, this value is multiplied with corresponding g_kkprime value to get the Green's function:\n    G_kkprime = self.g_kk[k, k_prime] * self.G_ff\n\n    G_kkprime(x, x') = g1 * g_kkprime,  if |x - x'| = 1\n                     = g2 * g_kkprime,  if |x - x'| = sqrt(2)\n                     = 0,               otherwise\n\n    Here d is the dimension of problem and x' are the neighboring points.\n\n    Some examples values could be:\n    For D2Q9:\n        g1 = 1/3 and g2 = 1/12\n    For D3Q19\n        g1 = 1/6 and g2 = 1/12\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    G_ff (jax.numpy.ndarray): Dimension: (q, )\n    \"\"\"\n    c = np.array(self.lattice.c).T\n    G_ff = np.zeros((self.q,), dtype=np.float64)\n    cl = np.linalg.norm(c, axis=-1)\n    if isinstance(self.lattice, LatticeD2Q9):\n        g1 = 1 / 3\n        g2 = 1 / 12\n        G_ff[np.isclose(cl, 1.0, atol=1e-6)] = g1\n        G_ff[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n    elif isinstance(self.lattice, LatticeD3Q19):\n        g1 = 1 / 6\n        g2 = 1 / 12\n        G_ff[np.isclose(cl, 1.0, atol=1e-6)] = g1\n        G_ff[np.isclose(cl, jnp.sqrt(2.0), atol=1e-6)] = g2\n    else:\n        raise NotImplementedError(\"Please define Green's function for D3Q27 lattice by modifying compute_ff_greens_function.\")\n    return jnp.array(G_ff, dtype=self.precisionPolicy.compute_dtype)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_fluid_fluid_force","title":"compute_fluid_fluid_force","text":"<pre><code>compute_fluid_fluid_force(psi_tree, U_tree)\n</code></pre> <p>Compute the fluid-fluid interaction force using the effective mass (psi). The force calculation is based on the Shan-Chen method using the weighted sum of Shan-Chen and Zhang-Chen potential where modified pressure is used:</p> <p>modified pressure = k * pressure; k is defined by user. Set k=1 for default pseudopotential formulation.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_fluid_fluid_force--parameters","title":"Parameters","text":"<p>psi_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Yuan-Schaefer, with modification)</p> <p>U_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Zhang-Chen, with modification)</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_fluid_fluid_force--returns","title":"Returns","text":"<p>(pytree of jax.numpy.ndarray): Fluid-fluid interaction forces.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_fluid_fluid_force(self, psi_tree, U_tree):\n    \"\"\"\n    Compute the fluid-fluid interaction force using the effective mass (psi).\n    The force calculation is based on the Shan-Chen method using the weighted sum\n    of Shan-Chen and Zhang-Chen potential where modified pressure is used:\n\n    modified pressure = k * pressure;\n    k is defined by user. Set k=1 for default pseudopotential formulation.\n\n    Parameters\n    ----------\n    psi_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Yuan-Schaefer, with modification)\n\n    U_tree (pytree of jax.numpy.ndarray): Pseudo-potential field (Zhang-Chen, with modification)\n\n    Returns\n    -------\n    (pytree of jax.numpy.ndarray): Fluid-fluid interaction forces.\n    \"\"\"\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    psi_s_tree = map(lambda psi: self.streaming(jnp.repeat(psi, axis=-1, repeats=self.q)), psi_tree)\n    U_s_tree = map(lambda U: self.streaming(jnp.repeat(U, axis=-1, repeats=self.q)), U_tree)\n\n    def ffk_1(Ai, g_kkprime):\n        \"\"\"\n        Shan-Chen interaction force\n        g_kkprime is a row of self.gkkprime, as it represents the interaction between kth component with all components\n        \"\"\"\n        return reduce(operator.add, map(lambda A, G, psi_s: jnp.dot((1 - A) * G * self.G_ff * psi_s, c), list(Ai), list(g_kkprime), psi_s_tree))\n\n    def ffk_2(Ai):\n        \"\"\"\n        Zhang-Chen interaction force.\n        \"\"\"\n        return reduce(operator.add, map(lambda A, U_s: A * jnp.dot(self.G_ff * U_s, c), list(Ai), U_s_tree))\n\n    return map(\n        lambda psi, nt_1, nt_2: psi * nt_1 + nt_2,\n        psi_tree,\n        list(vmap(ffk_1, in_axes=(0, 0))(self.A, self.g_kkprime)),\n        list(vmap(ffk_2, in_axes=(0))(self.A)),\n    )\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_force","title":"compute_force","text":"<pre><code>compute_force(rho_tree)\n</code></pre> <p>Compute the force acting on each component(fluid). This includes fluid-fluid, fluid-solid, and body forces.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_force--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_force--returns","title":"Returns","text":"<p>fluid_fluid_force (pytree of jax.numpy.ndarray): Total force field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef compute_force(self, rho_tree):\n    \"\"\"\n    Compute the force acting on each component(fluid). This includes fluid-fluid, fluid-solid, and body forces.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    Returns\n    -------\n    fluid_fluid_force (pytree of jax.numpy.ndarray): Total force field.\n    \"\"\"\n    rho_tree = self.apply_contact_angle(rho_tree)\n    psi_tree, U_tree = self.compute_potential(rho_tree)\n    fluid_fluid_force = self.compute_fluid_fluid_force(psi_tree, U_tree)\n    # fluid_solid_force = self.compute_fluid_solid_force(rho_tree)\n    if self.body_force is not None:\n        return map(lambda ff, rho: ff + self.body_force * rho, fluid_fluid_force, rho_tree)\n    else:\n        return fluid_fluid_force\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_potential","title":"compute_potential","text":"<pre><code>compute_potential(rho_tree)\n</code></pre> <p>Compute the potential (psi and U) which is required for computing interaction forces. The psi values are obtained using the corresponding EOS. This function can be overloaded to handle cases where one or more component does not have EOS.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_potential--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_potential--returns","title":"Returns","text":"<p>psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_potential(self, rho_tree):\n    \"\"\"\n    Compute the potential (psi and U) which is required for computing interaction forces.\n    The psi values are obtained using the corresponding EOS. This function can be overloaded to handle cases where one or more component does not\n    have EOS.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    Returns\n    -------\n    psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.\n    \"\"\"\n    rho_tree = map(lambda rho: self.precisionPolicy.cast_to_compute(rho), rho_tree)\n    p_tree = self.compute_pressure(rho_tree)\n    # Shan-Chen potential using modified pressure\n    psi_tree = map(\n        lambda k, p, rho, G: jnp.sqrt(2 * (k * p - self.lattice.cs2 * rho) / G), self.k, p_tree, rho_tree, self.g_kkprime.diagonal().tolist()\n    )\n    # Zhang-Chen potential\n    U_tree = map(lambda k, p, rho: k * p - self.lattice.cs2 * rho, self.k, p_tree, rho_tree)\n    return psi_tree, U_tree\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_pressure","title":"compute_pressure","text":"<pre><code>compute_pressure(rho_tree, psi_tree=None)\n</code></pre> <p>Generalized function for computing pressure. By default it uses equation of state but it can be modified if the pseudopotential is computed using a different method.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_pressure--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p> <p>psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_pressure--returns","title":"Returns","text":"<p>(pytree of jax.numpy.ndarray): Pressure field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_pressure(self, rho_tree, psi_tree=None):\n    \"\"\"\n    Generalized function for computing pressure. By default it uses equation\n    of state but it can be modified if the pseudopotential is computed using\n    a different method.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    psi_tree (pytree of jax.numpy.ndarray): Pseudopotential field.\n\n    Returns\n    -------\n    (pytree of jax.numpy.ndarray): Pressure field.\n    \"\"\"\n    return self.eos.EOS(rho_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_density","title":"compute_total_density","text":"<pre><code>compute_total_density(rho_tree)\n</code></pre> <p>Compute the total density using component velocity and density values.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_density--parmeters","title":"Parmeters","text":"<p>rho_tree (Pytree of jax.numpy.ndarray): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_density--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): Total density field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_total_density(self, rho_tree):\n    \"\"\"\n    Compute the total density using component velocity and density values.\n\n    Parmeters\n    ---------\n    rho_tree (Pytree of jax.numpy.ndarray): Density field.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): Total density field.\n    \"\"\"\n    return reduce(operator.add, rho_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_pressure","title":"compute_total_pressure","text":"<pre><code>compute_total_pressure(p_tree, rho_tree=None)\n</code></pre> <p>Compute the total combined pressure from all components.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_pressure--parameters","title":"Parameters","text":"<p>p_tree (pytree of jax.numpy.ndarray): Pressure field.</p> <p>rho_tree (pytree of jax.numpy.ndarray, default=None): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_pressure--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): Total pressure field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_total_pressure(self, p_tree, rho_tree=None):\n    \"\"\"\n    Compute the total combined pressure from all components.\n\n    Parameters\n    ----------\n    p_tree (pytree of jax.numpy.ndarray): Pressure field.\n\n    rho_tree (pytree of jax.numpy.ndarray, default=None): Density field.\n\n    Returns\n    -------\n    (jax.numpy.ndarray): Total pressure field.\n    \"\"\"\n    return reduce(operator.add, p_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_velocity","title":"compute_total_velocity","text":"<pre><code>compute_total_velocity(rho_tree, u_tree)\n</code></pre> <p>Compute the total velocity using component velocity and density values.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_velocity--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field</p>"},{"location":"multiphase/#src.multiphase.Multiphase.compute_total_velocity--returns","title":"Returns","text":"<p>(jax.numpy.ndarray): Total velocity field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_total_velocity(self, rho_tree, u_tree):\n    \"\"\"\n    Compute the total velocity using component velocity and density values.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field\n\n    Returns\n    -------\n    (jax.numpy.ndarray): Total velocity field.\n    \"\"\"\n    n = reduce(operator.add, map(lambda rho, u: rho * u, rho_tree, u_tree))\n    d = reduce(operator.add, rho_tree)\n    return n / d\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.equilibrium","title":"equilibrium","text":"<pre><code>equilibrium(rho_tree, u_tree, cast_output=True)\n</code></pre> <p>Compute the equillibrium distribution function using the given density and velocity pytrees.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.equilibrium--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field</p> <p>cast_output (bool, optional): A flag to cast the density and velocity values to the compute and output precision. Default: True</p>"},{"location":"multiphase/#src.multiphase.Multiphase.equilibrium--returns","title":"Returns","text":"<p>feq_tree (pytree of jax.numpy.ndarray): Equillibrium distribution</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), inline=True)\ndef equilibrium(self, rho_tree, u_tree, cast_output=True):\n    \"\"\"\n    Compute the equillibrium distribution function using the given density and velocity pytrees.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field\n\n    cast_output (bool, optional): A flag to cast the density and velocity values to the compute and output precision. Default: True\n\n    Returns\n    -------\n    feq_tree (pytree of jax.numpy.ndarray): Equillibrium distribution\n    \"\"\"\n    if cast_output:\n        cast = lambda x: self.precisionPolicy.cast_to_compute(x)\n        rho_tree = map(cast, rho_tree)\n        u_tree = map(cast, u_tree)\n\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype)\n    cu_tree = map(lambda u: 3.0 * jnp.dot(u, c), u_tree)\n    usqr_tree = map(lambda u: 1.5 * jnp.sum(jnp.square(u), axis=-1, keepdims=True), u_tree)\n    feq_tree = map(lambda rho, udote, udotu: rho * self.w * (1.0 + udote * (1.0 + 0.5 * udote) - udotu), rho_tree, cu_tree, usqr_tree)\n\n    if cast_output:\n        return map(lambda f_eq: self.precisionPolicy.cast_to_output(f_eq), feq_tree)\n    else:\n        return feq_tree\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.get_solid_mask_streamed","title":"get_solid_mask_streamed","text":"<pre><code>get_solid_mask_streamed()\n</code></pre> <p>Define the solid mask used for fluid-solid interaction force. The boundary conditions must be passed separately.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.get_solid_mask_streamed--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"multiphase/#src.multiphase.Multiphase.get_solid_mask_streamed--returns","title":"Returns","text":"<p>solid_mask array: (numpy.ndarray) Dimension: (nx, ny, 1) for d == 2 and (nx, ny, nz, 1) for d == 3</p> Source code in <code>src/multiphase.py</code> <pre><code>def get_solid_mask_streamed(self):\n    \"\"\"\n    Define the solid mask used for fluid-solid interaction force. The boundary conditions must be passed separately.\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    solid_mask array: (numpy.ndarray) Dimension: (nx, ny, 1) for d == 2 and (nx, ny, nz, 1) for d == 3\n    \"\"\"\n    # solid_indices = []\n    # for i in range(self.n_components):\n    #     for bc in self.BCs[i]:\n    #         if (\n    #             isinstance(bc, BounceBack)\n    #             or isinstance(bc, BounceBackHalfway)\n    #             or isinstance(bc, BounceBackMoving)\n    #         ):\n    #             solid_indices.append(np.array(bc.indices).T)\n    # solid_index = None\n    # if not len(solid_indices) == 0:\n    #     solid_index = np.vstack(solid_indices)\n    # if self.dim == 2:\n    #     shape = (self.nx, self.ny, 1)\n    #     solid_mask = jnp.zeros(shape, dtype=jnp.int8)\n    #     if solid_index is not None:\n    #         solid_mask = solid_mask.at[solid_index[:, 0], solid_index[:, 1], 0].set(\n    #             1\n    #         )\n    # else:\n    #     shape = (self.nx, self.ny, self.nz, 1)\n    #     solid_mask = jnp.zeros(shape, dtype=jnp.int8)\n    #     if solid_index is not None:\n    #         solid_mask = solid_mask.at[\n    #             solid_index[:, 0], solid_index[:, 1], solid_index[:, 2], 0\n    #         ].set(1)\n    # return self.streaming(\n    #     jnp.repeat(\n    #         solid_mask,\n    #         axis=-1,\n    #         repeats=self.q,\n    #     )\n    # )\n    solid_mask = []\n    solid_indices = [[] for i in range(self.n_components)]\n    for i in range(self.n_components):\n        for bc in self.BCs[i]:\n            if isinstance(bc, BounceBack) or isinstance(bc, BounceBackHalfway) or isinstance(bc, BounceBackMoving):\n                solid_indices[i].append(np.array(bc.indices).T)\n    for i in range(self.n_components):\n        index = None\n        if not len(solid_indices[i]) == 0:\n            index = np.vstack(solid_indices[i])\n        if self.dim == 2:\n            shape = (self.nx, self.ny, 1)\n            mask = jnp.zeros(shape, dtype=jnp.int8)\n            if index is not None:\n                mask = mask.at[index[:, 0], index[:, 1], 0].set(1)\n            mask = self.streaming(jnp.repeat(mask, axis=-1, repeats=self.q))\n            solid_mask.append(mask)\n        else:\n            shape = (self.nx, self.ny, self.nz, 1)\n            mask = jnp.zeros(shape, dtype=jnp.int8)\n            if index is not None:\n                mask = mask.at[index[:, 0], index[:, 1], index[:, 2], 0].set(1)\n            mask = self.streaming(jnp.repeat(mask, axis=-1, repeats=self.q))\n            solid_mask.append(mask)\n    return solid_mask\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.handle_io_timestep","title":"handle_io_timestep","text":"<pre><code>handle_io_timestep(timestep, f_tree, fstar_tree, p_tree, p_total, u_tree, u_total, rho_total, rho_tree, p_prev_tree, p_prev_total, u_total_prev, u_prev_tree, rho_total_prev, rho_prev_tree)\n</code></pre> <p>This function handles the input/output (I/O) operations at each time step of the simulation.</p> <p>It prepares the data to be saved and calls the output_data function, which can be overwritten by the user to customize the I/O operations.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.handle_io_timestep--parameters","title":"Parameters","text":"<p>timestep (int): The current time step of the simulation.</p> <p>f_tree (pytree of jax.numpy.ndarray): Post-streaming distribution functions at the current time step.</p> <p>fstar_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions at the current time step.</p> <p>p_tree (pytree of jax.numpy.ndarray): Pressure field at the current time step.</p> <p>p (jax.numpy.ndarray): Total pressure field at the current time step.</p> <p>u_total (jax.numpy.ndarray): Total velocity field at the current time step.</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field at the current time step.</p> <p>rho_total (jax.numpy.ndarray): Total density field at the current time step.</p> <p>rho_tree (pytree of jax.numpy.ndarray): Density field at the current time step.</p> <p>p_prev_tree (pytree of jax.numpy.ndarray): Pressure field at the previous time step.</p> <p>p_prev (jax.numpy.ndarray): Total pressure field at the previous time step.</p> <p>u_total_prev (jax.numpy.ndarray): Total velocity field at the previous time step.</p> <p>u_prev_tree (pytree of jax.numpy.ndarray): Velocity field at the previous time step.</p> <p>rho_total_prev (jax.numpy.ndarray): Total density field at the previous time step.</p> <p>rho_prev_tree: (ytree of jax.numpy.ndarray): Density field at the previous time step.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.handle_io_timestep--returns","title":"Returns","text":"<p>None</p> Source code in <code>src/multiphase.py</code> <pre><code>def handle_io_timestep(\n    self,\n    timestep,\n    f_tree,\n    fstar_tree,\n    p_tree,\n    p_total,\n    u_tree,\n    u_total,\n    rho_total,\n    rho_tree,\n    p_prev_tree,\n    p_prev_total,\n    u_total_prev,\n    u_prev_tree,\n    rho_total_prev,\n    rho_prev_tree,\n):\n    \"\"\"\n    This function handles the input/output (I/O) operations at each time step of the simulation.\n\n    It prepares the data to be saved and calls the output_data function, which can be overwritten\n    by the user to customize the I/O operations.\n\n    Parameters\n    ----------\n    timestep (int): The current time step of the simulation.\n\n    f_tree (pytree of jax.numpy.ndarray): Post-streaming distribution functions at the current time step.\n\n    fstar_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions at the current time step.\n\n    p_tree (pytree of jax.numpy.ndarray): Pressure field at the current time step.\n\n    p (jax.numpy.ndarray): Total pressure field at the current time step.\n\n    u_total (jax.numpy.ndarray): Total velocity field at the current time step.\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field at the current time step.\n\n    rho_total (jax.numpy.ndarray): Total density field at the current time step.\n\n    rho_tree (pytree of jax.numpy.ndarray): Density field at the current time step.\n\n    p_prev_tree (pytree of jax.numpy.ndarray): Pressure field at the previous time step.\n\n    p_prev (jax.numpy.ndarray): Total pressure field at the previous time step.\n\n    u_total_prev (jax.numpy.ndarray): Total velocity field at the previous time step.\n\n    u_prev_tree (pytree of jax.numpy.ndarray): Velocity field at the previous time step.\n\n    rho_total_prev (jax.numpy.ndarray): Total density field at the previous time step.\n\n    rho_prev_tree: (ytree of jax.numpy.ndarray): Density field at the previous time step.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    kwargs = {\n        \"n_components\": self.n_components,\n        \"timestep\": timestep,\n        \"rho_total\": rho_total,\n        \"rho_tree\": rho_tree,\n        \"p_tree\": p_tree,\n        \"p\": p_total,\n        \"u_total\": u_total,\n        \"u_tree\": u_tree,\n        \"rho_total_prev\": rho_total_prev,\n        \"rho_prev_tree\": rho_prev_tree,\n        \"p_prev_tree\": p_prev_tree,\n        \"p_prev\": p_prev_total,\n        \"u_total_prev\": u_total_prev,\n        \"u_prev_tree\": u_prev_tree,\n        \"f_poststreaming_tree\": f_tree,\n        \"f_postcollision_tree\": fstar_tree,\n    }\n    self.output_data(**kwargs)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.macroscopic_velocity","title":"macroscopic_velocity","text":"<pre><code>macroscopic_velocity(f_tree, rho_tree)\n</code></pre> <p>macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.macroscopic_velocity--parameters","title":"Parameters","text":"<p>f_tree (pytree of jax.numpy.ndarray): Distribution field.</p> <p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.macroscopic_velocity--returns","title":"Returns","text":"<p>u_tree (pytree of jax.numpy.ndarray): Velocity field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef macroscopic_velocity(self, f_tree, rho_tree):\n    \"\"\"\n    macroscopic_velocity computes the velocity and incorporates forces into velocity for Exact Difference Method (EDM) (used for SRT and MRT collision) models\n    and the consistent forcing scheme developed by LinLin Fei et. al (for Cascaded LBM). This is used for post-processing only and not for equilibrium distribution computation.\n\n    Parameters\n    ----------\n    f_tree (pytree of jax.numpy.ndarray): Distribution field.\n\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    Returns\n    -------\n    u_tree (pytree of jax.numpy.ndarray): Velocity field.\n    \"\"\"\n    # rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    u_tree = map(lambda f, rho: jnp.dot(f, c) / rho, f_tree, rho_tree)\n    F_tree = self.compute_force(rho_tree)\n    return map(lambda rho, u, F: u + 0.5 * F / rho, rho_tree, u_tree, F_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.run","title":"run","text":"<pre><code>run(t_max)\n</code></pre> <p>This function runs the LBM simulation for a specified number of time steps.</p> <p>It first initializes the distribution functions and then enters a loop where it performs the simulation steps (collision, streaming, and boundary conditions) for each time step.</p> <p>The function can also print the progress of the simulation, save the simulation data, and compute the performance of the simulation in million lattice updates per second (MLUPS).</p>"},{"location":"multiphase/#src.multiphase.Multiphase.run--parameters","title":"Parameters","text":"<p>t_max (int): The total number of time steps to run the simulation.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.run--returns","title":"Returns","text":"<p>f_tree (pytree of jax.numpy.ndarray): Distribution function after t_max timesteps.</p> Source code in <code>src/multiphase.py</code> <pre><code>def run(self, t_max):\n    \"\"\"\n    This function runs the LBM simulation for a specified number of time steps.\n\n    It first initializes the distribution functions and then enters a loop where it performs the\n    simulation steps (collision, streaming, and boundary conditions) for each time step.\n\n    The function can also print the progress of the simulation, save the simulation data, and\n    compute the performance of the simulation in million lattice updates per second (MLUPS).\n\n    Parameters\n    ----------\n    t_max (int): The total number of time steps to run the simulation.\n\n    Returns\n    -------\n    f_tree (pytree of jax.numpy.ndarray): Distribution function after t_max timesteps.\n    \"\"\"\n    f_tree = self.assign_fields_sharded()\n    start_step = 0\n    if self.restore_checkpoint:\n        latest_step = self.mngr.latest_step()\n        if latest_step is not None:  # existing checkpoint present\n            # Assert that the checkpoint manager is not None\n            assert self.mngr is not None, \"Checkpoint manager does not exist.\"\n            state = {}\n            c_name = lambda i: f\"component_{i}\"\n            for i in range(self.n_components):\n                state[c_name(i)] = f_tree[i]\n            # shardings = jax.map(lambda x: x.sharding, f_tree)\n            # restore_args = orb.checkpoint_utils.construct_restore_args(\n            #     f_tree, shardings\n            # )\n            try:\n                f_tree = self.mngr.restore(latest_step, args=orb.args.StandardRestore(state))\n                print(f\"Restored checkpoint at step {latest_step}.\")\n            except ValueError:\n                raise ValueError(f\"Failed to restore checkpoint at step {latest_step}.\")\n\n            start_step = latest_step + 1\n            if not (t_max &gt; start_step):\n                raise ValueError(f\"Simulation already exceeded maximum allowable steps (t_max  = {t_max}). Consider increasing t_max.\")\n\n    if self.computeMLUPS:\n        start = time.time()\n\n    # Loop over all time steps\n    for timestep in range(start_step, t_max + 1):\n        io_flag = self.ioRate &gt; 0 and (timestep % self.ioRate == 0 or timestep == t_max)\n        print_iter_flag = self.printInfoRate &gt; 0 and timestep % self.printInfoRate == 0\n        checkpoint_flag = self.checkpointRate &gt; 0 and timestep % self.checkpointRate == 0\n\n        if io_flag:\n            # Update the macroscopic variables and save the previous values (for error computation)\n            rho_prev_tree, _ = self.update_macroscopic(f_tree)\n            u_prev_tree = self.macroscopic_velocity(f_tree, rho_prev_tree)\n            rho_prev_tree = map(\n                lambda rho_prev: downsample_field(rho_prev, self.downsamplingFactor),\n                rho_prev_tree,\n            )\n            psi_prev_tree, _ = self.compute_potential(rho_prev_tree)\n            p_prev_tree = self.compute_pressure(rho_prev_tree, psi_prev_tree)\n            p_prev_total = self.compute_total_pressure(p_prev_tree, rho_prev_tree)\n            p_prev_total = downsample_field(p_prev_total, self.downsamplingFactor)\n            u_prev_tree = map(\n                lambda u_prev: downsample_field(u_prev, self.downsamplingFactor),\n                u_prev_tree,\n            )\n            rho_total_prev = self.compute_total_density(rho_prev_tree)\n            u_total_prev = self.compute_total_velocity(rho_prev_tree, u_prev_tree)\n\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            p_prev_total = process_allgather(p_prev_total)\n            rho_prev_tree = map(lambda rho_prev: process_allgather(rho_prev), rho_prev_tree)\n            u_prev_tree = map(lambda u_prev: process_allgather(u_prev), u_prev_tree)\n            rho_total_prev = process_allgather(rho_total_prev)\n            u_total_prev = process_allgather(u_total_prev)\n\n        # Perform one time-step (collision, streaming, and boundary conditions)\n        f_tree, fstar_tree = self.step(f_tree, timestep)\n\n        # Print the progress of the simulation\n        if print_iter_flag:\n            print(\n                colored(\"Timestep \", \"blue\")\n                + colored(f\"{timestep}\", \"green\")\n                + colored(\" of \", \"blue\")\n                + colored(f\"{t_max}\", \"green\")\n                + colored(\" completed\", \"blue\")\n            )\n\n        if io_flag:\n            # Save the simulation data\n            print(f\"Saving data at timestep {timestep}/{t_max}\")\n            rho_tree, _ = self.update_macroscopic(f_tree)\n            u_tree = self.macroscopic_velocity(f_tree, rho_tree)\n            psi_tree, _ = self.compute_potential(rho_tree)\n            p_tree = self.compute_pressure(rho_tree, psi_tree)\n            p_total = self.compute_total_pressure(p_tree, rho_tree)\n            p_total = downsample_field(p_total, self.downsamplingFactor)\n            rho_tree = map(\n                lambda rho: downsample_field(rho, self.downsamplingFactor),\n                rho_tree,\n            )\n            u_tree = map(lambda u: downsample_field(u, self.downsamplingFactor), u_tree)\n\n            rho_total = self.compute_total_density(rho_tree)\n            u_total = self.compute_total_velocity(rho_tree, u_tree)\n\n            # Gather the data from all processes and convert it to numpy arrays (move to host memory)\n            p_total = process_allgather(p_total)\n            rho_tree = map(lambda rho: process_allgather(rho), rho_tree)\n            u_tree = map(lambda u: process_allgather(u), u_tree)\n            rho_total = process_allgather(rho_total)\n            u_total = process_allgather(u_total)\n\n            # Save the data\n            self.handle_io_timestep(\n                timestep,\n                f_tree,\n                fstar_tree,\n                p_tree,\n                p_total,\n                u_tree,\n                u_total,\n                rho_total,\n                rho_tree,\n                p_prev_tree,\n                p_prev_total,\n                u_total_prev,\n                u_prev_tree,\n                rho_total_prev,\n                rho_prev_tree,\n            )\n\n        if checkpoint_flag:\n            # Save the checkpoint\n            print(f\"Saving checkpoint at timestep {timestep}/{t_max}\")\n            state = {}\n            c_name = lambda i: f\"component_{i}\"\n            for i in range(self.n_components):\n                state[c_name(i)] = f_tree[i]\n\n            self.mngr.save(timestep, args=orb.args.StandardSave(state))\n\n        # Start the timer for the MLUPS computation after the first timestep (to remove compilation overhead)\n        if self.computeMLUPS and timestep == 1:\n            jax.block_until_ready(f_tree)\n            start = time.time()\n\n    if self.computeMLUPS:\n        # Compute and print the performance of the simulation in MLUPS\n        jax.block_until_ready(f_tree)\n        end = time.time()\n        if self.dim == 2:\n            print(\n                colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny}\", \"green\")\n                if self.dim == 2\n                else colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\")\n            )\n            print(\n                colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny}\", \"green\")\n                if self.dim == 2\n                else colored(f\"{self.nx * self.ny * self.nz}\", \"green\")\n            )\n            print(\n                colored(\"MLUPS: \", \"blue\")\n                + colored(\n                    f\"{self.n_components * self.nx * self.ny * t_max / (end - start) / 1e6}\",\n                    \"red\",\n                )\n            )\n\n        elif self.dim == 3:\n            print(colored(\"Domain: \", \"blue\") + colored(f\"{self.nx} x {self.ny} x {self.nz}\", \"green\"))\n            print(colored(\"Number of voxels: \", \"blue\") + colored(f\"{self.nx * self.ny * self.nz}\", \"green\"))\n            print(\n                colored(\"MLUPS: \", \"blue\")\n                + colored(\n                    f\"{self.n_components * self.nx * self.ny * self.nz * t_max / (end - start) / 1e6}\",\n                    \"red\",\n                )\n            )\n    if self.mngr is not None:\n        self.mngr.wait_until_finished()\n    return f_tree\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.step","title":"step","text":"<pre><code>step(f_poststreaming_tree, timestep, return_fpost=False)\n</code></pre> <p>This function performs a single step of the LBM simulation.</p> <p>It first performs the collision step, which is the relaxation of the distribution functions towards their equilibrium values. It then applies the respective boundary conditions to the post-collision distribution functions.</p> <p>The function then performs the streaming step, which is the propagation of the distribution functions in the lattice. It then applies the respective boundary conditions to the post-streaming distribution functions.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.step--parameters","title":"Parameters","text":"<p>fin_tree (pytree of jax.numpy.ndarray): Post-streaming distribution function.</p> <p>timestep (int): Current timestep</p> <p>return_fpost (bool): Return post-collision distribution function (pytree).</p>"},{"location":"multiphase/#src.multiphase.Multiphase.step--returns","title":"Returns","text":"<p>f_poststreaming_tree (pytree of jax.numpy.ndarray): Post-streamed distribution function.</p> <p>f_collision_tree (pytree of jax.numpy.ndarray {Optional}): Post-collision distribution function.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0, 3), donate_argnums=(1,))\ndef step(self, f_poststreaming_tree, timestep, return_fpost=False):\n    \"\"\"\n    This function performs a single step of the LBM simulation.\n\n    It first performs the collision step, which is the relaxation of the distribution functions\n    towards their equilibrium values. It then applies the respective boundary conditions to the\n    post-collision distribution functions.\n\n    The function then performs the streaming step, which is the propagation of the distribution\n    functions in the lattice. It then applies the respective boundary conditions to the post-streaming\n    distribution functions.\n\n    Parameters\n    ----------\n    fin_tree (pytree of jax.numpy.ndarray): Post-streaming distribution function.\n\n    timestep (int): Current timestep\n\n    return_fpost (bool): Return post-collision distribution function (pytree).\n\n    Returns\n    -------\n    f_poststreaming_tree (pytree of jax.numpy.ndarray): Post-streamed distribution function.\n\n    f_collision_tree (pytree of jax.numpy.ndarray {Optional}): Post-collision distribution function.\n    \"\"\"\n    f_postcollision_tree = self.collision(f_poststreaming_tree)\n    f_postcollision_tree = self.apply_bc(f_postcollision_tree, f_poststreaming_tree, timestep, \"PostCollision\")\n    f_poststreaming_tree = map(lambda f_postcollision: self.streaming(f_postcollision), f_postcollision_tree)\n    f_poststreaming_tree = self.apply_bc(f_poststreaming_tree, f_postcollision_tree, timestep, \"PostStreaming\")\n\n    if return_fpost:\n        return f_poststreaming_tree, f_postcollision_tree\n    else:\n        return f_poststreaming_tree, None\n</code></pre>"},{"location":"multiphase/#src.multiphase.Multiphase.update_macroscopic","title":"update_macroscopic","text":"<pre><code>update_macroscopic(f_tree)\n</code></pre> <p>update_macroscopic from base.py extended to pytrees.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.update_macroscopic--parameters","title":"Parameters","text":"<p>f_tree (pytree of jax.numpy.ndarray): Distribution field.</p>"},{"location":"multiphase/#src.multiphase.Multiphase.update_macroscopic--returns","title":"Returns","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field. u_tree (pytree of jax.numpy.ndarray): Velocity field.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef update_macroscopic(self, f_tree):\n    \"\"\"\n    update_macroscopic from base.py extended to pytrees.\n\n    Parameters\n    ----------\n    f_tree (pytree of jax.numpy.ndarray): Distribution field.\n\n    Returns\n    -------\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n    u_tree (pytree of jax.numpy.ndarray): Velocity field.\n    \"\"\"\n    rho_tree = map(lambda f: jnp.sum(f, axis=-1, keepdims=True), f_tree)\n    c = jnp.array(self.c, dtype=self.precisionPolicy.compute_dtype).T\n    u_tree = map(lambda f, rho: jnp.dot(f, c) / rho, f_tree, rho_tree)  # Component velocity\n    return rho_tree, u_tree\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseBGK.collision","title":"collision","text":"<pre><code>collision(fin_tree)\n</code></pre> <p>BGK collision step for lattice, extended to pytrees.</p> <p>The collision step is where the main physics of the LBM is applied. In the BGK approximation, the distribution function is relaxed towards the equilibrium distribution function.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin_tree):\n    \"\"\"\n    BGK collision step for lattice, extended to pytrees.\n\n    The collision step is where the main physics of the LBM is applied. In the BGK approximation,\n    the distribution function is relaxed towards the equilibrium distribution function.\n    \"\"\"\n    fin_tree = map(lambda fin: self.precisionPolicy.cast_to_compute(fin), fin_tree)\n    rho_tree, u_tree = self.update_macroscopic(fin_tree)\n    feq_tree = self.equilibrium(rho_tree, u_tree, cast_output=False)\n    fneq_tree = map(lambda feq, fin: feq - fin, feq_tree, fin_tree)\n    fout_tree = map(lambda fin, fneq, omega: fin + omega * fneq, fin_tree, fneq_tree, self.omega)\n\n    fout_tree = self.apply_force(fout_tree, feq_tree, rho_tree, u_tree)\n\n    return map(lambda fout: self.precisionPolicy.cast_to_output(fout), fout_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseMRT.apply_force","title":"apply_force","text":"<pre><code>apply_force(m_tree, meq_tree, rho_tree, u_tree)\n</code></pre> <p>Modified version of the apply_force defined in LBMBase to account for modified force.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseMRT.apply_force--parameters","title":"Parameters","text":"<p>m_tree (pytree of jax.numpy.ndarray): Post-collision distribution function.</p> <p>meq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution function.</p> <p>rho_tree (pytree of jax.numpy.ndarray): Density field for all components.</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field for all components.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseMRT.apply_force--returns","title":"Returns","text":"<p>f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions with the force applied.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, m_tree, meq_tree, rho_tree, u_tree):\n    \"\"\"\n    Modified version of the apply_force defined in LBMBase to account for modified force.\n\n    Parameters\n    ----------\n    m_tree (pytree of jax.numpy.ndarray): Post-collision distribution function.\n\n    meq_tree (pytree of jax.numpy.ndarray): Equilibrium distribution function.\n\n    rho_tree (pytree of jax.numpy.ndarray): Density field for all components.\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field for all components.\n\n    Returns\n    -------\n    f_postcollision_tree (pytree of jax.numpy.ndarray): Post-collision distribution functions with the force applied.\n    \"\"\"\n    F_tree = self.compute_force(rho_tree)\n\n    delta_u_tree = map(lambda F, rho: F / rho, F_tree, rho_tree)\n    u_temp_tree = map(lambda u, delta_u: u + delta_u, u_tree, delta_u_tree)\n    feq_force_tree = self.equilibrium(rho_tree, u_temp_tree, cast_output=False)\n    meq_force_tree = map(lambda feq, M: jnp.dot(feq, M), feq_force_tree, self.M)\n    return map(\n        lambda m, meq_force, meq: m + meq_force - meq,\n        m_tree,\n        meq_force_tree,\n        meq_tree,\n    )\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseMRT.collision","title":"collision","text":"<pre><code>collision(fin_tree)\n</code></pre> <p>MRT collision step for lattice.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin_tree):\n    \"\"\"\n    MRT collision step for lattice.\n    \"\"\"\n    fin_tree = map(lambda f: self.precisionPolicy.cast_to_compute(f), fin_tree)\n    rho_tree, u_tree = self.update_macroscopic(fin_tree)\n    m_tree = map(lambda f, M: jnp.dot(f, M), fin_tree, self.M)\n    feq_tree = self.equilibrium(rho_tree, u_tree, cast_output=False)\n    meq_tree = map(lambda feq, M: jnp.dot(feq, M), feq_tree, self.M)\n    psi_tree, _ = self.compute_potential(rho_tree)\n    C_tree = self.adjust_surface_tension(psi_tree)\n    mout_tree = map(\n        lambda m, meq, S: m - jnp.dot(m - meq, S),\n        m_tree,\n        meq_tree,\n        self.S,\n    )\n    mout_tree = self.apply_force(mout_tree, meq_tree, rho_tree, u_tree)\n    fout_tree = map(lambda m, Minv, C: jnp.dot(m + C, Minv), mout_tree, self.M_inv, C_tree)\n    # fout_tree = self.apply_force(fout_tree, feq_tree, rho_tree, u_tree)\n    return map(\n        lambda fout: self.precisionPolicy.cast_to_output(fout),\n        fout_tree,\n    )\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.apply_force","title":"apply_force","text":"<pre><code>apply_force(Tdash_tree, rho_tree, u_tree)\n</code></pre> <p>Modified version of the apply_force defined in LBMBase to account for modified force.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.apply_force--parameters","title":"Parameters","text":"<p>Tdash_tree (pytree of jax.numpy.ndarray): Central moments of post-collision distribution functions.</p> <p>rho_tree (pytree of jax.numpy.ndarray): Density field.</p> <p>u_tree (pytree of jax.numpy.ndarray): Velocity field.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.apply_force--returns","title":"Returns","text":"<p>f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution functions with the force applied.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), inline=True)\ndef apply_force(self, Tdash_tree, rho_tree, u_tree):\n    \"\"\"\n    Modified version of the apply_force defined in LBMBase to account for modified force.\n\n    Parameters\n    ----------\n    Tdash_tree (pytree of jax.numpy.ndarray): Central moments of post-collision distribution functions.\n\n    rho_tree (pytree of jax.numpy.ndarray): Density field.\n\n    u_tree (pytree of jax.numpy.ndarray): Velocity field.\n\n    Returns\n    -------\n    f_postcollision_tree (pytree of jax.numpy.ndarray): The post-collision distribution functions with the force applied.\n    \"\"\"\n    F_tree = self.compute_force(rho_tree)\n    psi_tree, _ = self.compute_potential(rho_tree)\n    C_tree = self.compute_force_central_moments(F_tree, psi_tree)\n    Tf_tree = map(lambda S, C: jnp.dot(C, jnp.eye(self.lattice.q) - 0.5 * S), self.S, C_tree)\n    return map(lambda Tdash, Tf: Tdash + Tf, Tdash_tree, Tf_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.collision","title":"collision","text":"<pre><code>collision(fin_tree)\n</code></pre> <p>Cascaded LBM collision step for lattice.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,), donate_argnums=(1,))\ndef collision(self, fin_tree):\n    \"\"\"\n    Cascaded LBM collision step for lattice.\n    \"\"\"\n    fin_tree = map(lambda f: self.precisionPolicy.cast_to_compute(f), fin_tree)\n    rho_tree, _ = self.update_macroscopic(fin_tree)\n    u_tree = self.macroscopic_velocity(fin_tree, rho_tree)\n    T_tree = map(lambda f, M: jnp.dot(f, M), fin_tree, self.M)\n    Tdash_tree = self.compute_central_moment(T_tree, u_tree)\n    Tdash_eq_tree = self.compute_eq_central_moments(rho_tree)\n    Tout_tree = map(\n        lambda Tdash, Tdash_eq, S: jnp.dot(Tdash, jnp.eye(self.lattice.q) - S) + jnp.dot(Tdash_eq, S), Tdash_tree, Tdash_eq_tree, self.S\n    )\n    Tout_tree = self.apply_force(Tout_tree, rho_tree, u_tree)\n    Tout_tree = self.compute_central_moment_inverse(Tout_tree, u_tree)\n    fout_tree = map(lambda T, Minv: jnp.dot(T, Minv), Tout_tree, self.M_inv)\n    return map(lambda fout: self.precisionPolicy.cast_to_output(fout), fout_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_eq_central_moments","title":"compute_eq_central_moments","text":"<pre><code>compute_eq_central_moments(rho_tree)\n</code></pre> <p>Calculate the central moments of the equilibrium distribution.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_eq_central_moments--parameters","title":"Parameters","text":"<p>rho_tree (pytree of jax.numpy.ndarray): Density field for all components.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_eq_central_moments--returns","title":"Returns","text":"<p>T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the equilibrium distribution.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_eq_central_moments(self, rho_tree):\n    \"\"\"\n    Calculate the central moments of the equilibrium distribution.\n\n    Parameters\n    ----------\n    rho_tree (pytree of jax.numpy.ndarray): Density field for all components.\n\n    Returns\n    -------\n    T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the equilibrium distribution.\n    \"\"\"\n\n    def f(rho):\n        if isinstance(self.lattice, LatticeD2Q9):\n            T_eq = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 3].set(2 * rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs**4)\n\n            return T_eq\n\n        elif isinstance(self.lattice, LatticeD3Q19):\n            T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 16].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n\n            return T_eq\n\n        elif isinstance(self.lattice, LatticeD3Q27):\n            T_eq = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            T_eq = T_eq.at[..., 0].set(rho[..., 0])\n            T_eq = T_eq.at[..., 7].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 8].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 9].set(rho[..., 0] * self.lattice.cs2)\n            T_eq = T_eq.at[..., 17].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 18].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 19].set(rho[..., 0] * self.lattice.cs**4)\n            T_eq = T_eq.at[..., 26].set(rho[..., 0] * self.lattice.cs**6)\n\n            return T_eq\n\n    return map(lambda rho: f(rho), rho_tree)\n</code></pre>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_force_central_moments","title":"compute_force_central_moments","text":"<pre><code>compute_force_central_moments(F_tree, psi_tree)\n</code></pre> <p>Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_force_central_moments--parameters","title":"Parameters","text":"<p>F_tree (pytree of jax.numpy.ndarray): Force field.</p> <p>psi_tree (pytree of jax.numpy.ndarray): Potential field.</p>"},{"location":"multiphase/#src.multiphase.MultiphaseCascade.compute_force_central_moments--returns","title":"Returns","text":"<p>T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the force distribution.</p> Source code in <code>src/multiphase.py</code> <pre><code>@partial(jit, static_argnums=(0,))\ndef compute_force_central_moments(self, F_tree, psi_tree):\n    \"\"\"\n    Calculate the central moments of the force distribution. Includes modification to accurately replicate mechanical stability conditions.\n\n    Parameters\n    ----------\n    F_tree (pytree of jax.numpy.ndarray): Force field.\n\n    psi_tree (pytree of jax.numpy.ndarray): Potential field.\n\n    Returns\n    -------\n    T_eq_tree (pytree of jax.numpy.ndarray): Central moments of the force distribution.\n    \"\"\"\n\n    def f(F, sigma, psi, s_b):\n        if isinstance(self.lattice, LatticeD2Q9):\n            C = jnp.zeros((self.nx, self.ny, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            eta = 4 * sigma * (Fx**2 + Fy**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))  # For mechanical stability\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 3].set(eta)\n            C = C.at[..., 6].set(Fy * self.lattice.cs2)\n            C = C.at[..., 7].set(Fx * self.lattice.cs2)\n            C = C.at[..., 8].set(eta * self.lattice.cs2)\n\n            return C\n        elif isinstance(self.lattice, LatticeD3Q19):\n            C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            Fz = F[..., 2]\n            eta = 4 * sigma * (Fx**2 + Fy**2 + Fz**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 3].set(Fz)\n            C = C.at[..., 7].set(eta)\n            C = C.at[..., 8].set(eta)\n            C = C.at[..., 9].set(eta)\n            C = C.at[..., 10].set(Fx * self.lattice.cs2)\n            C = C.at[..., 11].set(Fx * self.lattice.cs2)\n            C = C.at[..., 12].set(Fy * self.lattice.cs2)\n            C = C.at[..., 13].set(Fz * self.lattice.cs2)\n            C = C.at[..., 14].set(Fy * self.lattice.cs2)\n            C = C.at[..., 15].set(Fz * self.lattice.cs2)\n\n            return C\n        elif isinstance(self.lattice, LatticeD3Q27):\n            C = jnp.zeros((self.nx, self.ny, self.nz, self.lattice.q), dtype=self.precisionPolicy.compute_dtype)\n            Fx = F[..., 0]\n            Fy = F[..., 1]\n            Fz = F[..., 2]\n            C = C.at[..., 1].set(Fx)\n            C = C.at[..., 2].set(Fy)\n            C = C.at[..., 3].set(Fz)\n            eta = 4 * sigma * (Fx**2 + Fy**2 + Fz**2) / ((psi[..., 0] ** 2) * (1 / s_b - 0.5))\n            C = C.at[..., 7].set(eta)\n            C = C.at[..., 8].set(eta)\n            C = C.at[..., 9].set(eta)\n            C = C.at[..., 10].set(Fx * self.lattice.cs2)\n            C = C.at[..., 11].set(Fx * self.lattice.cs2)\n            C = C.at[..., 12].set(Fy * self.lattice.cs2)\n            C = C.at[..., 13].set(Fz * self.lattice.cs2)\n            C = C.at[..., 14].set(Fy * self.lattice.cs2)\n            C = C.at[..., 15].set(Fz * self.lattice.cs2)\n            C = C.at[..., 23].set(Fx * self.lattice.cs**4)\n            C = C.at[..., 24].set(Fy * self.lattice.cs**4)\n            C = C.at[..., 25].set(Fz * self.lattice.cs**4)\n\n            return C\n\n    return map(lambda F, sigma, psi, s_b: f(F, sigma, psi, s_b), F_tree, self.sigma, psi_tree, self.s_b)\n</code></pre>"},{"location":"utils/","title":"JAX-LaB utils","text":"<p>Downsample a JAX array by a factor of <code>factor</code> along each axis.</p> <p>Save an image of a field at a given timestep.</p> <p>Save VTK fields to the specified directory.</p> <p>Live rendering of a 3D volume using pyvista.</p> <p>Save boundary conditions as VTK format to the specified directory.</p> <p>Rotates a voxelized mesh around a given axis.</p> <p>Converts an STL file to a voxelized mesh.</p>"},{"location":"utils/#src.utils.downsample_field--parameters","title":"Parameters","text":"<p>field : jax.numpy.ndarray     The input vector field to be downsampled. This should be a 3D or 4D JAX array where the last dimension is 2 or 3 (vector components). factor : int     The factor by which to downsample the field. The dimensions of the field will be divided by this factor. method : str, optional     The method to use for downsampling. Default is \u2018bicubic\u2019.</p>"},{"location":"utils/#src.utils.downsample_field--returns","title":"Returns","text":"<p>jax.numpy.ndarray     The downsampled field.</p> Source code in <code>src/utils.py</code> <pre><code>@partial(jit, static_argnums=(1, 2))\ndef downsample_field(field, factor, method=\"bicubic\"):\n    \"\"\"\n    Downsample a JAX array by a factor of `factor` along each axis.\n\n    Parameters\n    ----------\n    field : jax.numpy.ndarray\n        The input vector field to be downsampled. This should be a 3D or 4D JAX array where the last dimension is 2 or 3 (vector components).\n    factor : int\n        The factor by which to downsample the field. The dimensions of the field will be divided by this factor.\n    method : str, optional\n        The method to use for downsampling. Default is 'bicubic'.\n\n    Returns\n    -------\n    jax.numpy.ndarray\n        The downsampled field.\n    \"\"\"\n    if factor == 1:\n        return field\n    else:\n        new_shape = tuple(dim // factor for dim in field.shape[:-1])\n        downsampled_components = []\n        for i in range(field.shape[-1]):  # Iterate over the last dimension (vector components)\n            resized = resize(field[..., i], new_shape, method=method)\n            downsampled_components.append(resized)\n\n        return jnp.stack(downsampled_components, axis=-1)\n</code></pre>"},{"location":"utils/#src.utils.save_image--parameters","title":"Parameters","text":"<p>timestep : int     The timestep at which the field is being saved. fld : jax.numpy.ndarray     The field to be saved. This should be a 2D or 3D JAX array. If the field is 3D, the magnitude of the field will be calculated and saved. prefix : str, optional     A prefix to be added to the filename. The filename will be the name of the main script file by default.</p>"},{"location":"utils/#src.utils.save_image--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_image--notes","title":"Notes","text":"<p>This function saves the field as an image in the PNG format. The filename is based on the name of the main script file, the provided prefix, and the timestep number. If the field is 3D, the magnitude of the field is calculated and saved. The image is saved with the \u2018nipy_spectral\u2019 colormap and the origin set to \u2018lower\u2019.</p> Source code in <code>src/utils.py</code> <pre><code>def save_image(timestep, fld, prefix=None):\n    \"\"\"\n    Save an image of a field at a given timestep.\n\n    Parameters\n    ----------\n    timestep : int\n        The timestep at which the field is being saved.\n    fld : jax.numpy.ndarray\n        The field to be saved. This should be a 2D or 3D JAX array. If the field is 3D, the magnitude of the field will be calculated and saved.\n    prefix : str, optional\n        A prefix to be added to the filename. The filename will be the name of the main script file by default.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the field as an image in the PNG format. The filename is based on the name of the main script file, the provided prefix, and the timestep number.\n    If the field is 3D, the magnitude of the field is calculated and saved. The image is saved with the 'nipy_spectral' colormap and the origin set to 'lower'.\n    \"\"\"\n    fname = os.path.basename(__main__.__file__)\n    fname = os.path.splitext(fname)[0]\n    if prefix is not None:\n        fname = prefix + fname\n    fname = fname + \"_\" + str(timestep).zfill(4)\n\n    if len(fld.shape) &gt; 3:\n        raise ValueError(\"The input field should be 2D!\")\n    elif len(fld.shape) == 3:\n        fld = np.sqrt(fld[..., 0] ** 2 + fld[..., 1] ** 2)\n\n    plt.clf()\n    plt.imsave(fname + \".png\", fld.T, cmap=cm.nipy_spectral, origin=\"lower\")\n</code></pre>"},{"location":"utils/#src.utils.save_fields_vtk--parameters","title":"Parameters","text":"<p>timestep (int): The timestep number to be associated with the saved fields. fields (Dict[str, np.ndarray]): A dictionary of fields to be saved. Each field must be an array-like object     with dimensions (nx, ny) for 2D fields or (nx, ny, nz) for 3D fields, where:         - nx : int, number of grid points along the x-axis         - ny : int, number of grid points along the y-axis         - nz : int, number of grid points along the z-axis (for 3D fields only)     The key value for each field in the dictionary must be a string containing the name of the field. output_dir (str, optional, default: \u2018.\u2019): The directory in which to save the VTK files. Defaults to the current directory. prefix (str, optional, default: \u2018fields\u2019): A prefix to be added to the filename. Defaults to \u2018fields\u2019.</p>"},{"location":"utils/#src.utils.save_fields_vtk--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_fields_vtk--notes","title":"Notes","text":"<p>This function saves the VTK fields in the specified directory, with filenames based on the provided timestep number and the filename. For example, if the timestep number is 10 and the file name is fields, the VTK file will be saved as \u2018fields_0000010.vtk\u2019in the specified directory.</p> Source code in <code>src/utils.py</code> <pre><code>def save_fields_vtk(timestep, fields, output_dir=\".\", prefix=\"fields\"):\n    \"\"\"\n    Save VTK fields to the specified directory.\n\n    Parameters\n    ----------\n    timestep (int): The timestep number to be associated with the saved fields.\n    fields (Dict[str, np.ndarray]): A dictionary of fields to be saved. Each field must be an array-like object\n        with dimensions (nx, ny) for 2D fields or (nx, ny, nz) for 3D fields, where:\n            - nx : int, number of grid points along the x-axis\n            - ny : int, number of grid points along the y-axis\n            - nz : int, number of grid points along the z-axis (for 3D fields only)\n        The key value for each field in the dictionary must be a string containing the name of the field.\n    output_dir (str, optional, default: '.'): The directory in which to save the VTK files. Defaults to the current directory.\n    prefix (str, optional, default: 'fields'): A prefix to be added to the filename. Defaults to 'fields'.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the VTK fields in the specified directory, with filenames based on the provided timestep number\n    and the filename. For example, if the timestep number is 10 and the file name is fields, the VTK file\n    will be saved as 'fields_0000010.vtk'in the specified directory.\n\n    \"\"\"\n    # Assert that all fields have the same dimensions except for the last dimension assuming fields is a dictionary\n    for key, value in fields.items():\n        if key == list(fields.keys())[0]:\n            dimensions = value.shape\n        else:\n            assert value.shape == dimensions, \"All fields must have the same dimensions!\"\n\n    if not os.path.exists(\"./\" + output_dir):\n        print(\n            colored(\n                \"Directory does not exist, creating the directory \" + output_dir,\n                \"yellow\",\n            )\n        )\n        os.makedirs(output_dir)\n\n    output_filename = os.path.join(output_dir, prefix + \"_\" + f\"{timestep:07d}.vtk\")\n\n    # Add 1 to the dimensions tuple as we store cell values\n    dimensions = tuple([dim + 1 for dim in dimensions])\n\n    # Create a uniform grid\n    if value.ndim == 2:\n        dimensions = dimensions + (1,)\n\n    grid = pv.ImageData(dimensions=dimensions)\n\n    # Add the fields to the grid\n    for key, value in fields.items():\n        grid[key] = value.flatten(order=\"F\")\n\n    # Save the grid to a VTK file\n    start = time()\n    grid.save(output_filename, binary=True)\n    print(f\"Saved {output_filename} in {time() - start:.6f} seconds.\")\n</code></pre>"},{"location":"utils/#src.utils.live_volume_randering--parameters","title":"Parameters","text":"<p>field (np.ndarray): A 3D array containing the field to be rendered.</p>"},{"location":"utils/#src.utils.live_volume_randering--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.live_volume_randering--notes","title":"Notes","text":"<p>This function uses pyvista to render a 3D volume. The volume is rendered with a colormap based on the field values. The colormap is updated every 0.1 seconds to reflect changes to the field.</p> Source code in <code>src/utils.py</code> <pre><code>def live_volume_randering(timestep, field):\n    # WORK IN PROGRESS\n    \"\"\"\n    Live rendering of a 3D volume using pyvista.\n\n    Parameters\n    ----------\n    field (np.ndarray): A 3D array containing the field to be rendered.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function uses pyvista to render a 3D volume. The volume is rendered with a colormap based on the field values.\n    The colormap is updated every 0.1 seconds to reflect changes to the field.\n\n    \"\"\"\n    # Create a uniform grid (Note that the field must be 3D) otherwise raise error\n    if field.ndim != 3:\n        raise ValueError(\"The input field must be 3D!\")\n    dimensions = field.shape\n    grid = pv.ImageData(dimensions=dimensions)\n\n    # Add the field to the grid\n    grid[\"field\"] = field.flatten(order=\"F\")\n\n    # Create the rendering scene\n    if timestep == 0:\n        plt.ion()\n        plt.figure(figsize=(10, 10))\n        plt.axis(\"off\")\n        plt.title(\"Live rendering of the field\")\n        pl = pv.Plotter(off_screen=True)\n        pl.add_volume(grid, cmap=\"nipy_spectral\", opacity=\"sigmoid_10\", shade=False)\n        plt.imshow(pl.screenshot())\n\n    else:\n        pl = pv.Plotter(off_screen=True)\n        pl.add_volume(grid, cmap=\"nipy_spectral\", opacity=\"sigmoid_10\", shade=False)\n        # Update the rendering scene every 0.1 seconds\n        plt.imshow(pl.screenshot())\n        plt.pause(0.1)\n</code></pre>"},{"location":"utils/#src.utils.save_BCs_vtk--parameters","title":"Parameters","text":"<p>timestep (int): The timestep number to be associated with the saved fields. BCs (List[BC]): A list of boundary conditions to be saved. Each boundary condition must be an object of type BC.</p>"},{"location":"utils/#src.utils.save_BCs_vtk--returns","title":"Returns","text":"<p>None</p>"},{"location":"utils/#src.utils.save_BCs_vtk--notes","title":"Notes","text":"<p>This function saves the boundary conditions in the specified directory, with filenames based on the provided timestep number and the filename. For example, if the timestep number is 10, the VTK file will be saved as \u2018BCs_0000010.vtk\u2019in the specified directory.</p> Source code in <code>src/utils.py</code> <pre><code>def save_BCs_vtk(timestep, BCs, gridInfo, output_dir=\".\"):\n    \"\"\"\n    Save boundary conditions as VTK format to the specified directory.\n\n    Parameters\n    ----------\n    timestep (int): The timestep number to be associated with the saved fields.\n    BCs (List[BC]): A list of boundary conditions to be saved. Each boundary condition must be an object of type BC.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This function saves the boundary conditions in the specified directory, with filenames based on the provided timestep number\n    and the filename. For example, if the timestep number is 10, the VTK file\n    will be saved as 'BCs_0000010.vtk'in the specified directory.\n    \"\"\"\n\n    # Create a uniform grid\n    if gridInfo[\"nz\"] == 0:\n        gridDimensions = (gridInfo[\"nx\"] + 1, gridInfo[\"ny\"] + 1, 1)\n        fieldDimensions = (gridInfo[\"nx\"], gridInfo[\"ny\"], 1)\n    else:\n        gridDimensions = (gridInfo[\"nx\"] + 1, gridInfo[\"ny\"] + 1, gridInfo[\"nz\"] + 1)\n        fieldDimensions = (gridInfo[\"nx\"], gridInfo[\"ny\"], gridInfo[\"nz\"])\n\n    grid = pv.ImageData(dimensions=gridDimensions)\n\n    # Dictionary to keep track of encountered BC names\n    bcNamesCount = {}\n\n    for bc in BCs:\n        bcName = bc.name\n        if bcName in bcNamesCount:\n            bcNamesCount[bcName] += 1\n        else:\n            bcNamesCount[bcName] = 0\n        bcName += f\"_{bcNamesCount[bcName]}\"\n\n        if bc.isDynamic:\n            bcIndices, _ = bc.update_function(timestep)\n        else:\n            bcIndices = bc.indices\n\n        # Convert indices to 1D indices\n        if gridInfo[\"dim\"] == 2:\n            bcIndices = np.ravel_multi_index(bcIndices, fieldDimensions[:-1], order=\"F\")\n        else:\n            bcIndices = np.ravel_multi_index(bcIndices, fieldDimensions, order=\"F\")\n\n        grid[bcName] = np.zeros(fieldDimensions, dtype=bool).flatten(order=\"F\")\n        grid[bcName][bcIndices] = True\n\n    # Save the grid to a VTK file\n    output_filename = os.path.join(output_dir, \"BCs_\" + f\"{timestep:07d}.vtk\")\n\n    start = time()\n    grid.save(output_filename, binary=True)\n    print(f\"Saved {output_filename} in {time() - start:.6f} seconds.\")\n</code></pre>"},{"location":"utils/#src.utils.rotate_geometry--parameters","title":"Parameters","text":"<p>indices : array-like     The indices of the voxels in the mesh. origin : array-like     The coordinates of the origin of the rotation axis. axis : array-like     The direction vector of the rotation axis. This should be a 3-element sequence. angle : float     The angle by which to rotate the mesh, in radians.</p>"},{"location":"utils/#src.utils.rotate_geometry--returns","title":"Returns","text":"<p>tuple     The indices of the voxels in the rotated mesh.</p>"},{"location":"utils/#src.utils.rotate_geometry--notes","title":"Notes","text":"<p>This function rotates the mesh by applying a rotation matrix to the voxel indices. The rotation matrix is calculated using the axis-angle representation of rotations. The origin of the rotation axis is assumed to be at (0, 0, 0).</p> Source code in <code>src/utils.py</code> <pre><code>def rotate_geometry(indices, origin, axis, angle):\n    \"\"\"\n    Rotates a voxelized mesh around a given axis.\n\n    Parameters\n    ----------\n    indices : array-like\n        The indices of the voxels in the mesh.\n    origin : array-like\n        The coordinates of the origin of the rotation axis.\n    axis : array-like\n        The direction vector of the rotation axis. This should be a 3-element sequence.\n    angle : float\n        The angle by which to rotate the mesh, in radians.\n\n    Returns\n    -------\n    tuple\n        The indices of the voxels in the rotated mesh.\n\n    Notes\n    -----\n    This function rotates the mesh by applying a rotation matrix to the voxel indices. The rotation matrix is calculated\n    using the axis-angle representation of rotations. The origin of the rotation axis is assumed to be at (0, 0, 0).\n    \"\"\"\n    indices_rotated = (jnp.array(indices).T - origin) @ axangle2mat(axis, angle) + origin\n    return tuple(jnp.rint(indices_rotated).astype(\"int32\").T)\n</code></pre>"},{"location":"utils/#src.utils.voxelize_stl--parameters","title":"Parameters","text":"<p>stl_filename : str     The name of the STL file to be voxelized. length_lbm_unit : float, optional     The unit length in LBM. Either this or \u2018pitch\u2019 must be provided. tranformation_matrix : array-like, optional     A transformation matrix to be applied to the mesh before voxelization. pitch : float, optional     The pitch of the voxel grid. Either this or \u2018length_lbm_unit\u2019 must be provided.</p>"},{"location":"utils/#src.utils.voxelize_stl--returns","title":"Returns","text":"<p>trimesh.VoxelGrid, float     The voxelized mesh and the pitch of the voxel grid.</p>"},{"location":"utils/#src.utils.voxelize_stl--notes","title":"Notes","text":"<p>This function uses the trimesh library to load the STL file and voxelized the mesh. If a transformation matrix is provided, it is applied to the mesh before voxelization. The pitch of the voxel grid is calculated based on the maximum extent of the mesh and the provided lattice Boltzmann unit length, unless a pitch is provided directly.</p> Source code in <code>src/utils.py</code> <pre><code>def voxelize_stl(stl_filename, length_lbm_unit=None, tranformation_matrix=None, pitch=None):\n    \"\"\"\n    Converts an STL file to a voxelized mesh.\n\n    Parameters\n    ----------\n    stl_filename : str\n        The name of the STL file to be voxelized.\n    length_lbm_unit : float, optional\n        The unit length in LBM. Either this or 'pitch' must be provided.\n    tranformation_matrix : array-like, optional\n        A transformation matrix to be applied to the mesh before voxelization.\n    pitch : float, optional\n        The pitch of the voxel grid. Either this or 'length_lbm_unit' must be provided.\n\n    Returns\n    -------\n    trimesh.VoxelGrid, float\n        The voxelized mesh and the pitch of the voxel grid.\n\n    Notes\n    -----\n    This function uses the trimesh library to load the STL file and voxelized the mesh. If a transformation matrix is\n    provided, it is applied to the mesh before voxelization. The pitch of the voxel grid is calculated based on the\n    maximum extent of the mesh and the provided lattice Boltzmann unit length, unless a pitch is provided directly.\n    \"\"\"\n    if length_lbm_unit is None and pitch is None:\n        raise ValueError(\"Either 'length_lbm_unit' or 'pitch' must be provided!\")\n    mesh = trimesh.load_mesh(stl_filename, process=False)\n    length_phys_unit = mesh.extents.max()\n    if tranformation_matrix is not None:\n        mesh.apply_transform(tranformation_matrix)\n    if pitch is None:\n        pitch = length_phys_unit / length_lbm_unit\n    mesh_voxelized = mesh.voxelized(pitch=pitch)\n    return mesh_voxelized, pitch\n</code></pre>"}]}