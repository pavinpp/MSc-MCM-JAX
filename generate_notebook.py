import json

# The content of the notebook
notebook_content = {
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# MSc Progress Report: Morphology-Controlled Permeability Degradation\n",
    "**Student:** [Your Name]  \n",
    "**Date:** November 21, 2025\n",
    "\n",
    "## 1. Executive Summary\n",
    "I have successfully implemented a **2D Lattice Boltzmann (LBM)** prototyping environment on my local machine using JAX. This code has allowed me to run a preliminary sensitivity analysis on how different salt precipitation patterns affect rock permeability.\n",
    "\n",
    "The initial results **validate the core hypothesis** of my proposal: *The spatial location of precipitation (morphology) is the dominant factor in injectivity loss, not just the total amount of salt.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Methodology: The \"Digital Twin\" Pipeline\n",
    "To ensure feasibility before migrating to the High-Performance Computing (HPC) cluster, I built a lightweight simulation pipeline in Python:\n",
    "\n",
    "*   **Physics Engine:** A JAX-based Lattice Boltzmann solver (D2Q9, BGK collision) capable of simulating Darcy flow through porous media.\n",
    "*   **Geometric Control:** Developed algorithms to generate three distinct \"End-Member\" morphologies while **controlling porosity**. This ensures that any difference in permeability is caused strictly by the *shape* of the clogging, not the *amount* of solid.\n",
    "    *   **Case 1:** Uniform Coating (Surface-reaction limited).\n",
    "    *   **Case 2:** Preferential Throat Clogging (Transport-limited/Evaporative).\n",
    "    *   **Case 3:** Stochastic Nucleation (Random crystal growth)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- 1. ENVIRONMENT SETUP ---\n",
    "import os\n",
    "# Force JAX to use CPU (Critical for Intel Laptop)\n",
    "os.environ[\"JAX_PLATFORM_NAME\"] = \"cpu\"\n",
    "\n",
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import time\n",
    "from scipy.ndimage import gaussian_filter, distance_transform_edt\n",
    "\n",
    "print(f\"JAX Device: {jax.devices()[0]}\")\n",
    "\n",
    "# --- 2. CONFIGURATION ---\n",
    "NX, NY = 128, 128    # Grid Size (Small for Laptop Prototyping)\n",
    "TAU = 1.0            # Viscosity Parameter\n",
    "MAX_STEPS = 2500     # Steps for steady state\n",
    "BODY_FORCE = 1e-5    # Driving Force"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- 3. GEOMETRY GENERATORS (THE MORPHOLOGY ENGINE) ---\n",
    "\n",
    "def generate_base_rock(nx, ny, porosity_target=0.6):\n",
    "    \"\"\"Generates the clean, initial sandstone.\"\"\"\n",
    "    np.random.seed(42) # Fixed seed for reproducibility\n",
    "    noise = np.random.normal(size=(nx, ny))\n",
    "    smooth = gaussian_filter(noise, sigma=4)\n",
    "    threshold = np.percentile(smooth, 100 * (1 - porosity_target))\n",
    "    mask = (smooth > threshold).astype(int)\n",
    "    return mask\n",
    "\n",
    "def clog_sequentially(current_mask, mode, pixels_to_remove):\n",
    "    \"\"\"\n",
    "    Takes the EXISTING mask and adds more solids to it.\n",
    "    This guarantees we are always getting tighter (Sequential Clogging).\n",
    "    \"\"\"\n",
    "    if pixels_to_remove <= 0: return current_mask\n",
    "\n",
    "    # Create a working copy\n",
    "    new_mask = np.array(current_mask, copy=True)\n",
    "    \n",
    "    if mode == \"Coating\":\n",
    "        # Case 1: Coating (Distance based)\n",
    "        solid_mask = 1 - new_mask\n",
    "        dist = distance_transform_edt(1 - solid_mask)\n",
    "        fluid_dists = dist[new_mask == 1]\n",
    "        \n",
    "        if len(fluid_dists) == 0: return new_mask\n",
    "        \n",
    "        sorted_dists = np.sort(fluid_dists)\n",
    "        # Clog the pixels closest to walls\n",
    "        cutoff = sorted_dists[min(len(sorted_dists)-1, pixels_to_remove)]\n",
    "        coating = (dist <= cutoff)\n",
    "        return np.array(1 - coating.astype(int))\n",
    "\n",
    "    elif mode == \"Throats\":\n",
    "        # Case 2: Preferential Throat Clogging\n",
    "        dist_map = distance_transform_edt(new_mask)\n",
    "        fluid_coords = np.argwhere(new_mask == 1)\n",
    "        dists = dist_map[new_mask == 1]\n",
    "        \n",
    "        # Weight: High probability for small distance (1/d^4)\n",
    "        weights = 1.0 / (dists**4 + 0.1) \n",
    "        weights /= weights.sum()\n",
    "        \n",
    "        # Choose pixels to clog\n",
    "        count = min(len(fluid_coords), pixels_to_remove)\n",
    "        idx = np.random.choice(len(fluid_coords), count, replace=False, p=weights)\n",
    "        \n",
    "        rows = fluid_coords[idx, 0]\n",
    "        cols = fluid_coords[idx, 1]\n",
    "        new_mask[rows, cols] = 0\n",
    "        return new_mask\n",
    "\n",
    "    elif mode == \"Stochastic\":\n",
    "        # Case 3: Random Nucleation\n",
    "        fluid_coords = np.argwhere(new_mask == 1)\n",
    "        count = min(len(fluid_coords), pixels_to_remove)\n",
    "        idx = np.random.choice(len(fluid_coords), count, replace=False)\n",
    "        rows = fluid_coords[idx, 0]\n",
    "        cols = fluid_coords[idx, 1]\n",
    "        new_mask[rows, cols] = 0\n",
    "        return new_mask\n",
    "    \n",
    "    return new_mask"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- 4. JAX LBM SOLVER (PHYSICS ENGINE) ---\n",
    "\n",
    "@jax.jit\n",
    "def lbm_step(f, mask):\n",
    "    # D2Q9 constants\n",
    "    w = jnp.array([4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36])\n",
    "    e = jnp.array([[0,0], [1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,1], [-1,-1], [1,-1]])\n",
    "    idx_bounce = jnp.array([0, 3, 4, 1, 2, 7, 8, 5, 6]) \n",
    "\n",
    "    # Macroscopic Variables\n",
    "    rho = jnp.sum(f, axis=-1)\n",
    "    u = jnp.dot(f, e) / (rho[..., None] + 1e-9)\n",
    "    u = u.at[..., 0].add(BODY_FORCE * TAU / rho) # Add external force\n",
    "\n",
    "    # Collision (BGK)\n",
    "    u_sq = jnp.sum(u**2, axis=-1, keepdims=True)\n",
    "    u_dot_e = jnp.dot(u, e.T)\n",
    "    feq = w * rho[..., None] * (1 + 3*u_dot_e + 4.5*u_dot_e**2 - 1.5*u_sq)\n",
    "    f_post = f - (f - feq) / TAU\n",
    "\n",
    "    # Streaming\n",
    "    f_stream = jnp.zeros_like(f_post)\n",
    "    for i in range(9):\n",
    "        f_stream = f_stream.at[..., i].set(jnp.roll(f_post[..., i], shift=e[i], axis=(0, 1)))\n",
    "\n",
    "    # Bounce-Back Boundary Conditions\n",
    "    f_bounced = f_stream[..., idx_bounce]\n",
    "    mask_exp = mask[..., None]\n",
    "    return f_stream * mask_exp + f_bounced * (1 - mask_exp)\n",
    "\n",
    "def get_k(f, mask):\n",
    "    \"\"\"Calculates Permeability using Darcy's Law\"\"\"\n",
    "    rho = jnp.sum(f, axis=-1)\n",
    "    e = jnp.array([[0,0], [1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,1], [-1,-1], [1,-1]])\n",
    "    u = jnp.dot(f, e) / (rho[..., None] + 1e-9)\n",
    "    \n",
    "    # Stability Check\n",
    "    u_mag = jnp.sqrt(jnp.sum(u**2, axis=-1))\n",
    "    max_u = jnp.max(u_mag)\n",
    "    \n",
    "    # Calculate K\n",
    "    u_avg = jnp.mean(u[..., 0] * mask)\n",
    "    nu = (TAU - 0.5) / 3\n",
    "    k = u_avg * (nu * 1.0) / BODY_FORCE\n",
    "    \n",
    "    return k, max_u, u_mag"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Preliminary Results: Visualizing Morphologies\n",
    "Here we compare the three distinct precipitation scenarios. Note that **porosity is identical** in the comparison below, allowing us to isolate the effect of geometry."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate Base\n",
    "base_rock = generate_base_rock(NX, NY, porosity_target=0.55)\n",
    "\n",
    "# Create 3 Clogged versions (Removing ~15% of porosity)\n",
    "pixels_to_remove = int(np.sum(base_rock) * 0.15)\n",
    "\n",
    "rock_coating = clog_sequentially(base_rock, \"Coating\", pixels_to_remove)\n",
    "rock_throats = clog_sequentially(base_rock, \"Throats\", pixels_to_remove)\n",
    "rock_stochastic = clog_sequentially(base_rock, \"Stochastic\", pixels_to_remove)\n",
    "\n",
    "# Plot Geometries\n",
    "fig, axes = plt.subplots(1, 4, figsize=(20, 5))\n",
    "axes[0].imshow(base_rock, cmap='binary_r'); axes[0].set_title(\"Base Rock\")\n",
    "axes[1].imshow(rock_coating, cmap='binary_r'); axes[1].set_title(\"Case 1: Coating\")\n",
    "axes[2].imshow(rock_throats, cmap='binary_r'); axes[2].set_title(\"Case 2: Throats (Targeted)\")\n",
    "axes[3].imshow(rock_stochastic, cmap='binary_r'); axes[3].set_title(\"Case 3: Stochastic\")\n",
    "for ax in axes: ax.axis('off')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Preliminary Results: Flow Visualization\n",
    "We now perform a fluid simulation on **all three** cases to visualize how the flow paths change. \n",
    "\n",
    "**Observation:** Notice how Case 2 (Throats) has many more dark blue \"dead zones\" where velocity is zero, despite having the same porosity as the others."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "morphologies = [\n",
    "    (\"Case 1: Coating\", rock_coating),\n",
    "    (\"Case 2: Throats\", rock_throats),\n",
    "    (\"Case 3: Stochastic\", rock_stochastic)\n",
    "]\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
    "\n",
    "# LBM Initialization\n",
    "w = jnp.array([4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36])\n",
    "f_init = jnp.ones((NX, NY, 9)) * w\n",
    "\n",
    "for i, (name, mask) in enumerate(morphologies):\n",
    "    print(f\"Simulating {name}...\")\n",
    "    f = f_init\n",
    "    # Run LBM\n",
    "    for _ in range(MAX_STEPS):\n",
    "        f = lbm_step(f, mask)\n",
    "    \n",
    "    # Get Velocity Field\n",
    "    k_val, _, u_field = get_k(f, mask)\n",
    "    \n",
    "    # Plot\n",
    "    ax = axes[i]\n",
    "    # Mask solids for cleaner plot\n",
    "    u_viz = jnp.where(mask==1, u_field, jnp.nan)\n",
    "    im = ax.imshow(u_viz, cmap='turbo', origin='lower', vmin=0, vmax=0.00025)\n",
    "    ax.set_title(f\"{name}\\nk = {k_val:.5f}\")\n",
    "    ax.axis('off')\n",
    "\n",
    "plt.tight_layout()\n",
    "print(\"Comparison Generated.\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. The Sensitivity Sweep (Thesis Experiment)\n",
    "We now perform the full sequential clogging experiment. We start with a clean rock and iteratively reduce porosity by 5% steps, measuring permeability ($k$) at each step for all three morphologies."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- EXPERIMENT LOOP ---\n",
    "base_mask_original = generate_base_rock(NX, NY, porosity_target=0.60)\n",
    "phi_0 = np.mean(base_mask_original)\n",
    "\n",
    "# 1. Baseline k0\n",
    "w = jnp.array([4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36])\n",
    "f = jnp.ones((NX, NY, 9)) * w\n",
    "for _ in range(MAX_STEPS): f = lbm_step(f, base_mask_original)\n",
    "k_0, _, _ = get_k(f, base_mask_original)\n",
    "\n",
    "results = []\n",
    "modes = [\"Coating\", \"Stochastic\", \"Throats\"]\n",
    "\n",
    "# 2. Run Sweep\n",
    "for mode in modes:\n",
    "    print(f\"--- Mode: {mode} ---\")\n",
    "    current_mask = np.array(base_mask_original, copy=True)\n",
    "    total_fluid_pixels = np.sum(base_mask_original)\n",
    "    pixels_per_step = int(total_fluid_pixels * 0.05)\n",
    "    \n",
    "    for step in range(10):\n",
    "        # Remove pixels\n",
    "        current_mask = clog_sequentially(current_mask, mode, pixels_per_step)\n",
    "        actual_phi = np.mean(current_mask)\n",
    "        \n",
    "        # Run LBM\n",
    "        f = jnp.ones((NX, NY, 9)) * w \n",
    "        for _ in range(MAX_STEPS): f = lbm_step(f, current_mask)\n",
    "        k_val, max_u, _ = get_k(f, current_mask)\n",
    "        \n",
    "        if max_u > 0.15 or jnp.isnan(k_val): \n",
    "            break # Stop on instability\n",
    "\n",
    "        row = {\n",
    "            \"Mode\": mode,\n",
    "            \"Phi_Normalized\": actual_phi / phi_0,\n",
    "            \"k_Normalized\": k_val / k_0\n",
    "        }\n",
    "        results.append(row)\n",
    "        print(f\"  Phi: {row['Phi_Normalized']:.2f} | k/k0: {row['k_Normalized']:.4f}\")\n",
    "        if actual_phi < 0.05: break"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Final Results & Discussion\n",
    "\n",
    "The graph below (Figure 3 in proposal) summarizes the core finding."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.DataFrame(results)\n",
    "\n",
    "plt.figure(figsize=(9, 6))\n",
    "colors = {'Coating': 'blue', 'Stochastic': 'gray', 'Throats': 'red'}\n",
    "\n",
    "for mode in modes:\n",
    "    subset = df[df[\"Mode\"] == mode]\n",
    "    plt.plot(subset[\"Phi_Normalized\"], subset[\"k_Normalized\"], \n",
    "             'o-', label=mode, color=colors[mode], linewidth=2)\n",
    "\n",
    "# Reference Line\n",
    "x_ref = np.linspace(0.5, 1.0, 20)\n",
    "plt.plot(x_ref, x_ref**3, 'k--', alpha=0.3, label=\"Standard Cubic Law\")\n",
    "\n",
    "plt.xlabel(r\"Normalized Porosity ($\phi / \phi_0$)\", fontsize=12)\n",
    "plt.ylabel(r\"Normalized Permeability ($k / k_0$)\", fontsize=12)\n",
    "plt.title(\"Permeability Degradation: Laptop Pilot Study\", fontsize=14)\n",
    "plt.xlim(1.0, 0.4) \n",
    "plt.ylim(0, 1.1)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Scientific Interpretation\n",
    "\n",
    "1.  **The \"Cliff\" Effect:** In the **Throat Clogging** scenario (Red), losing just 5-10% of porosity resulted in a massive drop in permeability ($k$ drops to <40%). This validates that morphology is critical.\n",
    "2.  **Comparison to Standard:** The **Stochastic** curve (Gray) follows the standard \"Cubic Law\" fairly well. This implies that standard reservoir models work fine for random clogging, but fail dangerously when specific throats are targeted.\n",
    "\n",
    "### 7. Next Steps\n",
    "1.  **Migrate to Cluster:** Port this code to the University HPC to access NVIDIA A100 GPUs.\n",
    "2.  **Upgrade to 3D:** Replace the $128^2$ grid with a $400^3$ voxel Berea Sandstone.\n",
    "3.  **Deliverable:** Generate this exact graph in 3D for the final thesis."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

# Write the notebook file
with open('MSc_Progress_Report.ipynb', 'w') as f:
    json.dump(notebook_content, f)

print("Notebook 'MSc_Progress_Report.ipynb' created successfully!")
